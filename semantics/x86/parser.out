Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    NEG
    SEMICOLON

Grammar

Rule 0     S' -> stmts
Rule 1     stmts -> stmt
Rule 2     stmts -> stmts stmt
Rule 3     stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
Rule 4     stmt -> BREAK
Rule 5     stmt -> expr
Rule 6     stmt -> CASE expr OF cases ESAC
Rule 7     cases -> CASE_HEADER stmts
Rule 8     cases -> cases CASE_HEADER stmts
Rule 9     stmt -> RETURN expr
Rule 10    expr -> expr UPDATE expr
Rule 11    expr -> OP UPDATE ID
Rule 12    expr -> expr PLUS_EQUAL expr
Rule 13    expr -> expr OR_EQUAL expr
Rule 14    stmt -> DO WHILE expr stmts OD
Rule 15    stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR
Rule 16    stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
Rule 17    stmt -> IF expr THEN stmts FI
Rule 18    stmt -> IF expr THEN stmts ELSE stmts FI
Rule 19    stmt -> IF expr stmts FI
Rule 20    stmt -> IF expr stmts ELSE stmts FI
Rule 21    stmt -> IF expr stmts ELSE stmts
Rule 22    stmt -> PSEUDO
Rule 23    expr -> ID LPAREN args RPAREN
Rule 24    expr -> ID LPAREN RPAREN
Rule 25    expr -> ID LBRACKET expr RBRACKET
Rule 26    expr -> expr DOT ID
Rule 27    args -> expr
Rule 28    args -> args COMMA expr
Rule 29    expr -> expr LBRACE expr RBRACE
Rule 30    expr -> expr LBRACE expr COLON expr RBRACE
Rule 31    expr -> expr QUEST expr COLON expr
Rule 32    expr -> NOT expr
Rule 33    expr -> MINUS expr
Rule 34    expr -> BITWISE_NOT expr
Rule 35    expr -> expr BITWISE_AND expr
Rule 36    expr -> expr BITWISE_OR expr
Rule 37    expr -> expr OP expr
Rule 38    expr -> expr PLUS expr
Rule 39    expr -> expr MINUS expr
Rule 40    expr -> expr TIMES expr
Rule 41    expr -> expr DIV expr
Rule 42    expr -> expr MOD expr
Rule 43    expr -> expr AND expr
Rule 44    expr -> expr OR expr
Rule 45    expr -> expr LSHIFT expr
Rule 46    expr -> expr RSHIFT expr
Rule 47    expr -> expr LSHIFT_LOGICAL expr
Rule 48    expr -> expr RSHIFT_LOGICAL expr
Rule 49    expr -> expr GREATER expr
Rule 50    expr -> expr LESS expr
Rule 51    expr -> expr LESS_EQUAL expr
Rule 52    expr -> expr GREATER_EQUAL expr
Rule 53    expr -> expr EQUAL expr
Rule 54    expr -> expr NOT_EQUAL expr
Rule 55    expr -> expr XOR expr
Rule 56    expr -> LPAREN expr RPAREN
Rule 57    expr -> ID
Rule 58    expr -> NUMBER
Rule 59    expr -> PSEUDO

Terminals, with rules where they appear

AND                  : 43
BITWISE_AND          : 35
BITWISE_NOT          : 34
BITWISE_OR           : 36
BREAK                : 4
CASE                 : 6
CASE_HEADER          : 7 8
COLON                : 30 31
COMMA                : 28
COMMENT              : 
DEFINE               : 3
DIV                  : 41
DO                   : 14
DOT                  : 26
DOWNTO               : 16
ELSE                 : 18 20 21
ENDFOR               : 15 16
EQUAL                : 53
ESAC                 : 6
FI                   : 17 18 19 20
FOR                  : 15 16
GREATER              : 49
GREATER_EQUAL        : 52
ID                   : 3 11 15 16 23 24 25 26 57
IF                   : 17 18 19 20 21
LBRACE               : 29 30
LBRACKET             : 3 25
LESS                 : 50
LESS_EQUAL           : 51
LPAREN               : 3 23 24 56
LSHIFT               : 45
LSHIFT_LOGICAL       : 47
MINUS                : 33 39
MOD                  : 42
NEG                  : 
NOT                  : 32
NOT_EQUAL            : 54
NUMBER               : 58
OD                   : 14
OF                   : 6
OP                   : 11 37
OR                   : 44
OR_EQUAL             : 13
PLUS                 : 38
PLUS_EQUAL           : 12
PSEUDO               : 22 59
QUEST                : 31
RBRACE               : 29 30
RBRACKET             : 3 25
RETURN               : 9
RPAREN               : 3 23 24 56
RSHIFT               : 46
RSHIFT_LOGICAL       : 48
SEMICOLON            : 
THEN                 : 17 18
TIMES                : 40
TO                   : 15
UPDATE               : 10 11 15 16
WHILE                : 14
XOR                  : 55
error                : 

Nonterminals, with rules where they appear

args                 : 3 23 28
cases                : 6 8
expr                 : 5 6 9 10 10 12 12 13 13 14 15 15 16 16 17 18 19 20 21 25 26 27 28 29 29 30 30 30 31 31 31 32 33 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56
stmt                 : 1 2
stmts                : 2 3 7 8 14 15 16 17 18 18 19 20 20 21 21 0

Parsing method: LALR

state 0

    (0) S' -> . stmts
    (1) stmts -> . stmt
    (2) stmts -> . stmts stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    stmts                          shift and go to state 1
    stmt                           shift and go to state 2
    expr                           shift and go to state 7

state 1

    (0) S' -> stmts .
    (2) stmts -> stmts . stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    stmt                           shift and go to state 19
    expr                           shift and go to state 7

state 2

    (1) stmts -> stmt .

    DEFINE          reduce using rule 1 (stmts -> stmt .)
    BREAK           reduce using rule 1 (stmts -> stmt .)
    CASE            reduce using rule 1 (stmts -> stmt .)
    RETURN          reduce using rule 1 (stmts -> stmt .)
    DO              reduce using rule 1 (stmts -> stmt .)
    FOR             reduce using rule 1 (stmts -> stmt .)
    IF              reduce using rule 1 (stmts -> stmt .)
    PSEUDO          reduce using rule 1 (stmts -> stmt .)
    OP              reduce using rule 1 (stmts -> stmt .)
    ID              reduce using rule 1 (stmts -> stmt .)
    NOT             reduce using rule 1 (stmts -> stmt .)
    MINUS           reduce using rule 1 (stmts -> stmt .)
    BITWISE_NOT     reduce using rule 1 (stmts -> stmt .)
    LPAREN          reduce using rule 1 (stmts -> stmt .)
    NUMBER          reduce using rule 1 (stmts -> stmt .)
    $end            reduce using rule 1 (stmts -> stmt .)
    FI              reduce using rule 1 (stmts -> stmt .)
    ELSE            reduce using rule 1 (stmts -> stmt .)
    OD              reduce using rule 1 (stmts -> stmt .)
    ESAC            reduce using rule 1 (stmts -> stmt .)
    CASE_HEADER     reduce using rule 1 (stmts -> stmt .)
    RBRACKET        reduce using rule 1 (stmts -> stmt .)
    ENDFOR          reduce using rule 1 (stmts -> stmt .)


state 3

    (3) stmt -> DEFINE . ID LPAREN args RPAREN LBRACKET stmts RBRACKET

    ID              shift and go to state 20


state 4

    (23) expr -> ID . LPAREN args RPAREN
    (24) expr -> ID . LPAREN RPAREN
    (25) expr -> ID . LBRACKET expr RBRACKET
    (57) expr -> ID .

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 21
    LBRACKET        shift and go to state 22
    UPDATE          reduce using rule 57 (expr -> ID .)
    PLUS_EQUAL      reduce using rule 57 (expr -> ID .)
    OR_EQUAL        reduce using rule 57 (expr -> ID .)
    DOT             reduce using rule 57 (expr -> ID .)
    LBRACE          reduce using rule 57 (expr -> ID .)
    QUEST           reduce using rule 57 (expr -> ID .)
    BITWISE_AND     reduce using rule 57 (expr -> ID .)
    BITWISE_OR      reduce using rule 57 (expr -> ID .)
    OP              reduce using rule 57 (expr -> ID .)
    PLUS            reduce using rule 57 (expr -> ID .)
    MINUS           reduce using rule 57 (expr -> ID .)
    TIMES           reduce using rule 57 (expr -> ID .)
    DIV             reduce using rule 57 (expr -> ID .)
    MOD             reduce using rule 57 (expr -> ID .)
    AND             reduce using rule 57 (expr -> ID .)
    OR              reduce using rule 57 (expr -> ID .)
    LSHIFT          reduce using rule 57 (expr -> ID .)
    RSHIFT          reduce using rule 57 (expr -> ID .)
    LSHIFT_LOGICAL  reduce using rule 57 (expr -> ID .)
    RSHIFT_LOGICAL  reduce using rule 57 (expr -> ID .)
    GREATER         reduce using rule 57 (expr -> ID .)
    LESS            reduce using rule 57 (expr -> ID .)
    LESS_EQUAL      reduce using rule 57 (expr -> ID .)
    GREATER_EQUAL   reduce using rule 57 (expr -> ID .)
    EQUAL           reduce using rule 57 (expr -> ID .)
    NOT_EQUAL       reduce using rule 57 (expr -> ID .)
    XOR             reduce using rule 57 (expr -> ID .)
    DEFINE          reduce using rule 57 (expr -> ID .)
    BREAK           reduce using rule 57 (expr -> ID .)
    CASE            reduce using rule 57 (expr -> ID .)
    RETURN          reduce using rule 57 (expr -> ID .)
    DO              reduce using rule 57 (expr -> ID .)
    FOR             reduce using rule 57 (expr -> ID .)
    IF              reduce using rule 57 (expr -> ID .)
    PSEUDO          reduce using rule 57 (expr -> ID .)
    ID              reduce using rule 57 (expr -> ID .)
    NOT             reduce using rule 57 (expr -> ID .)
    BITWISE_NOT     reduce using rule 57 (expr -> ID .)
    NUMBER          reduce using rule 57 (expr -> ID .)
    $end            reduce using rule 57 (expr -> ID .)
    RPAREN          reduce using rule 57 (expr -> ID .)
    OF              reduce using rule 57 (expr -> ID .)
    FI              reduce using rule 57 (expr -> ID .)
    ELSE            reduce using rule 57 (expr -> ID .)
    OD              reduce using rule 57 (expr -> ID .)
    ESAC            reduce using rule 57 (expr -> ID .)
    CASE_HEADER     reduce using rule 57 (expr -> ID .)
    RBRACKET        reduce using rule 57 (expr -> ID .)
    ENDFOR          reduce using rule 57 (expr -> ID .)
    THEN            reduce using rule 57 (expr -> ID .)
    COMMA           reduce using rule 57 (expr -> ID .)
    RBRACE          reduce using rule 57 (expr -> ID .)
    COLON           reduce using rule 57 (expr -> ID .)
    TO              reduce using rule 57 (expr -> ID .)
    DOWNTO          reduce using rule 57 (expr -> ID .)

  ! LPAREN          [ reduce using rule 57 (expr -> ID .) ]


state 5

    (56) expr -> LPAREN . expr RPAREN
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 23

state 6

    (4) stmt -> BREAK .

    DEFINE          reduce using rule 4 (stmt -> BREAK .)
    BREAK           reduce using rule 4 (stmt -> BREAK .)
    CASE            reduce using rule 4 (stmt -> BREAK .)
    RETURN          reduce using rule 4 (stmt -> BREAK .)
    DO              reduce using rule 4 (stmt -> BREAK .)
    FOR             reduce using rule 4 (stmt -> BREAK .)
    IF              reduce using rule 4 (stmt -> BREAK .)
    PSEUDO          reduce using rule 4 (stmt -> BREAK .)
    OP              reduce using rule 4 (stmt -> BREAK .)
    ID              reduce using rule 4 (stmt -> BREAK .)
    NOT             reduce using rule 4 (stmt -> BREAK .)
    MINUS           reduce using rule 4 (stmt -> BREAK .)
    BITWISE_NOT     reduce using rule 4 (stmt -> BREAK .)
    LPAREN          reduce using rule 4 (stmt -> BREAK .)
    NUMBER          reduce using rule 4 (stmt -> BREAK .)
    $end            reduce using rule 4 (stmt -> BREAK .)
    FI              reduce using rule 4 (stmt -> BREAK .)
    ELSE            reduce using rule 4 (stmt -> BREAK .)
    OD              reduce using rule 4 (stmt -> BREAK .)
    ESAC            reduce using rule 4 (stmt -> BREAK .)
    CASE_HEADER     reduce using rule 4 (stmt -> BREAK .)
    RBRACKET        reduce using rule 4 (stmt -> BREAK .)
    ENDFOR          reduce using rule 4 (stmt -> BREAK .)


state 7

    (5) stmt -> expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

  ! shift/reduce conflict for OP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    DEFINE          reduce using rule 5 (stmt -> expr .)
    BREAK           reduce using rule 5 (stmt -> expr .)
    CASE            reduce using rule 5 (stmt -> expr .)
    RETURN          reduce using rule 5 (stmt -> expr .)
    DO              reduce using rule 5 (stmt -> expr .)
    FOR             reduce using rule 5 (stmt -> expr .)
    IF              reduce using rule 5 (stmt -> expr .)
    PSEUDO          reduce using rule 5 (stmt -> expr .)
    ID              reduce using rule 5 (stmt -> expr .)
    NOT             reduce using rule 5 (stmt -> expr .)
    BITWISE_NOT     reduce using rule 5 (stmt -> expr .)
    LPAREN          reduce using rule 5 (stmt -> expr .)
    NUMBER          reduce using rule 5 (stmt -> expr .)
    $end            reduce using rule 5 (stmt -> expr .)
    FI              reduce using rule 5 (stmt -> expr .)
    ELSE            reduce using rule 5 (stmt -> expr .)
    OD              reduce using rule 5 (stmt -> expr .)
    ESAC            reduce using rule 5 (stmt -> expr .)
    CASE_HEADER     reduce using rule 5 (stmt -> expr .)
    RBRACKET        reduce using rule 5 (stmt -> expr .)
    ENDFOR          reduce using rule 5 (stmt -> expr .)
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51

  ! OP              [ reduce using rule 5 (stmt -> expr .) ]
  ! MINUS           [ reduce using rule 5 (stmt -> expr .) ]


state 8

    (6) stmt -> CASE . expr OF cases ESAC
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 52

state 9

    (9) stmt -> RETURN . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 53

state 10

    (14) stmt -> DO . WHILE expr stmts OD

    WHILE           shift and go to state 54


state 11

    (15) stmt -> FOR . ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> FOR . ID UPDATE expr DOWNTO expr stmts ENDFOR

    ID              shift and go to state 55


state 12

    (17) stmt -> IF . expr THEN stmts FI
    (18) stmt -> IF . expr THEN stmts ELSE stmts FI
    (19) stmt -> IF . expr stmts FI
    (20) stmt -> IF . expr stmts ELSE stmts FI
    (21) stmt -> IF . expr stmts ELSE stmts
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 56

state 13

    (22) stmt -> PSEUDO .
    (59) expr -> PSEUDO .

  ! reduce/reduce conflict for OP resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for MINUS resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for DEFINE resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for BREAK resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for CASE resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for RETURN resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for DO resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for FOR resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for IF resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for PSEUDO resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for ID resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for NOT resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for BITWISE_NOT resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for LPAREN resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for NUMBER resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for $end resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for FI resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for ELSE resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for OD resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for ESAC resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for CASE_HEADER resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 22 (stmt -> PSEUDO .)
  ! reduce/reduce conflict for ENDFOR resolved using rule 22 (stmt -> PSEUDO .)
    DEFINE          reduce using rule 22 (stmt -> PSEUDO .)
    BREAK           reduce using rule 22 (stmt -> PSEUDO .)
    CASE            reduce using rule 22 (stmt -> PSEUDO .)
    RETURN          reduce using rule 22 (stmt -> PSEUDO .)
    DO              reduce using rule 22 (stmt -> PSEUDO .)
    FOR             reduce using rule 22 (stmt -> PSEUDO .)
    IF              reduce using rule 22 (stmt -> PSEUDO .)
    PSEUDO          reduce using rule 22 (stmt -> PSEUDO .)
    OP              reduce using rule 22 (stmt -> PSEUDO .)
    ID              reduce using rule 22 (stmt -> PSEUDO .)
    NOT             reduce using rule 22 (stmt -> PSEUDO .)
    MINUS           reduce using rule 22 (stmt -> PSEUDO .)
    BITWISE_NOT     reduce using rule 22 (stmt -> PSEUDO .)
    LPAREN          reduce using rule 22 (stmt -> PSEUDO .)
    NUMBER          reduce using rule 22 (stmt -> PSEUDO .)
    $end            reduce using rule 22 (stmt -> PSEUDO .)
    FI              reduce using rule 22 (stmt -> PSEUDO .)
    ELSE            reduce using rule 22 (stmt -> PSEUDO .)
    OD              reduce using rule 22 (stmt -> PSEUDO .)
    ESAC            reduce using rule 22 (stmt -> PSEUDO .)
    CASE_HEADER     reduce using rule 22 (stmt -> PSEUDO .)
    RBRACKET        reduce using rule 22 (stmt -> PSEUDO .)
    ENDFOR          reduce using rule 22 (stmt -> PSEUDO .)
    UPDATE          reduce using rule 59 (expr -> PSEUDO .)
    PLUS_EQUAL      reduce using rule 59 (expr -> PSEUDO .)
    OR_EQUAL        reduce using rule 59 (expr -> PSEUDO .)
    DOT             reduce using rule 59 (expr -> PSEUDO .)
    LBRACE          reduce using rule 59 (expr -> PSEUDO .)
    QUEST           reduce using rule 59 (expr -> PSEUDO .)
    BITWISE_AND     reduce using rule 59 (expr -> PSEUDO .)
    BITWISE_OR      reduce using rule 59 (expr -> PSEUDO .)
    PLUS            reduce using rule 59 (expr -> PSEUDO .)
    TIMES           reduce using rule 59 (expr -> PSEUDO .)
    DIV             reduce using rule 59 (expr -> PSEUDO .)
    MOD             reduce using rule 59 (expr -> PSEUDO .)
    AND             reduce using rule 59 (expr -> PSEUDO .)
    OR              reduce using rule 59 (expr -> PSEUDO .)
    LSHIFT          reduce using rule 59 (expr -> PSEUDO .)
    RSHIFT          reduce using rule 59 (expr -> PSEUDO .)
    LSHIFT_LOGICAL  reduce using rule 59 (expr -> PSEUDO .)
    RSHIFT_LOGICAL  reduce using rule 59 (expr -> PSEUDO .)
    GREATER         reduce using rule 59 (expr -> PSEUDO .)
    LESS            reduce using rule 59 (expr -> PSEUDO .)
    LESS_EQUAL      reduce using rule 59 (expr -> PSEUDO .)
    GREATER_EQUAL   reduce using rule 59 (expr -> PSEUDO .)
    EQUAL           reduce using rule 59 (expr -> PSEUDO .)
    NOT_EQUAL       reduce using rule 59 (expr -> PSEUDO .)
    XOR             reduce using rule 59 (expr -> PSEUDO .)

  ! OP              [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! MINUS           [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! DEFINE          [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! BREAK           [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! CASE            [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! RETURN          [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! DO              [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! FOR             [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! IF              [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! PSEUDO          [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! ID              [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! NOT             [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! BITWISE_NOT     [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! LPAREN          [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! NUMBER          [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! $end            [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! FI              [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! ELSE            [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! OD              [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! ESAC            [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! CASE_HEADER     [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! RBRACKET        [ reduce using rule 59 (expr -> PSEUDO .) ]
  ! ENDFOR          [ reduce using rule 59 (expr -> PSEUDO .) ]


state 14

    (11) expr -> OP . UPDATE ID

    UPDATE          shift and go to state 57


state 15

    (32) expr -> NOT . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 58

state 16

    (33) expr -> MINUS . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 59

state 17

    (34) expr -> BITWISE_NOT . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 60

state 18

    (58) expr -> NUMBER .

    UPDATE          reduce using rule 58 (expr -> NUMBER .)
    PLUS_EQUAL      reduce using rule 58 (expr -> NUMBER .)
    OR_EQUAL        reduce using rule 58 (expr -> NUMBER .)
    DOT             reduce using rule 58 (expr -> NUMBER .)
    LBRACE          reduce using rule 58 (expr -> NUMBER .)
    QUEST           reduce using rule 58 (expr -> NUMBER .)
    BITWISE_AND     reduce using rule 58 (expr -> NUMBER .)
    BITWISE_OR      reduce using rule 58 (expr -> NUMBER .)
    OP              reduce using rule 58 (expr -> NUMBER .)
    PLUS            reduce using rule 58 (expr -> NUMBER .)
    MINUS           reduce using rule 58 (expr -> NUMBER .)
    TIMES           reduce using rule 58 (expr -> NUMBER .)
    DIV             reduce using rule 58 (expr -> NUMBER .)
    MOD             reduce using rule 58 (expr -> NUMBER .)
    AND             reduce using rule 58 (expr -> NUMBER .)
    OR              reduce using rule 58 (expr -> NUMBER .)
    LSHIFT          reduce using rule 58 (expr -> NUMBER .)
    RSHIFT          reduce using rule 58 (expr -> NUMBER .)
    LSHIFT_LOGICAL  reduce using rule 58 (expr -> NUMBER .)
    RSHIFT_LOGICAL  reduce using rule 58 (expr -> NUMBER .)
    GREATER         reduce using rule 58 (expr -> NUMBER .)
    LESS            reduce using rule 58 (expr -> NUMBER .)
    LESS_EQUAL      reduce using rule 58 (expr -> NUMBER .)
    GREATER_EQUAL   reduce using rule 58 (expr -> NUMBER .)
    EQUAL           reduce using rule 58 (expr -> NUMBER .)
    NOT_EQUAL       reduce using rule 58 (expr -> NUMBER .)
    XOR             reduce using rule 58 (expr -> NUMBER .)
    DEFINE          reduce using rule 58 (expr -> NUMBER .)
    BREAK           reduce using rule 58 (expr -> NUMBER .)
    CASE            reduce using rule 58 (expr -> NUMBER .)
    RETURN          reduce using rule 58 (expr -> NUMBER .)
    DO              reduce using rule 58 (expr -> NUMBER .)
    FOR             reduce using rule 58 (expr -> NUMBER .)
    IF              reduce using rule 58 (expr -> NUMBER .)
    PSEUDO          reduce using rule 58 (expr -> NUMBER .)
    ID              reduce using rule 58 (expr -> NUMBER .)
    NOT             reduce using rule 58 (expr -> NUMBER .)
    BITWISE_NOT     reduce using rule 58 (expr -> NUMBER .)
    LPAREN          reduce using rule 58 (expr -> NUMBER .)
    NUMBER          reduce using rule 58 (expr -> NUMBER .)
    $end            reduce using rule 58 (expr -> NUMBER .)
    RPAREN          reduce using rule 58 (expr -> NUMBER .)
    OF              reduce using rule 58 (expr -> NUMBER .)
    FI              reduce using rule 58 (expr -> NUMBER .)
    ELSE            reduce using rule 58 (expr -> NUMBER .)
    OD              reduce using rule 58 (expr -> NUMBER .)
    ESAC            reduce using rule 58 (expr -> NUMBER .)
    CASE_HEADER     reduce using rule 58 (expr -> NUMBER .)
    RBRACKET        reduce using rule 58 (expr -> NUMBER .)
    ENDFOR          reduce using rule 58 (expr -> NUMBER .)
    THEN            reduce using rule 58 (expr -> NUMBER .)
    COMMA           reduce using rule 58 (expr -> NUMBER .)
    RBRACE          reduce using rule 58 (expr -> NUMBER .)
    COLON           reduce using rule 58 (expr -> NUMBER .)
    TO              reduce using rule 58 (expr -> NUMBER .)
    DOWNTO          reduce using rule 58 (expr -> NUMBER .)


state 19

    (2) stmts -> stmts stmt .

    DEFINE          reduce using rule 2 (stmts -> stmts stmt .)
    BREAK           reduce using rule 2 (stmts -> stmts stmt .)
    CASE            reduce using rule 2 (stmts -> stmts stmt .)
    RETURN          reduce using rule 2 (stmts -> stmts stmt .)
    DO              reduce using rule 2 (stmts -> stmts stmt .)
    FOR             reduce using rule 2 (stmts -> stmts stmt .)
    IF              reduce using rule 2 (stmts -> stmts stmt .)
    PSEUDO          reduce using rule 2 (stmts -> stmts stmt .)
    OP              reduce using rule 2 (stmts -> stmts stmt .)
    ID              reduce using rule 2 (stmts -> stmts stmt .)
    NOT             reduce using rule 2 (stmts -> stmts stmt .)
    MINUS           reduce using rule 2 (stmts -> stmts stmt .)
    BITWISE_NOT     reduce using rule 2 (stmts -> stmts stmt .)
    LPAREN          reduce using rule 2 (stmts -> stmts stmt .)
    NUMBER          reduce using rule 2 (stmts -> stmts stmt .)
    $end            reduce using rule 2 (stmts -> stmts stmt .)
    FI              reduce using rule 2 (stmts -> stmts stmt .)
    ELSE            reduce using rule 2 (stmts -> stmts stmt .)
    OD              reduce using rule 2 (stmts -> stmts stmt .)
    ESAC            reduce using rule 2 (stmts -> stmts stmt .)
    CASE_HEADER     reduce using rule 2 (stmts -> stmts stmt .)
    RBRACKET        reduce using rule 2 (stmts -> stmts stmt .)
    ENDFOR          reduce using rule 2 (stmts -> stmts stmt .)


state 20

    (3) stmt -> DEFINE ID . LPAREN args RPAREN LBRACKET stmts RBRACKET

    LPAREN          shift and go to state 61


state 21

    (23) expr -> ID LPAREN . args RPAREN
    (24) expr -> ID LPAREN . RPAREN
    (27) args -> . expr
    (28) args -> . args COMMA expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    RPAREN          shift and go to state 63
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    args                           shift and go to state 62
    expr                           shift and go to state 64

state 22

    (25) expr -> ID LBRACKET . expr RBRACKET
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 65

state 23

    (56) expr -> LPAREN expr . RPAREN
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    RPAREN          shift and go to state 66
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51


state 24

    (59) expr -> PSEUDO .

    RPAREN          reduce using rule 59 (expr -> PSEUDO .)
    UPDATE          reduce using rule 59 (expr -> PSEUDO .)
    PLUS_EQUAL      reduce using rule 59 (expr -> PSEUDO .)
    OR_EQUAL        reduce using rule 59 (expr -> PSEUDO .)
    DOT             reduce using rule 59 (expr -> PSEUDO .)
    LBRACE          reduce using rule 59 (expr -> PSEUDO .)
    QUEST           reduce using rule 59 (expr -> PSEUDO .)
    BITWISE_AND     reduce using rule 59 (expr -> PSEUDO .)
    BITWISE_OR      reduce using rule 59 (expr -> PSEUDO .)
    OP              reduce using rule 59 (expr -> PSEUDO .)
    PLUS            reduce using rule 59 (expr -> PSEUDO .)
    MINUS           reduce using rule 59 (expr -> PSEUDO .)
    TIMES           reduce using rule 59 (expr -> PSEUDO .)
    DIV             reduce using rule 59 (expr -> PSEUDO .)
    MOD             reduce using rule 59 (expr -> PSEUDO .)
    AND             reduce using rule 59 (expr -> PSEUDO .)
    OR              reduce using rule 59 (expr -> PSEUDO .)
    LSHIFT          reduce using rule 59 (expr -> PSEUDO .)
    RSHIFT          reduce using rule 59 (expr -> PSEUDO .)
    LSHIFT_LOGICAL  reduce using rule 59 (expr -> PSEUDO .)
    RSHIFT_LOGICAL  reduce using rule 59 (expr -> PSEUDO .)
    GREATER         reduce using rule 59 (expr -> PSEUDO .)
    LESS            reduce using rule 59 (expr -> PSEUDO .)
    LESS_EQUAL      reduce using rule 59 (expr -> PSEUDO .)
    GREATER_EQUAL   reduce using rule 59 (expr -> PSEUDO .)
    EQUAL           reduce using rule 59 (expr -> PSEUDO .)
    NOT_EQUAL       reduce using rule 59 (expr -> PSEUDO .)
    XOR             reduce using rule 59 (expr -> PSEUDO .)
    OF              reduce using rule 59 (expr -> PSEUDO .)
    DEFINE          reduce using rule 59 (expr -> PSEUDO .)
    BREAK           reduce using rule 59 (expr -> PSEUDO .)
    CASE            reduce using rule 59 (expr -> PSEUDO .)
    RETURN          reduce using rule 59 (expr -> PSEUDO .)
    DO              reduce using rule 59 (expr -> PSEUDO .)
    FOR             reduce using rule 59 (expr -> PSEUDO .)
    IF              reduce using rule 59 (expr -> PSEUDO .)
    PSEUDO          reduce using rule 59 (expr -> PSEUDO .)
    ID              reduce using rule 59 (expr -> PSEUDO .)
    NOT             reduce using rule 59 (expr -> PSEUDO .)
    BITWISE_NOT     reduce using rule 59 (expr -> PSEUDO .)
    LPAREN          reduce using rule 59 (expr -> PSEUDO .)
    NUMBER          reduce using rule 59 (expr -> PSEUDO .)
    $end            reduce using rule 59 (expr -> PSEUDO .)
    FI              reduce using rule 59 (expr -> PSEUDO .)
    ELSE            reduce using rule 59 (expr -> PSEUDO .)
    OD              reduce using rule 59 (expr -> PSEUDO .)
    ESAC            reduce using rule 59 (expr -> PSEUDO .)
    CASE_HEADER     reduce using rule 59 (expr -> PSEUDO .)
    RBRACKET        reduce using rule 59 (expr -> PSEUDO .)
    ENDFOR          reduce using rule 59 (expr -> PSEUDO .)
    THEN            reduce using rule 59 (expr -> PSEUDO .)
    COMMA           reduce using rule 59 (expr -> PSEUDO .)
    RBRACE          reduce using rule 59 (expr -> PSEUDO .)
    COLON           reduce using rule 59 (expr -> PSEUDO .)
    TO              reduce using rule 59 (expr -> PSEUDO .)
    DOWNTO          reduce using rule 59 (expr -> PSEUDO .)


state 25

    (10) expr -> expr UPDATE . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 67

state 26

    (12) expr -> expr PLUS_EQUAL . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 68

state 27

    (13) expr -> expr OR_EQUAL . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 69

state 28

    (26) expr -> expr DOT . ID

    ID              shift and go to state 70


state 29

    (29) expr -> expr LBRACE . expr RBRACE
    (30) expr -> expr LBRACE . expr COLON expr RBRACE
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 71

state 30

    (31) expr -> expr QUEST . expr COLON expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 72

state 31

    (35) expr -> expr BITWISE_AND . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 73

state 32

    (36) expr -> expr BITWISE_OR . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 74

state 33

    (37) expr -> expr OP . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 75

state 34

    (38) expr -> expr PLUS . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 76

state 35

    (39) expr -> expr MINUS . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 77

state 36

    (40) expr -> expr TIMES . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 78

state 37

    (41) expr -> expr DIV . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 79

state 38

    (42) expr -> expr MOD . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 80

state 39

    (43) expr -> expr AND . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 81

state 40

    (44) expr -> expr OR . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 82

state 41

    (45) expr -> expr LSHIFT . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 83

state 42

    (46) expr -> expr RSHIFT . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 84

state 43

    (47) expr -> expr LSHIFT_LOGICAL . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 85

state 44

    (48) expr -> expr RSHIFT_LOGICAL . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 86

state 45

    (49) expr -> expr GREATER . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 87

state 46

    (50) expr -> expr LESS . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 88

state 47

    (51) expr -> expr LESS_EQUAL . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 89

state 48

    (52) expr -> expr GREATER_EQUAL . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 90

state 49

    (53) expr -> expr EQUAL . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 91

state 50

    (54) expr -> expr NOT_EQUAL . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 92

state 51

    (55) expr -> expr XOR . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 93

state 52

    (6) stmt -> CASE expr . OF cases ESAC
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    OF              shift and go to state 94
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51


state 53

    (9) stmt -> RETURN expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

  ! shift/reduce conflict for OP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    DEFINE          reduce using rule 9 (stmt -> RETURN expr .)
    BREAK           reduce using rule 9 (stmt -> RETURN expr .)
    CASE            reduce using rule 9 (stmt -> RETURN expr .)
    RETURN          reduce using rule 9 (stmt -> RETURN expr .)
    DO              reduce using rule 9 (stmt -> RETURN expr .)
    FOR             reduce using rule 9 (stmt -> RETURN expr .)
    IF              reduce using rule 9 (stmt -> RETURN expr .)
    PSEUDO          reduce using rule 9 (stmt -> RETURN expr .)
    ID              reduce using rule 9 (stmt -> RETURN expr .)
    NOT             reduce using rule 9 (stmt -> RETURN expr .)
    BITWISE_NOT     reduce using rule 9 (stmt -> RETURN expr .)
    LPAREN          reduce using rule 9 (stmt -> RETURN expr .)
    NUMBER          reduce using rule 9 (stmt -> RETURN expr .)
    $end            reduce using rule 9 (stmt -> RETURN expr .)
    FI              reduce using rule 9 (stmt -> RETURN expr .)
    ELSE            reduce using rule 9 (stmt -> RETURN expr .)
    OD              reduce using rule 9 (stmt -> RETURN expr .)
    ESAC            reduce using rule 9 (stmt -> RETURN expr .)
    CASE_HEADER     reduce using rule 9 (stmt -> RETURN expr .)
    RBRACKET        reduce using rule 9 (stmt -> RETURN expr .)
    ENDFOR          reduce using rule 9 (stmt -> RETURN expr .)
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51

  ! OP              [ reduce using rule 9 (stmt -> RETURN expr .) ]
  ! MINUS           [ reduce using rule 9 (stmt -> RETURN expr .) ]


state 54

    (14) stmt -> DO WHILE . expr stmts OD
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 95

state 55

    (15) stmt -> FOR ID . UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> FOR ID . UPDATE expr DOWNTO expr stmts ENDFOR

    UPDATE          shift and go to state 96


state 56

    (17) stmt -> IF expr . THEN stmts FI
    (18) stmt -> IF expr . THEN stmts ELSE stmts FI
    (19) stmt -> IF expr . stmts FI
    (20) stmt -> IF expr . stmts ELSE stmts FI
    (21) stmt -> IF expr . stmts ELSE stmts
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr
    (1) stmts -> . stmt
    (2) stmts -> . stmts stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    THEN            shift and go to state 97
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 99
    PLUS            shift and go to state 34
    MINUS           shift and go to state 100
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    ID              shift and go to state 4
    NOT             shift and go to state 15
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    expr                           shift and go to state 7
    stmts                          shift and go to state 98
    stmt                           shift and go to state 2

state 57

    (11) expr -> OP UPDATE . ID

    ID              shift and go to state 101


state 58

    (32) expr -> NOT expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 32 (expr -> NOT expr .)
    PLUS_EQUAL      reduce using rule 32 (expr -> NOT expr .)
    OR_EQUAL        reduce using rule 32 (expr -> NOT expr .)
    QUEST           reduce using rule 32 (expr -> NOT expr .)
    BITWISE_AND     reduce using rule 32 (expr -> NOT expr .)
    BITWISE_OR      reduce using rule 32 (expr -> NOT expr .)
    OP              reduce using rule 32 (expr -> NOT expr .)
    PLUS            reduce using rule 32 (expr -> NOT expr .)
    MINUS           reduce using rule 32 (expr -> NOT expr .)
    TIMES           reduce using rule 32 (expr -> NOT expr .)
    DIV             reduce using rule 32 (expr -> NOT expr .)
    MOD             reduce using rule 32 (expr -> NOT expr .)
    AND             reduce using rule 32 (expr -> NOT expr .)
    OR              reduce using rule 32 (expr -> NOT expr .)
    LSHIFT          reduce using rule 32 (expr -> NOT expr .)
    RSHIFT          reduce using rule 32 (expr -> NOT expr .)
    LSHIFT_LOGICAL  reduce using rule 32 (expr -> NOT expr .)
    RSHIFT_LOGICAL  reduce using rule 32 (expr -> NOT expr .)
    GREATER         reduce using rule 32 (expr -> NOT expr .)
    LESS            reduce using rule 32 (expr -> NOT expr .)
    LESS_EQUAL      reduce using rule 32 (expr -> NOT expr .)
    GREATER_EQUAL   reduce using rule 32 (expr -> NOT expr .)
    EQUAL           reduce using rule 32 (expr -> NOT expr .)
    NOT_EQUAL       reduce using rule 32 (expr -> NOT expr .)
    XOR             reduce using rule 32 (expr -> NOT expr .)
    DEFINE          reduce using rule 32 (expr -> NOT expr .)
    BREAK           reduce using rule 32 (expr -> NOT expr .)
    CASE            reduce using rule 32 (expr -> NOT expr .)
    RETURN          reduce using rule 32 (expr -> NOT expr .)
    DO              reduce using rule 32 (expr -> NOT expr .)
    FOR             reduce using rule 32 (expr -> NOT expr .)
    IF              reduce using rule 32 (expr -> NOT expr .)
    PSEUDO          reduce using rule 32 (expr -> NOT expr .)
    ID              reduce using rule 32 (expr -> NOT expr .)
    NOT             reduce using rule 32 (expr -> NOT expr .)
    BITWISE_NOT     reduce using rule 32 (expr -> NOT expr .)
    LPAREN          reduce using rule 32 (expr -> NOT expr .)
    NUMBER          reduce using rule 32 (expr -> NOT expr .)
    $end            reduce using rule 32 (expr -> NOT expr .)
    RPAREN          reduce using rule 32 (expr -> NOT expr .)
    OF              reduce using rule 32 (expr -> NOT expr .)
    FI              reduce using rule 32 (expr -> NOT expr .)
    ELSE            reduce using rule 32 (expr -> NOT expr .)
    OD              reduce using rule 32 (expr -> NOT expr .)
    ESAC            reduce using rule 32 (expr -> NOT expr .)
    CASE_HEADER     reduce using rule 32 (expr -> NOT expr .)
    RBRACKET        reduce using rule 32 (expr -> NOT expr .)
    ENDFOR          reduce using rule 32 (expr -> NOT expr .)
    THEN            reduce using rule 32 (expr -> NOT expr .)
    COMMA           reduce using rule 32 (expr -> NOT expr .)
    RBRACE          reduce using rule 32 (expr -> NOT expr .)
    COLON           reduce using rule 32 (expr -> NOT expr .)
    TO              reduce using rule 32 (expr -> NOT expr .)
    DOWNTO          reduce using rule 32 (expr -> NOT expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29

  ! DOT             [ reduce using rule 32 (expr -> NOT expr .) ]
  ! LBRACE          [ reduce using rule 32 (expr -> NOT expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! TIMES           [ shift and go to state 36 ]
  ! DIV             [ shift and go to state 37 ]
  ! MOD             [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! LSHIFT          [ shift and go to state 41 ]
  ! RSHIFT          [ shift and go to state 42 ]
  ! LSHIFT_LOGICAL  [ shift and go to state 43 ]
  ! RSHIFT_LOGICAL  [ shift and go to state 44 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 59

    (33) expr -> MINUS expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 33 (expr -> MINUS expr .)
    PLUS_EQUAL      reduce using rule 33 (expr -> MINUS expr .)
    OR_EQUAL        reduce using rule 33 (expr -> MINUS expr .)
    QUEST           reduce using rule 33 (expr -> MINUS expr .)
    BITWISE_AND     reduce using rule 33 (expr -> MINUS expr .)
    BITWISE_OR      reduce using rule 33 (expr -> MINUS expr .)
    OP              reduce using rule 33 (expr -> MINUS expr .)
    PLUS            reduce using rule 33 (expr -> MINUS expr .)
    MINUS           reduce using rule 33 (expr -> MINUS expr .)
    TIMES           reduce using rule 33 (expr -> MINUS expr .)
    DIV             reduce using rule 33 (expr -> MINUS expr .)
    MOD             reduce using rule 33 (expr -> MINUS expr .)
    AND             reduce using rule 33 (expr -> MINUS expr .)
    OR              reduce using rule 33 (expr -> MINUS expr .)
    LSHIFT          reduce using rule 33 (expr -> MINUS expr .)
    RSHIFT          reduce using rule 33 (expr -> MINUS expr .)
    LSHIFT_LOGICAL  reduce using rule 33 (expr -> MINUS expr .)
    RSHIFT_LOGICAL  reduce using rule 33 (expr -> MINUS expr .)
    GREATER         reduce using rule 33 (expr -> MINUS expr .)
    LESS            reduce using rule 33 (expr -> MINUS expr .)
    LESS_EQUAL      reduce using rule 33 (expr -> MINUS expr .)
    GREATER_EQUAL   reduce using rule 33 (expr -> MINUS expr .)
    EQUAL           reduce using rule 33 (expr -> MINUS expr .)
    NOT_EQUAL       reduce using rule 33 (expr -> MINUS expr .)
    XOR             reduce using rule 33 (expr -> MINUS expr .)
    DEFINE          reduce using rule 33 (expr -> MINUS expr .)
    BREAK           reduce using rule 33 (expr -> MINUS expr .)
    CASE            reduce using rule 33 (expr -> MINUS expr .)
    RETURN          reduce using rule 33 (expr -> MINUS expr .)
    DO              reduce using rule 33 (expr -> MINUS expr .)
    FOR             reduce using rule 33 (expr -> MINUS expr .)
    IF              reduce using rule 33 (expr -> MINUS expr .)
    PSEUDO          reduce using rule 33 (expr -> MINUS expr .)
    ID              reduce using rule 33 (expr -> MINUS expr .)
    NOT             reduce using rule 33 (expr -> MINUS expr .)
    BITWISE_NOT     reduce using rule 33 (expr -> MINUS expr .)
    LPAREN          reduce using rule 33 (expr -> MINUS expr .)
    NUMBER          reduce using rule 33 (expr -> MINUS expr .)
    $end            reduce using rule 33 (expr -> MINUS expr .)
    RPAREN          reduce using rule 33 (expr -> MINUS expr .)
    OF              reduce using rule 33 (expr -> MINUS expr .)
    FI              reduce using rule 33 (expr -> MINUS expr .)
    ELSE            reduce using rule 33 (expr -> MINUS expr .)
    OD              reduce using rule 33 (expr -> MINUS expr .)
    ESAC            reduce using rule 33 (expr -> MINUS expr .)
    CASE_HEADER     reduce using rule 33 (expr -> MINUS expr .)
    RBRACKET        reduce using rule 33 (expr -> MINUS expr .)
    ENDFOR          reduce using rule 33 (expr -> MINUS expr .)
    THEN            reduce using rule 33 (expr -> MINUS expr .)
    COMMA           reduce using rule 33 (expr -> MINUS expr .)
    RBRACE          reduce using rule 33 (expr -> MINUS expr .)
    COLON           reduce using rule 33 (expr -> MINUS expr .)
    TO              reduce using rule 33 (expr -> MINUS expr .)
    DOWNTO          reduce using rule 33 (expr -> MINUS expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29

  ! DOT             [ reduce using rule 33 (expr -> MINUS expr .) ]
  ! LBRACE          [ reduce using rule 33 (expr -> MINUS expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! TIMES           [ shift and go to state 36 ]
  ! DIV             [ shift and go to state 37 ]
  ! MOD             [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! LSHIFT          [ shift and go to state 41 ]
  ! RSHIFT          [ shift and go to state 42 ]
  ! LSHIFT_LOGICAL  [ shift and go to state 43 ]
  ! RSHIFT_LOGICAL  [ shift and go to state 44 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 60

    (34) expr -> BITWISE_NOT expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 34 (expr -> BITWISE_NOT expr .)
    PLUS_EQUAL      reduce using rule 34 (expr -> BITWISE_NOT expr .)
    OR_EQUAL        reduce using rule 34 (expr -> BITWISE_NOT expr .)
    QUEST           reduce using rule 34 (expr -> BITWISE_NOT expr .)
    BITWISE_AND     reduce using rule 34 (expr -> BITWISE_NOT expr .)
    BITWISE_OR      reduce using rule 34 (expr -> BITWISE_NOT expr .)
    OP              reduce using rule 34 (expr -> BITWISE_NOT expr .)
    PLUS            reduce using rule 34 (expr -> BITWISE_NOT expr .)
    MINUS           reduce using rule 34 (expr -> BITWISE_NOT expr .)
    TIMES           reduce using rule 34 (expr -> BITWISE_NOT expr .)
    DIV             reduce using rule 34 (expr -> BITWISE_NOT expr .)
    MOD             reduce using rule 34 (expr -> BITWISE_NOT expr .)
    AND             reduce using rule 34 (expr -> BITWISE_NOT expr .)
    OR              reduce using rule 34 (expr -> BITWISE_NOT expr .)
    LSHIFT          reduce using rule 34 (expr -> BITWISE_NOT expr .)
    RSHIFT          reduce using rule 34 (expr -> BITWISE_NOT expr .)
    LSHIFT_LOGICAL  reduce using rule 34 (expr -> BITWISE_NOT expr .)
    RSHIFT_LOGICAL  reduce using rule 34 (expr -> BITWISE_NOT expr .)
    GREATER         reduce using rule 34 (expr -> BITWISE_NOT expr .)
    LESS            reduce using rule 34 (expr -> BITWISE_NOT expr .)
    LESS_EQUAL      reduce using rule 34 (expr -> BITWISE_NOT expr .)
    GREATER_EQUAL   reduce using rule 34 (expr -> BITWISE_NOT expr .)
    EQUAL           reduce using rule 34 (expr -> BITWISE_NOT expr .)
    NOT_EQUAL       reduce using rule 34 (expr -> BITWISE_NOT expr .)
    XOR             reduce using rule 34 (expr -> BITWISE_NOT expr .)
    DEFINE          reduce using rule 34 (expr -> BITWISE_NOT expr .)
    BREAK           reduce using rule 34 (expr -> BITWISE_NOT expr .)
    CASE            reduce using rule 34 (expr -> BITWISE_NOT expr .)
    RETURN          reduce using rule 34 (expr -> BITWISE_NOT expr .)
    DO              reduce using rule 34 (expr -> BITWISE_NOT expr .)
    FOR             reduce using rule 34 (expr -> BITWISE_NOT expr .)
    IF              reduce using rule 34 (expr -> BITWISE_NOT expr .)
    PSEUDO          reduce using rule 34 (expr -> BITWISE_NOT expr .)
    ID              reduce using rule 34 (expr -> BITWISE_NOT expr .)
    NOT             reduce using rule 34 (expr -> BITWISE_NOT expr .)
    BITWISE_NOT     reduce using rule 34 (expr -> BITWISE_NOT expr .)
    LPAREN          reduce using rule 34 (expr -> BITWISE_NOT expr .)
    NUMBER          reduce using rule 34 (expr -> BITWISE_NOT expr .)
    $end            reduce using rule 34 (expr -> BITWISE_NOT expr .)
    RPAREN          reduce using rule 34 (expr -> BITWISE_NOT expr .)
    OF              reduce using rule 34 (expr -> BITWISE_NOT expr .)
    FI              reduce using rule 34 (expr -> BITWISE_NOT expr .)
    ELSE            reduce using rule 34 (expr -> BITWISE_NOT expr .)
    OD              reduce using rule 34 (expr -> BITWISE_NOT expr .)
    ESAC            reduce using rule 34 (expr -> BITWISE_NOT expr .)
    CASE_HEADER     reduce using rule 34 (expr -> BITWISE_NOT expr .)
    RBRACKET        reduce using rule 34 (expr -> BITWISE_NOT expr .)
    ENDFOR          reduce using rule 34 (expr -> BITWISE_NOT expr .)
    THEN            reduce using rule 34 (expr -> BITWISE_NOT expr .)
    COMMA           reduce using rule 34 (expr -> BITWISE_NOT expr .)
    RBRACE          reduce using rule 34 (expr -> BITWISE_NOT expr .)
    COLON           reduce using rule 34 (expr -> BITWISE_NOT expr .)
    TO              reduce using rule 34 (expr -> BITWISE_NOT expr .)
    DOWNTO          reduce using rule 34 (expr -> BITWISE_NOT expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29

  ! DOT             [ reduce using rule 34 (expr -> BITWISE_NOT expr .) ]
  ! LBRACE          [ reduce using rule 34 (expr -> BITWISE_NOT expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! TIMES           [ shift and go to state 36 ]
  ! DIV             [ shift and go to state 37 ]
  ! MOD             [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! LSHIFT          [ shift and go to state 41 ]
  ! RSHIFT          [ shift and go to state 42 ]
  ! LSHIFT_LOGICAL  [ shift and go to state 43 ]
  ! RSHIFT_LOGICAL  [ shift and go to state 44 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 61

    (3) stmt -> DEFINE ID LPAREN . args RPAREN LBRACKET stmts RBRACKET
    (27) args -> . expr
    (28) args -> . args COMMA expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    args                           shift and go to state 102
    expr                           shift and go to state 64

state 62

    (23) expr -> ID LPAREN args . RPAREN
    (28) args -> args . COMMA expr

    RPAREN          shift and go to state 103
    COMMA           shift and go to state 104


state 63

    (24) expr -> ID LPAREN RPAREN .

    UPDATE          reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    PLUS_EQUAL      reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    OR_EQUAL        reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    DOT             reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    LBRACE          reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    QUEST           reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    BITWISE_AND     reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    BITWISE_OR      reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    OP              reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    DIV             reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    MOD             reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    AND             reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    OR              reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    LSHIFT          reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    RSHIFT          reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    LSHIFT_LOGICAL  reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    RSHIFT_LOGICAL  reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    GREATER         reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    LESS            reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    LESS_EQUAL      reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    GREATER_EQUAL   reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    EQUAL           reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    NOT_EQUAL       reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    XOR             reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    DEFINE          reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    BREAK           reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    CASE            reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    DO              reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    FOR             reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    IF              reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    PSEUDO          reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    ID              reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    NOT             reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    BITWISE_NOT     reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    LPAREN          reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    NUMBER          reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    $end            reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    OF              reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    FI              reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    ELSE            reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    OD              reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    ESAC            reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    CASE_HEADER     reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    ENDFOR          reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    THEN            reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    RBRACE          reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    COLON           reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    TO              reduce using rule 24 (expr -> ID LPAREN RPAREN .)
    DOWNTO          reduce using rule 24 (expr -> ID LPAREN RPAREN .)


state 64

    (27) args -> expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    RPAREN          reduce using rule 27 (args -> expr .)
    COMMA           reduce using rule 27 (args -> expr .)
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51


state 65

    (25) expr -> ID LBRACKET expr . RBRACKET
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    RBRACKET        shift and go to state 105
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51


state 66

    (56) expr -> LPAREN expr RPAREN .

    UPDATE          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    PLUS_EQUAL      reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    OR_EQUAL        reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    DOT             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    LBRACE          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    QUEST           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    BITWISE_AND     reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    BITWISE_OR      reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    OP              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    DIV             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    MOD             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    LSHIFT          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    RSHIFT          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    LSHIFT_LOGICAL  reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    RSHIFT_LOGICAL  reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    GREATER         reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    LESS            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    LESS_EQUAL      reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    GREATER_EQUAL   reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    EQUAL           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    NOT_EQUAL       reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    XOR             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    DEFINE          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    BREAK           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    CASE            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    RETURN          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    DO              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    FOR             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    IF              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    PSEUDO          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    ID              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    NOT             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    BITWISE_NOT     reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    LPAREN          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    NUMBER          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    OF              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    FI              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    ELSE            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    OD              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    ESAC            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    CASE_HEADER     reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    ENDFOR          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    THEN            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    RBRACE          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    COLON           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    TO              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    DOWNTO          reduce using rule 56 (expr -> LPAREN expr RPAREN .)


state 67

    (10) expr -> expr UPDATE expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

  ! shift/reduce conflict for UPDATE resolved as shift
  ! shift/reduce conflict for PLUS_EQUAL resolved as shift
  ! shift/reduce conflict for OR_EQUAL resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for QUEST resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT_LOGICAL resolved as shift
  ! shift/reduce conflict for RSHIFT_LOGICAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
    DEFINE          reduce using rule 10 (expr -> expr UPDATE expr .)
    BREAK           reduce using rule 10 (expr -> expr UPDATE expr .)
    CASE            reduce using rule 10 (expr -> expr UPDATE expr .)
    RETURN          reduce using rule 10 (expr -> expr UPDATE expr .)
    DO              reduce using rule 10 (expr -> expr UPDATE expr .)
    FOR             reduce using rule 10 (expr -> expr UPDATE expr .)
    IF              reduce using rule 10 (expr -> expr UPDATE expr .)
    PSEUDO          reduce using rule 10 (expr -> expr UPDATE expr .)
    ID              reduce using rule 10 (expr -> expr UPDATE expr .)
    NOT             reduce using rule 10 (expr -> expr UPDATE expr .)
    BITWISE_NOT     reduce using rule 10 (expr -> expr UPDATE expr .)
    LPAREN          reduce using rule 10 (expr -> expr UPDATE expr .)
    NUMBER          reduce using rule 10 (expr -> expr UPDATE expr .)
    $end            reduce using rule 10 (expr -> expr UPDATE expr .)
    RPAREN          reduce using rule 10 (expr -> expr UPDATE expr .)
    OF              reduce using rule 10 (expr -> expr UPDATE expr .)
    FI              reduce using rule 10 (expr -> expr UPDATE expr .)
    ELSE            reduce using rule 10 (expr -> expr UPDATE expr .)
    OD              reduce using rule 10 (expr -> expr UPDATE expr .)
    ESAC            reduce using rule 10 (expr -> expr UPDATE expr .)
    CASE_HEADER     reduce using rule 10 (expr -> expr UPDATE expr .)
    RBRACKET        reduce using rule 10 (expr -> expr UPDATE expr .)
    ENDFOR          reduce using rule 10 (expr -> expr UPDATE expr .)
    THEN            reduce using rule 10 (expr -> expr UPDATE expr .)
    COMMA           reduce using rule 10 (expr -> expr UPDATE expr .)
    RBRACE          reduce using rule 10 (expr -> expr UPDATE expr .)
    COLON           reduce using rule 10 (expr -> expr UPDATE expr .)
    TO              reduce using rule 10 (expr -> expr UPDATE expr .)
    DOWNTO          reduce using rule 10 (expr -> expr UPDATE expr .)
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51

  ! UPDATE          [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! PLUS_EQUAL      [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! OR_EQUAL        [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! DOT             [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! LBRACE          [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! QUEST           [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! BITWISE_AND     [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! BITWISE_OR      [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! OP              [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! PLUS            [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! MINUS           [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! TIMES           [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! DIV             [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! MOD             [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! AND             [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! OR              [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! LSHIFT          [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! RSHIFT          [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! GREATER         [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! LESS            [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! LESS_EQUAL      [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! EQUAL           [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! NOT_EQUAL       [ reduce using rule 10 (expr -> expr UPDATE expr .) ]
  ! XOR             [ reduce using rule 10 (expr -> expr UPDATE expr .) ]


state 68

    (12) expr -> expr PLUS_EQUAL expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

  ! shift/reduce conflict for UPDATE resolved as shift
  ! shift/reduce conflict for PLUS_EQUAL resolved as shift
  ! shift/reduce conflict for OR_EQUAL resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for QUEST resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT_LOGICAL resolved as shift
  ! shift/reduce conflict for RSHIFT_LOGICAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
    DEFINE          reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    BREAK           reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    CASE            reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    RETURN          reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    DO              reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    FOR             reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    IF              reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    PSEUDO          reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    ID              reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    NOT             reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    BITWISE_NOT     reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    LPAREN          reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    NUMBER          reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    $end            reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    RPAREN          reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    OF              reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    FI              reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    ELSE            reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    OD              reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    ESAC            reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    CASE_HEADER     reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    RBRACKET        reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    ENDFOR          reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    THEN            reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    COMMA           reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    RBRACE          reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    COLON           reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    TO              reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    DOWNTO          reduce using rule 12 (expr -> expr PLUS_EQUAL expr .)
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51

  ! UPDATE          [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! PLUS_EQUAL      [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! OR_EQUAL        [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! DOT             [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! LBRACE          [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! QUEST           [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! BITWISE_AND     [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! BITWISE_OR      [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! OP              [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! PLUS            [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! MINUS           [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! TIMES           [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! DIV             [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! MOD             [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! AND             [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! OR              [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! LSHIFT          [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! RSHIFT          [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! GREATER         [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! LESS            [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! LESS_EQUAL      [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! EQUAL           [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! NOT_EQUAL       [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]
  ! XOR             [ reduce using rule 12 (expr -> expr PLUS_EQUAL expr .) ]


state 69

    (13) expr -> expr OR_EQUAL expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

  ! shift/reduce conflict for UPDATE resolved as shift
  ! shift/reduce conflict for PLUS_EQUAL resolved as shift
  ! shift/reduce conflict for OR_EQUAL resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for QUEST resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT_LOGICAL resolved as shift
  ! shift/reduce conflict for RSHIFT_LOGICAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
    DEFINE          reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    BREAK           reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    CASE            reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    RETURN          reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    DO              reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    FOR             reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    IF              reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    PSEUDO          reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    ID              reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    NOT             reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    BITWISE_NOT     reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    LPAREN          reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    NUMBER          reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    $end            reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    RPAREN          reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    OF              reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    FI              reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    ELSE            reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    OD              reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    ESAC            reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    CASE_HEADER     reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    RBRACKET        reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    ENDFOR          reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    THEN            reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    COMMA           reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    RBRACE          reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    COLON           reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    TO              reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    DOWNTO          reduce using rule 13 (expr -> expr OR_EQUAL expr .)
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51

  ! UPDATE          [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! PLUS_EQUAL      [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! OR_EQUAL        [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! DOT             [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! LBRACE          [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! QUEST           [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! BITWISE_AND     [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! BITWISE_OR      [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! OP              [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! PLUS            [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! MINUS           [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! TIMES           [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! DIV             [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! MOD             [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! AND             [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! OR              [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! LSHIFT          [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! RSHIFT          [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! GREATER         [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! LESS            [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! LESS_EQUAL      [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! EQUAL           [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! NOT_EQUAL       [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]
  ! XOR             [ reduce using rule 13 (expr -> expr OR_EQUAL expr .) ]


state 70

    (26) expr -> expr DOT ID .

    UPDATE          reduce using rule 26 (expr -> expr DOT ID .)
    PLUS_EQUAL      reduce using rule 26 (expr -> expr DOT ID .)
    OR_EQUAL        reduce using rule 26 (expr -> expr DOT ID .)
    DOT             reduce using rule 26 (expr -> expr DOT ID .)
    LBRACE          reduce using rule 26 (expr -> expr DOT ID .)
    QUEST           reduce using rule 26 (expr -> expr DOT ID .)
    BITWISE_AND     reduce using rule 26 (expr -> expr DOT ID .)
    BITWISE_OR      reduce using rule 26 (expr -> expr DOT ID .)
    OP              reduce using rule 26 (expr -> expr DOT ID .)
    PLUS            reduce using rule 26 (expr -> expr DOT ID .)
    MINUS           reduce using rule 26 (expr -> expr DOT ID .)
    TIMES           reduce using rule 26 (expr -> expr DOT ID .)
    DIV             reduce using rule 26 (expr -> expr DOT ID .)
    MOD             reduce using rule 26 (expr -> expr DOT ID .)
    AND             reduce using rule 26 (expr -> expr DOT ID .)
    OR              reduce using rule 26 (expr -> expr DOT ID .)
    LSHIFT          reduce using rule 26 (expr -> expr DOT ID .)
    RSHIFT          reduce using rule 26 (expr -> expr DOT ID .)
    LSHIFT_LOGICAL  reduce using rule 26 (expr -> expr DOT ID .)
    RSHIFT_LOGICAL  reduce using rule 26 (expr -> expr DOT ID .)
    GREATER         reduce using rule 26 (expr -> expr DOT ID .)
    LESS            reduce using rule 26 (expr -> expr DOT ID .)
    LESS_EQUAL      reduce using rule 26 (expr -> expr DOT ID .)
    GREATER_EQUAL   reduce using rule 26 (expr -> expr DOT ID .)
    EQUAL           reduce using rule 26 (expr -> expr DOT ID .)
    NOT_EQUAL       reduce using rule 26 (expr -> expr DOT ID .)
    XOR             reduce using rule 26 (expr -> expr DOT ID .)
    DEFINE          reduce using rule 26 (expr -> expr DOT ID .)
    BREAK           reduce using rule 26 (expr -> expr DOT ID .)
    CASE            reduce using rule 26 (expr -> expr DOT ID .)
    RETURN          reduce using rule 26 (expr -> expr DOT ID .)
    DO              reduce using rule 26 (expr -> expr DOT ID .)
    FOR             reduce using rule 26 (expr -> expr DOT ID .)
    IF              reduce using rule 26 (expr -> expr DOT ID .)
    PSEUDO          reduce using rule 26 (expr -> expr DOT ID .)
    ID              reduce using rule 26 (expr -> expr DOT ID .)
    NOT             reduce using rule 26 (expr -> expr DOT ID .)
    BITWISE_NOT     reduce using rule 26 (expr -> expr DOT ID .)
    LPAREN          reduce using rule 26 (expr -> expr DOT ID .)
    NUMBER          reduce using rule 26 (expr -> expr DOT ID .)
    $end            reduce using rule 26 (expr -> expr DOT ID .)
    RPAREN          reduce using rule 26 (expr -> expr DOT ID .)
    OF              reduce using rule 26 (expr -> expr DOT ID .)
    FI              reduce using rule 26 (expr -> expr DOT ID .)
    ELSE            reduce using rule 26 (expr -> expr DOT ID .)
    OD              reduce using rule 26 (expr -> expr DOT ID .)
    ESAC            reduce using rule 26 (expr -> expr DOT ID .)
    CASE_HEADER     reduce using rule 26 (expr -> expr DOT ID .)
    RBRACKET        reduce using rule 26 (expr -> expr DOT ID .)
    ENDFOR          reduce using rule 26 (expr -> expr DOT ID .)
    THEN            reduce using rule 26 (expr -> expr DOT ID .)
    COMMA           reduce using rule 26 (expr -> expr DOT ID .)
    RBRACE          reduce using rule 26 (expr -> expr DOT ID .)
    COLON           reduce using rule 26 (expr -> expr DOT ID .)
    TO              reduce using rule 26 (expr -> expr DOT ID .)
    DOWNTO          reduce using rule 26 (expr -> expr DOT ID .)


state 71

    (29) expr -> expr LBRACE expr . RBRACE
    (30) expr -> expr LBRACE expr . COLON expr RBRACE
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    RBRACE          shift and go to state 106
    COLON           shift and go to state 107
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51


state 72

    (31) expr -> expr QUEST expr . COLON expr
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    COLON           shift and go to state 108
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51


state 73

    (35) expr -> expr BITWISE_AND expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    PLUS_EQUAL      reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    OR_EQUAL        reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    QUEST           reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    BITWISE_AND     reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    BITWISE_OR      reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    OP              reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    DEFINE          reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    BREAK           reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    CASE            reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    RETURN          reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    DO              reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    FOR             reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    IF              reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    PSEUDO          reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    ID              reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    NOT             reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    BITWISE_NOT     reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    LPAREN          reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    NUMBER          reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    $end            reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    RPAREN          reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    OF              reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    FI              reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    ELSE            reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    OD              reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    ESAC            reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    CASE_HEADER     reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    RBRACKET        reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    ENDFOR          reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    THEN            reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    COMMA           reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    RBRACE          reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    COLON           reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    TO              reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    DOWNTO          reduce using rule 35 (expr -> expr BITWISE_AND expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51

  ! DOT             [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! LBRACE          [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! PLUS            [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! MINUS           [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! TIMES           [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! DIV             [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! MOD             [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! AND             [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! OR              [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! LSHIFT          [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! RSHIFT          [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! GREATER         [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! LESS            [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! LESS_EQUAL      [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! EQUAL           [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! NOT_EQUAL       [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! XOR             [ reduce using rule 35 (expr -> expr BITWISE_AND expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]


state 74

    (36) expr -> expr BITWISE_OR expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    PLUS_EQUAL      reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    OR_EQUAL        reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    QUEST           reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    BITWISE_OR      reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    OP              reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    DEFINE          reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    BREAK           reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    CASE            reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    RETURN          reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    DO              reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    FOR             reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    IF              reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    PSEUDO          reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    ID              reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    NOT             reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    BITWISE_NOT     reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    LPAREN          reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    NUMBER          reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    $end            reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    RPAREN          reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    OF              reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    FI              reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    ELSE            reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    OD              reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    ESAC            reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    CASE_HEADER     reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    RBRACKET        reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    ENDFOR          reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    THEN            reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    COMMA           reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    RBRACE          reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    COLON           reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    TO              reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    DOWNTO          reduce using rule 36 (expr -> expr BITWISE_OR expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    BITWISE_AND     shift and go to state 31
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51

  ! DOT             [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! LBRACE          [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! BITWISE_AND     [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! PLUS            [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! MINUS           [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! TIMES           [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! DIV             [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! MOD             [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! AND             [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! OR              [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! LSHIFT          [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! RSHIFT          [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! GREATER         [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! LESS            [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! LESS_EQUAL      [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! EQUAL           [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! NOT_EQUAL       [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! XOR             [ reduce using rule 36 (expr -> expr BITWISE_OR expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]


state 75

    (37) expr -> expr OP expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

  ! shift/reduce conflict for UPDATE resolved as shift
  ! shift/reduce conflict for PLUS_EQUAL resolved as shift
  ! shift/reduce conflict for OR_EQUAL resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for QUEST resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT_LOGICAL resolved as shift
  ! shift/reduce conflict for RSHIFT_LOGICAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
    DEFINE          reduce using rule 37 (expr -> expr OP expr .)
    BREAK           reduce using rule 37 (expr -> expr OP expr .)
    CASE            reduce using rule 37 (expr -> expr OP expr .)
    RETURN          reduce using rule 37 (expr -> expr OP expr .)
    DO              reduce using rule 37 (expr -> expr OP expr .)
    FOR             reduce using rule 37 (expr -> expr OP expr .)
    IF              reduce using rule 37 (expr -> expr OP expr .)
    PSEUDO          reduce using rule 37 (expr -> expr OP expr .)
    ID              reduce using rule 37 (expr -> expr OP expr .)
    NOT             reduce using rule 37 (expr -> expr OP expr .)
    BITWISE_NOT     reduce using rule 37 (expr -> expr OP expr .)
    LPAREN          reduce using rule 37 (expr -> expr OP expr .)
    NUMBER          reduce using rule 37 (expr -> expr OP expr .)
    $end            reduce using rule 37 (expr -> expr OP expr .)
    RPAREN          reduce using rule 37 (expr -> expr OP expr .)
    OF              reduce using rule 37 (expr -> expr OP expr .)
    FI              reduce using rule 37 (expr -> expr OP expr .)
    ELSE            reduce using rule 37 (expr -> expr OP expr .)
    OD              reduce using rule 37 (expr -> expr OP expr .)
    ESAC            reduce using rule 37 (expr -> expr OP expr .)
    CASE_HEADER     reduce using rule 37 (expr -> expr OP expr .)
    RBRACKET        reduce using rule 37 (expr -> expr OP expr .)
    ENDFOR          reduce using rule 37 (expr -> expr OP expr .)
    THEN            reduce using rule 37 (expr -> expr OP expr .)
    COMMA           reduce using rule 37 (expr -> expr OP expr .)
    RBRACE          reduce using rule 37 (expr -> expr OP expr .)
    COLON           reduce using rule 37 (expr -> expr OP expr .)
    TO              reduce using rule 37 (expr -> expr OP expr .)
    DOWNTO          reduce using rule 37 (expr -> expr OP expr .)
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51

  ! UPDATE          [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! PLUS_EQUAL      [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! OR_EQUAL        [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! DOT             [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! LBRACE          [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! QUEST           [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! BITWISE_AND     [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! BITWISE_OR      [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! OP              [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! PLUS            [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! MINUS           [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! TIMES           [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! DIV             [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! MOD             [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! AND             [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! OR              [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! LSHIFT          [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! RSHIFT          [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! GREATER         [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! LESS            [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! LESS_EQUAL      [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! EQUAL           [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! NOT_EQUAL       [ reduce using rule 37 (expr -> expr OP expr .) ]
  ! XOR             [ reduce using rule 37 (expr -> expr OP expr .) ]


state 76

    (38) expr -> expr PLUS expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 38 (expr -> expr PLUS expr .)
    PLUS_EQUAL      reduce using rule 38 (expr -> expr PLUS expr .)
    OR_EQUAL        reduce using rule 38 (expr -> expr PLUS expr .)
    QUEST           reduce using rule 38 (expr -> expr PLUS expr .)
    BITWISE_AND     reduce using rule 38 (expr -> expr PLUS expr .)
    BITWISE_OR      reduce using rule 38 (expr -> expr PLUS expr .)
    OP              reduce using rule 38 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 38 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 38 (expr -> expr PLUS expr .)
    AND             reduce using rule 38 (expr -> expr PLUS expr .)
    OR              reduce using rule 38 (expr -> expr PLUS expr .)
    LSHIFT          reduce using rule 38 (expr -> expr PLUS expr .)
    RSHIFT          reduce using rule 38 (expr -> expr PLUS expr .)
    LSHIFT_LOGICAL  reduce using rule 38 (expr -> expr PLUS expr .)
    RSHIFT_LOGICAL  reduce using rule 38 (expr -> expr PLUS expr .)
    GREATER         reduce using rule 38 (expr -> expr PLUS expr .)
    LESS            reduce using rule 38 (expr -> expr PLUS expr .)
    LESS_EQUAL      reduce using rule 38 (expr -> expr PLUS expr .)
    GREATER_EQUAL   reduce using rule 38 (expr -> expr PLUS expr .)
    EQUAL           reduce using rule 38 (expr -> expr PLUS expr .)
    NOT_EQUAL       reduce using rule 38 (expr -> expr PLUS expr .)
    XOR             reduce using rule 38 (expr -> expr PLUS expr .)
    DEFINE          reduce using rule 38 (expr -> expr PLUS expr .)
    BREAK           reduce using rule 38 (expr -> expr PLUS expr .)
    CASE            reduce using rule 38 (expr -> expr PLUS expr .)
    RETURN          reduce using rule 38 (expr -> expr PLUS expr .)
    DO              reduce using rule 38 (expr -> expr PLUS expr .)
    FOR             reduce using rule 38 (expr -> expr PLUS expr .)
    IF              reduce using rule 38 (expr -> expr PLUS expr .)
    PSEUDO          reduce using rule 38 (expr -> expr PLUS expr .)
    ID              reduce using rule 38 (expr -> expr PLUS expr .)
    NOT             reduce using rule 38 (expr -> expr PLUS expr .)
    BITWISE_NOT     reduce using rule 38 (expr -> expr PLUS expr .)
    LPAREN          reduce using rule 38 (expr -> expr PLUS expr .)
    NUMBER          reduce using rule 38 (expr -> expr PLUS expr .)
    $end            reduce using rule 38 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 38 (expr -> expr PLUS expr .)
    OF              reduce using rule 38 (expr -> expr PLUS expr .)
    FI              reduce using rule 38 (expr -> expr PLUS expr .)
    ELSE            reduce using rule 38 (expr -> expr PLUS expr .)
    OD              reduce using rule 38 (expr -> expr PLUS expr .)
    ESAC            reduce using rule 38 (expr -> expr PLUS expr .)
    CASE_HEADER     reduce using rule 38 (expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 38 (expr -> expr PLUS expr .)
    ENDFOR          reduce using rule 38 (expr -> expr PLUS expr .)
    THEN            reduce using rule 38 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 38 (expr -> expr PLUS expr .)
    RBRACE          reduce using rule 38 (expr -> expr PLUS expr .)
    COLON           reduce using rule 38 (expr -> expr PLUS expr .)
    TO              reduce using rule 38 (expr -> expr PLUS expr .)
    DOWNTO          reduce using rule 38 (expr -> expr PLUS expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38

  ! DOT             [ reduce using rule 38 (expr -> expr PLUS expr .) ]
  ! LBRACE          [ reduce using rule 38 (expr -> expr PLUS expr .) ]
  ! TIMES           [ reduce using rule 38 (expr -> expr PLUS expr .) ]
  ! DIV             [ reduce using rule 38 (expr -> expr PLUS expr .) ]
  ! MOD             [ reduce using rule 38 (expr -> expr PLUS expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! LSHIFT          [ shift and go to state 41 ]
  ! RSHIFT          [ shift and go to state 42 ]
  ! LSHIFT_LOGICAL  [ shift and go to state 43 ]
  ! RSHIFT_LOGICAL  [ shift and go to state 44 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 77

    (39) expr -> expr MINUS expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 39 (expr -> expr MINUS expr .)
    PLUS_EQUAL      reduce using rule 39 (expr -> expr MINUS expr .)
    OR_EQUAL        reduce using rule 39 (expr -> expr MINUS expr .)
    QUEST           reduce using rule 39 (expr -> expr MINUS expr .)
    BITWISE_AND     reduce using rule 39 (expr -> expr MINUS expr .)
    BITWISE_OR      reduce using rule 39 (expr -> expr MINUS expr .)
    OP              reduce using rule 39 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 39 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 39 (expr -> expr MINUS expr .)
    AND             reduce using rule 39 (expr -> expr MINUS expr .)
    OR              reduce using rule 39 (expr -> expr MINUS expr .)
    LSHIFT          reduce using rule 39 (expr -> expr MINUS expr .)
    RSHIFT          reduce using rule 39 (expr -> expr MINUS expr .)
    LSHIFT_LOGICAL  reduce using rule 39 (expr -> expr MINUS expr .)
    RSHIFT_LOGICAL  reduce using rule 39 (expr -> expr MINUS expr .)
    GREATER         reduce using rule 39 (expr -> expr MINUS expr .)
    LESS            reduce using rule 39 (expr -> expr MINUS expr .)
    LESS_EQUAL      reduce using rule 39 (expr -> expr MINUS expr .)
    GREATER_EQUAL   reduce using rule 39 (expr -> expr MINUS expr .)
    EQUAL           reduce using rule 39 (expr -> expr MINUS expr .)
    NOT_EQUAL       reduce using rule 39 (expr -> expr MINUS expr .)
    XOR             reduce using rule 39 (expr -> expr MINUS expr .)
    DEFINE          reduce using rule 39 (expr -> expr MINUS expr .)
    BREAK           reduce using rule 39 (expr -> expr MINUS expr .)
    CASE            reduce using rule 39 (expr -> expr MINUS expr .)
    RETURN          reduce using rule 39 (expr -> expr MINUS expr .)
    DO              reduce using rule 39 (expr -> expr MINUS expr .)
    FOR             reduce using rule 39 (expr -> expr MINUS expr .)
    IF              reduce using rule 39 (expr -> expr MINUS expr .)
    PSEUDO          reduce using rule 39 (expr -> expr MINUS expr .)
    ID              reduce using rule 39 (expr -> expr MINUS expr .)
    NOT             reduce using rule 39 (expr -> expr MINUS expr .)
    BITWISE_NOT     reduce using rule 39 (expr -> expr MINUS expr .)
    LPAREN          reduce using rule 39 (expr -> expr MINUS expr .)
    NUMBER          reduce using rule 39 (expr -> expr MINUS expr .)
    $end            reduce using rule 39 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 39 (expr -> expr MINUS expr .)
    OF              reduce using rule 39 (expr -> expr MINUS expr .)
    FI              reduce using rule 39 (expr -> expr MINUS expr .)
    ELSE            reduce using rule 39 (expr -> expr MINUS expr .)
    OD              reduce using rule 39 (expr -> expr MINUS expr .)
    ESAC            reduce using rule 39 (expr -> expr MINUS expr .)
    CASE_HEADER     reduce using rule 39 (expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 39 (expr -> expr MINUS expr .)
    ENDFOR          reduce using rule 39 (expr -> expr MINUS expr .)
    THEN            reduce using rule 39 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 39 (expr -> expr MINUS expr .)
    RBRACE          reduce using rule 39 (expr -> expr MINUS expr .)
    COLON           reduce using rule 39 (expr -> expr MINUS expr .)
    TO              reduce using rule 39 (expr -> expr MINUS expr .)
    DOWNTO          reduce using rule 39 (expr -> expr MINUS expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38

  ! DOT             [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! LBRACE          [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! TIMES           [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! DIV             [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! LSHIFT          [ shift and go to state 41 ]
  ! RSHIFT          [ shift and go to state 42 ]
  ! LSHIFT_LOGICAL  [ shift and go to state 43 ]
  ! RSHIFT_LOGICAL  [ shift and go to state 44 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 78

    (40) expr -> expr TIMES expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 40 (expr -> expr TIMES expr .)
    PLUS_EQUAL      reduce using rule 40 (expr -> expr TIMES expr .)
    OR_EQUAL        reduce using rule 40 (expr -> expr TIMES expr .)
    QUEST           reduce using rule 40 (expr -> expr TIMES expr .)
    BITWISE_AND     reduce using rule 40 (expr -> expr TIMES expr .)
    BITWISE_OR      reduce using rule 40 (expr -> expr TIMES expr .)
    OP              reduce using rule 40 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 40 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 40 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 40 (expr -> expr TIMES expr .)
    DIV             reduce using rule 40 (expr -> expr TIMES expr .)
    MOD             reduce using rule 40 (expr -> expr TIMES expr .)
    AND             reduce using rule 40 (expr -> expr TIMES expr .)
    OR              reduce using rule 40 (expr -> expr TIMES expr .)
    LSHIFT          reduce using rule 40 (expr -> expr TIMES expr .)
    RSHIFT          reduce using rule 40 (expr -> expr TIMES expr .)
    LSHIFT_LOGICAL  reduce using rule 40 (expr -> expr TIMES expr .)
    RSHIFT_LOGICAL  reduce using rule 40 (expr -> expr TIMES expr .)
    GREATER         reduce using rule 40 (expr -> expr TIMES expr .)
    LESS            reduce using rule 40 (expr -> expr TIMES expr .)
    LESS_EQUAL      reduce using rule 40 (expr -> expr TIMES expr .)
    GREATER_EQUAL   reduce using rule 40 (expr -> expr TIMES expr .)
    EQUAL           reduce using rule 40 (expr -> expr TIMES expr .)
    NOT_EQUAL       reduce using rule 40 (expr -> expr TIMES expr .)
    XOR             reduce using rule 40 (expr -> expr TIMES expr .)
    DEFINE          reduce using rule 40 (expr -> expr TIMES expr .)
    BREAK           reduce using rule 40 (expr -> expr TIMES expr .)
    CASE            reduce using rule 40 (expr -> expr TIMES expr .)
    RETURN          reduce using rule 40 (expr -> expr TIMES expr .)
    DO              reduce using rule 40 (expr -> expr TIMES expr .)
    FOR             reduce using rule 40 (expr -> expr TIMES expr .)
    IF              reduce using rule 40 (expr -> expr TIMES expr .)
    PSEUDO          reduce using rule 40 (expr -> expr TIMES expr .)
    ID              reduce using rule 40 (expr -> expr TIMES expr .)
    NOT             reduce using rule 40 (expr -> expr TIMES expr .)
    BITWISE_NOT     reduce using rule 40 (expr -> expr TIMES expr .)
    LPAREN          reduce using rule 40 (expr -> expr TIMES expr .)
    NUMBER          reduce using rule 40 (expr -> expr TIMES expr .)
    $end            reduce using rule 40 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 40 (expr -> expr TIMES expr .)
    OF              reduce using rule 40 (expr -> expr TIMES expr .)
    FI              reduce using rule 40 (expr -> expr TIMES expr .)
    ELSE            reduce using rule 40 (expr -> expr TIMES expr .)
    OD              reduce using rule 40 (expr -> expr TIMES expr .)
    ESAC            reduce using rule 40 (expr -> expr TIMES expr .)
    CASE_HEADER     reduce using rule 40 (expr -> expr TIMES expr .)
    RBRACKET        reduce using rule 40 (expr -> expr TIMES expr .)
    ENDFOR          reduce using rule 40 (expr -> expr TIMES expr .)
    THEN            reduce using rule 40 (expr -> expr TIMES expr .)
    COMMA           reduce using rule 40 (expr -> expr TIMES expr .)
    RBRACE          reduce using rule 40 (expr -> expr TIMES expr .)
    COLON           reduce using rule 40 (expr -> expr TIMES expr .)
    TO              reduce using rule 40 (expr -> expr TIMES expr .)
    DOWNTO          reduce using rule 40 (expr -> expr TIMES expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29

  ! DOT             [ reduce using rule 40 (expr -> expr TIMES expr .) ]
  ! LBRACE          [ reduce using rule 40 (expr -> expr TIMES expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! TIMES           [ shift and go to state 36 ]
  ! DIV             [ shift and go to state 37 ]
  ! MOD             [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! LSHIFT          [ shift and go to state 41 ]
  ! RSHIFT          [ shift and go to state 42 ]
  ! LSHIFT_LOGICAL  [ shift and go to state 43 ]
  ! RSHIFT_LOGICAL  [ shift and go to state 44 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 79

    (41) expr -> expr DIV expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 41 (expr -> expr DIV expr .)
    PLUS_EQUAL      reduce using rule 41 (expr -> expr DIV expr .)
    OR_EQUAL        reduce using rule 41 (expr -> expr DIV expr .)
    QUEST           reduce using rule 41 (expr -> expr DIV expr .)
    BITWISE_AND     reduce using rule 41 (expr -> expr DIV expr .)
    BITWISE_OR      reduce using rule 41 (expr -> expr DIV expr .)
    OP              reduce using rule 41 (expr -> expr DIV expr .)
    PLUS            reduce using rule 41 (expr -> expr DIV expr .)
    MINUS           reduce using rule 41 (expr -> expr DIV expr .)
    TIMES           reduce using rule 41 (expr -> expr DIV expr .)
    DIV             reduce using rule 41 (expr -> expr DIV expr .)
    MOD             reduce using rule 41 (expr -> expr DIV expr .)
    AND             reduce using rule 41 (expr -> expr DIV expr .)
    OR              reduce using rule 41 (expr -> expr DIV expr .)
    LSHIFT          reduce using rule 41 (expr -> expr DIV expr .)
    RSHIFT          reduce using rule 41 (expr -> expr DIV expr .)
    LSHIFT_LOGICAL  reduce using rule 41 (expr -> expr DIV expr .)
    RSHIFT_LOGICAL  reduce using rule 41 (expr -> expr DIV expr .)
    GREATER         reduce using rule 41 (expr -> expr DIV expr .)
    LESS            reduce using rule 41 (expr -> expr DIV expr .)
    LESS_EQUAL      reduce using rule 41 (expr -> expr DIV expr .)
    GREATER_EQUAL   reduce using rule 41 (expr -> expr DIV expr .)
    EQUAL           reduce using rule 41 (expr -> expr DIV expr .)
    NOT_EQUAL       reduce using rule 41 (expr -> expr DIV expr .)
    XOR             reduce using rule 41 (expr -> expr DIV expr .)
    DEFINE          reduce using rule 41 (expr -> expr DIV expr .)
    BREAK           reduce using rule 41 (expr -> expr DIV expr .)
    CASE            reduce using rule 41 (expr -> expr DIV expr .)
    RETURN          reduce using rule 41 (expr -> expr DIV expr .)
    DO              reduce using rule 41 (expr -> expr DIV expr .)
    FOR             reduce using rule 41 (expr -> expr DIV expr .)
    IF              reduce using rule 41 (expr -> expr DIV expr .)
    PSEUDO          reduce using rule 41 (expr -> expr DIV expr .)
    ID              reduce using rule 41 (expr -> expr DIV expr .)
    NOT             reduce using rule 41 (expr -> expr DIV expr .)
    BITWISE_NOT     reduce using rule 41 (expr -> expr DIV expr .)
    LPAREN          reduce using rule 41 (expr -> expr DIV expr .)
    NUMBER          reduce using rule 41 (expr -> expr DIV expr .)
    $end            reduce using rule 41 (expr -> expr DIV expr .)
    RPAREN          reduce using rule 41 (expr -> expr DIV expr .)
    OF              reduce using rule 41 (expr -> expr DIV expr .)
    FI              reduce using rule 41 (expr -> expr DIV expr .)
    ELSE            reduce using rule 41 (expr -> expr DIV expr .)
    OD              reduce using rule 41 (expr -> expr DIV expr .)
    ESAC            reduce using rule 41 (expr -> expr DIV expr .)
    CASE_HEADER     reduce using rule 41 (expr -> expr DIV expr .)
    RBRACKET        reduce using rule 41 (expr -> expr DIV expr .)
    ENDFOR          reduce using rule 41 (expr -> expr DIV expr .)
    THEN            reduce using rule 41 (expr -> expr DIV expr .)
    COMMA           reduce using rule 41 (expr -> expr DIV expr .)
    RBRACE          reduce using rule 41 (expr -> expr DIV expr .)
    COLON           reduce using rule 41 (expr -> expr DIV expr .)
    TO              reduce using rule 41 (expr -> expr DIV expr .)
    DOWNTO          reduce using rule 41 (expr -> expr DIV expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29

  ! DOT             [ reduce using rule 41 (expr -> expr DIV expr .) ]
  ! LBRACE          [ reduce using rule 41 (expr -> expr DIV expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! TIMES           [ shift and go to state 36 ]
  ! DIV             [ shift and go to state 37 ]
  ! MOD             [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! LSHIFT          [ shift and go to state 41 ]
  ! RSHIFT          [ shift and go to state 42 ]
  ! LSHIFT_LOGICAL  [ shift and go to state 43 ]
  ! RSHIFT_LOGICAL  [ shift and go to state 44 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 80

    (42) expr -> expr MOD expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 42 (expr -> expr MOD expr .)
    PLUS_EQUAL      reduce using rule 42 (expr -> expr MOD expr .)
    OR_EQUAL        reduce using rule 42 (expr -> expr MOD expr .)
    QUEST           reduce using rule 42 (expr -> expr MOD expr .)
    BITWISE_AND     reduce using rule 42 (expr -> expr MOD expr .)
    BITWISE_OR      reduce using rule 42 (expr -> expr MOD expr .)
    OP              reduce using rule 42 (expr -> expr MOD expr .)
    PLUS            reduce using rule 42 (expr -> expr MOD expr .)
    MINUS           reduce using rule 42 (expr -> expr MOD expr .)
    TIMES           reduce using rule 42 (expr -> expr MOD expr .)
    DIV             reduce using rule 42 (expr -> expr MOD expr .)
    MOD             reduce using rule 42 (expr -> expr MOD expr .)
    AND             reduce using rule 42 (expr -> expr MOD expr .)
    OR              reduce using rule 42 (expr -> expr MOD expr .)
    LSHIFT          reduce using rule 42 (expr -> expr MOD expr .)
    RSHIFT          reduce using rule 42 (expr -> expr MOD expr .)
    LSHIFT_LOGICAL  reduce using rule 42 (expr -> expr MOD expr .)
    RSHIFT_LOGICAL  reduce using rule 42 (expr -> expr MOD expr .)
    GREATER         reduce using rule 42 (expr -> expr MOD expr .)
    LESS            reduce using rule 42 (expr -> expr MOD expr .)
    LESS_EQUAL      reduce using rule 42 (expr -> expr MOD expr .)
    GREATER_EQUAL   reduce using rule 42 (expr -> expr MOD expr .)
    EQUAL           reduce using rule 42 (expr -> expr MOD expr .)
    NOT_EQUAL       reduce using rule 42 (expr -> expr MOD expr .)
    XOR             reduce using rule 42 (expr -> expr MOD expr .)
    DEFINE          reduce using rule 42 (expr -> expr MOD expr .)
    BREAK           reduce using rule 42 (expr -> expr MOD expr .)
    CASE            reduce using rule 42 (expr -> expr MOD expr .)
    RETURN          reduce using rule 42 (expr -> expr MOD expr .)
    DO              reduce using rule 42 (expr -> expr MOD expr .)
    FOR             reduce using rule 42 (expr -> expr MOD expr .)
    IF              reduce using rule 42 (expr -> expr MOD expr .)
    PSEUDO          reduce using rule 42 (expr -> expr MOD expr .)
    ID              reduce using rule 42 (expr -> expr MOD expr .)
    NOT             reduce using rule 42 (expr -> expr MOD expr .)
    BITWISE_NOT     reduce using rule 42 (expr -> expr MOD expr .)
    LPAREN          reduce using rule 42 (expr -> expr MOD expr .)
    NUMBER          reduce using rule 42 (expr -> expr MOD expr .)
    $end            reduce using rule 42 (expr -> expr MOD expr .)
    RPAREN          reduce using rule 42 (expr -> expr MOD expr .)
    OF              reduce using rule 42 (expr -> expr MOD expr .)
    FI              reduce using rule 42 (expr -> expr MOD expr .)
    ELSE            reduce using rule 42 (expr -> expr MOD expr .)
    OD              reduce using rule 42 (expr -> expr MOD expr .)
    ESAC            reduce using rule 42 (expr -> expr MOD expr .)
    CASE_HEADER     reduce using rule 42 (expr -> expr MOD expr .)
    RBRACKET        reduce using rule 42 (expr -> expr MOD expr .)
    ENDFOR          reduce using rule 42 (expr -> expr MOD expr .)
    THEN            reduce using rule 42 (expr -> expr MOD expr .)
    COMMA           reduce using rule 42 (expr -> expr MOD expr .)
    RBRACE          reduce using rule 42 (expr -> expr MOD expr .)
    COLON           reduce using rule 42 (expr -> expr MOD expr .)
    TO              reduce using rule 42 (expr -> expr MOD expr .)
    DOWNTO          reduce using rule 42 (expr -> expr MOD expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29

  ! DOT             [ reduce using rule 42 (expr -> expr MOD expr .) ]
  ! LBRACE          [ reduce using rule 42 (expr -> expr MOD expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! TIMES           [ shift and go to state 36 ]
  ! DIV             [ shift and go to state 37 ]
  ! MOD             [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! LSHIFT          [ shift and go to state 41 ]
  ! RSHIFT          [ shift and go to state 42 ]
  ! LSHIFT_LOGICAL  [ shift and go to state 43 ]
  ! RSHIFT_LOGICAL  [ shift and go to state 44 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 81

    (43) expr -> expr AND expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 43 (expr -> expr AND expr .)
    PLUS_EQUAL      reduce using rule 43 (expr -> expr AND expr .)
    OR_EQUAL        reduce using rule 43 (expr -> expr AND expr .)
    QUEST           reduce using rule 43 (expr -> expr AND expr .)
    BITWISE_AND     reduce using rule 43 (expr -> expr AND expr .)
    BITWISE_OR      reduce using rule 43 (expr -> expr AND expr .)
    OP              reduce using rule 43 (expr -> expr AND expr .)
    AND             reduce using rule 43 (expr -> expr AND expr .)
    OR              reduce using rule 43 (expr -> expr AND expr .)
    DEFINE          reduce using rule 43 (expr -> expr AND expr .)
    BREAK           reduce using rule 43 (expr -> expr AND expr .)
    CASE            reduce using rule 43 (expr -> expr AND expr .)
    RETURN          reduce using rule 43 (expr -> expr AND expr .)
    DO              reduce using rule 43 (expr -> expr AND expr .)
    FOR             reduce using rule 43 (expr -> expr AND expr .)
    IF              reduce using rule 43 (expr -> expr AND expr .)
    PSEUDO          reduce using rule 43 (expr -> expr AND expr .)
    ID              reduce using rule 43 (expr -> expr AND expr .)
    NOT             reduce using rule 43 (expr -> expr AND expr .)
    BITWISE_NOT     reduce using rule 43 (expr -> expr AND expr .)
    LPAREN          reduce using rule 43 (expr -> expr AND expr .)
    NUMBER          reduce using rule 43 (expr -> expr AND expr .)
    $end            reduce using rule 43 (expr -> expr AND expr .)
    RPAREN          reduce using rule 43 (expr -> expr AND expr .)
    OF              reduce using rule 43 (expr -> expr AND expr .)
    FI              reduce using rule 43 (expr -> expr AND expr .)
    ELSE            reduce using rule 43 (expr -> expr AND expr .)
    OD              reduce using rule 43 (expr -> expr AND expr .)
    ESAC            reduce using rule 43 (expr -> expr AND expr .)
    CASE_HEADER     reduce using rule 43 (expr -> expr AND expr .)
    RBRACKET        reduce using rule 43 (expr -> expr AND expr .)
    ENDFOR          reduce using rule 43 (expr -> expr AND expr .)
    THEN            reduce using rule 43 (expr -> expr AND expr .)
    COMMA           reduce using rule 43 (expr -> expr AND expr .)
    RBRACE          reduce using rule 43 (expr -> expr AND expr .)
    COLON           reduce using rule 43 (expr -> expr AND expr .)
    TO              reduce using rule 43 (expr -> expr AND expr .)
    DOWNTO          reduce using rule 43 (expr -> expr AND expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51

  ! DOT             [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! LBRACE          [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! PLUS            [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! TIMES           [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! DIV             [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! MOD             [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! LSHIFT          [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! RSHIFT          [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! GREATER         [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! LESS            [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! LESS_EQUAL      [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! EQUAL           [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! NOT_EQUAL       [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! XOR             [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]


state 82

    (44) expr -> expr OR expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 44 (expr -> expr OR expr .)
    PLUS_EQUAL      reduce using rule 44 (expr -> expr OR expr .)
    OR_EQUAL        reduce using rule 44 (expr -> expr OR expr .)
    QUEST           reduce using rule 44 (expr -> expr OR expr .)
    BITWISE_AND     reduce using rule 44 (expr -> expr OR expr .)
    BITWISE_OR      reduce using rule 44 (expr -> expr OR expr .)
    OP              reduce using rule 44 (expr -> expr OR expr .)
    OR              reduce using rule 44 (expr -> expr OR expr .)
    DEFINE          reduce using rule 44 (expr -> expr OR expr .)
    BREAK           reduce using rule 44 (expr -> expr OR expr .)
    CASE            reduce using rule 44 (expr -> expr OR expr .)
    RETURN          reduce using rule 44 (expr -> expr OR expr .)
    DO              reduce using rule 44 (expr -> expr OR expr .)
    FOR             reduce using rule 44 (expr -> expr OR expr .)
    IF              reduce using rule 44 (expr -> expr OR expr .)
    PSEUDO          reduce using rule 44 (expr -> expr OR expr .)
    ID              reduce using rule 44 (expr -> expr OR expr .)
    NOT             reduce using rule 44 (expr -> expr OR expr .)
    BITWISE_NOT     reduce using rule 44 (expr -> expr OR expr .)
    LPAREN          reduce using rule 44 (expr -> expr OR expr .)
    NUMBER          reduce using rule 44 (expr -> expr OR expr .)
    $end            reduce using rule 44 (expr -> expr OR expr .)
    RPAREN          reduce using rule 44 (expr -> expr OR expr .)
    OF              reduce using rule 44 (expr -> expr OR expr .)
    FI              reduce using rule 44 (expr -> expr OR expr .)
    ELSE            reduce using rule 44 (expr -> expr OR expr .)
    OD              reduce using rule 44 (expr -> expr OR expr .)
    ESAC            reduce using rule 44 (expr -> expr OR expr .)
    CASE_HEADER     reduce using rule 44 (expr -> expr OR expr .)
    RBRACKET        reduce using rule 44 (expr -> expr OR expr .)
    ENDFOR          reduce using rule 44 (expr -> expr OR expr .)
    THEN            reduce using rule 44 (expr -> expr OR expr .)
    COMMA           reduce using rule 44 (expr -> expr OR expr .)
    RBRACE          reduce using rule 44 (expr -> expr OR expr .)
    COLON           reduce using rule 44 (expr -> expr OR expr .)
    TO              reduce using rule 44 (expr -> expr OR expr .)
    DOWNTO          reduce using rule 44 (expr -> expr OR expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51

  ! DOT             [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! LBRACE          [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! PLUS            [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! TIMES           [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! DIV             [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! MOD             [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! LSHIFT          [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! RSHIFT          [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! GREATER         [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! LESS            [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! LESS_EQUAL      [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! EQUAL           [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! NOT_EQUAL       [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! XOR             [ reduce using rule 44 (expr -> expr OR expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! OR              [ shift and go to state 40 ]


state 83

    (45) expr -> expr LSHIFT expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 45 (expr -> expr LSHIFT expr .)
    PLUS_EQUAL      reduce using rule 45 (expr -> expr LSHIFT expr .)
    OR_EQUAL        reduce using rule 45 (expr -> expr LSHIFT expr .)
    QUEST           reduce using rule 45 (expr -> expr LSHIFT expr .)
    BITWISE_AND     reduce using rule 45 (expr -> expr LSHIFT expr .)
    BITWISE_OR      reduce using rule 45 (expr -> expr LSHIFT expr .)
    OP              reduce using rule 45 (expr -> expr LSHIFT expr .)
    AND             reduce using rule 45 (expr -> expr LSHIFT expr .)
    OR              reduce using rule 45 (expr -> expr LSHIFT expr .)
    LSHIFT          reduce using rule 45 (expr -> expr LSHIFT expr .)
    RSHIFT          reduce using rule 45 (expr -> expr LSHIFT expr .)
    LSHIFT_LOGICAL  reduce using rule 45 (expr -> expr LSHIFT expr .)
    RSHIFT_LOGICAL  reduce using rule 45 (expr -> expr LSHIFT expr .)
    GREATER         reduce using rule 45 (expr -> expr LSHIFT expr .)
    LESS            reduce using rule 45 (expr -> expr LSHIFT expr .)
    LESS_EQUAL      reduce using rule 45 (expr -> expr LSHIFT expr .)
    GREATER_EQUAL   reduce using rule 45 (expr -> expr LSHIFT expr .)
    EQUAL           reduce using rule 45 (expr -> expr LSHIFT expr .)
    NOT_EQUAL       reduce using rule 45 (expr -> expr LSHIFT expr .)
    XOR             reduce using rule 45 (expr -> expr LSHIFT expr .)
    DEFINE          reduce using rule 45 (expr -> expr LSHIFT expr .)
    BREAK           reduce using rule 45 (expr -> expr LSHIFT expr .)
    CASE            reduce using rule 45 (expr -> expr LSHIFT expr .)
    RETURN          reduce using rule 45 (expr -> expr LSHIFT expr .)
    DO              reduce using rule 45 (expr -> expr LSHIFT expr .)
    FOR             reduce using rule 45 (expr -> expr LSHIFT expr .)
    IF              reduce using rule 45 (expr -> expr LSHIFT expr .)
    PSEUDO          reduce using rule 45 (expr -> expr LSHIFT expr .)
    ID              reduce using rule 45 (expr -> expr LSHIFT expr .)
    NOT             reduce using rule 45 (expr -> expr LSHIFT expr .)
    BITWISE_NOT     reduce using rule 45 (expr -> expr LSHIFT expr .)
    LPAREN          reduce using rule 45 (expr -> expr LSHIFT expr .)
    NUMBER          reduce using rule 45 (expr -> expr LSHIFT expr .)
    $end            reduce using rule 45 (expr -> expr LSHIFT expr .)
    RPAREN          reduce using rule 45 (expr -> expr LSHIFT expr .)
    OF              reduce using rule 45 (expr -> expr LSHIFT expr .)
    FI              reduce using rule 45 (expr -> expr LSHIFT expr .)
    ELSE            reduce using rule 45 (expr -> expr LSHIFT expr .)
    OD              reduce using rule 45 (expr -> expr LSHIFT expr .)
    ESAC            reduce using rule 45 (expr -> expr LSHIFT expr .)
    CASE_HEADER     reduce using rule 45 (expr -> expr LSHIFT expr .)
    RBRACKET        reduce using rule 45 (expr -> expr LSHIFT expr .)
    ENDFOR          reduce using rule 45 (expr -> expr LSHIFT expr .)
    THEN            reduce using rule 45 (expr -> expr LSHIFT expr .)
    COMMA           reduce using rule 45 (expr -> expr LSHIFT expr .)
    RBRACE          reduce using rule 45 (expr -> expr LSHIFT expr .)
    COLON           reduce using rule 45 (expr -> expr LSHIFT expr .)
    TO              reduce using rule 45 (expr -> expr LSHIFT expr .)
    DOWNTO          reduce using rule 45 (expr -> expr LSHIFT expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38

  ! DOT             [ reduce using rule 45 (expr -> expr LSHIFT expr .) ]
  ! LBRACE          [ reduce using rule 45 (expr -> expr LSHIFT expr .) ]
  ! PLUS            [ reduce using rule 45 (expr -> expr LSHIFT expr .) ]
  ! MINUS           [ reduce using rule 45 (expr -> expr LSHIFT expr .) ]
  ! TIMES           [ reduce using rule 45 (expr -> expr LSHIFT expr .) ]
  ! DIV             [ reduce using rule 45 (expr -> expr LSHIFT expr .) ]
  ! MOD             [ reduce using rule 45 (expr -> expr LSHIFT expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! LSHIFT          [ shift and go to state 41 ]
  ! RSHIFT          [ shift and go to state 42 ]
  ! LSHIFT_LOGICAL  [ shift and go to state 43 ]
  ! RSHIFT_LOGICAL  [ shift and go to state 44 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 84

    (46) expr -> expr RSHIFT expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 46 (expr -> expr RSHIFT expr .)
    PLUS_EQUAL      reduce using rule 46 (expr -> expr RSHIFT expr .)
    OR_EQUAL        reduce using rule 46 (expr -> expr RSHIFT expr .)
    QUEST           reduce using rule 46 (expr -> expr RSHIFT expr .)
    BITWISE_AND     reduce using rule 46 (expr -> expr RSHIFT expr .)
    BITWISE_OR      reduce using rule 46 (expr -> expr RSHIFT expr .)
    OP              reduce using rule 46 (expr -> expr RSHIFT expr .)
    AND             reduce using rule 46 (expr -> expr RSHIFT expr .)
    OR              reduce using rule 46 (expr -> expr RSHIFT expr .)
    LSHIFT          reduce using rule 46 (expr -> expr RSHIFT expr .)
    RSHIFT          reduce using rule 46 (expr -> expr RSHIFT expr .)
    LSHIFT_LOGICAL  reduce using rule 46 (expr -> expr RSHIFT expr .)
    RSHIFT_LOGICAL  reduce using rule 46 (expr -> expr RSHIFT expr .)
    GREATER         reduce using rule 46 (expr -> expr RSHIFT expr .)
    LESS            reduce using rule 46 (expr -> expr RSHIFT expr .)
    LESS_EQUAL      reduce using rule 46 (expr -> expr RSHIFT expr .)
    GREATER_EQUAL   reduce using rule 46 (expr -> expr RSHIFT expr .)
    EQUAL           reduce using rule 46 (expr -> expr RSHIFT expr .)
    NOT_EQUAL       reduce using rule 46 (expr -> expr RSHIFT expr .)
    XOR             reduce using rule 46 (expr -> expr RSHIFT expr .)
    DEFINE          reduce using rule 46 (expr -> expr RSHIFT expr .)
    BREAK           reduce using rule 46 (expr -> expr RSHIFT expr .)
    CASE            reduce using rule 46 (expr -> expr RSHIFT expr .)
    RETURN          reduce using rule 46 (expr -> expr RSHIFT expr .)
    DO              reduce using rule 46 (expr -> expr RSHIFT expr .)
    FOR             reduce using rule 46 (expr -> expr RSHIFT expr .)
    IF              reduce using rule 46 (expr -> expr RSHIFT expr .)
    PSEUDO          reduce using rule 46 (expr -> expr RSHIFT expr .)
    ID              reduce using rule 46 (expr -> expr RSHIFT expr .)
    NOT             reduce using rule 46 (expr -> expr RSHIFT expr .)
    BITWISE_NOT     reduce using rule 46 (expr -> expr RSHIFT expr .)
    LPAREN          reduce using rule 46 (expr -> expr RSHIFT expr .)
    NUMBER          reduce using rule 46 (expr -> expr RSHIFT expr .)
    $end            reduce using rule 46 (expr -> expr RSHIFT expr .)
    RPAREN          reduce using rule 46 (expr -> expr RSHIFT expr .)
    OF              reduce using rule 46 (expr -> expr RSHIFT expr .)
    FI              reduce using rule 46 (expr -> expr RSHIFT expr .)
    ELSE            reduce using rule 46 (expr -> expr RSHIFT expr .)
    OD              reduce using rule 46 (expr -> expr RSHIFT expr .)
    ESAC            reduce using rule 46 (expr -> expr RSHIFT expr .)
    CASE_HEADER     reduce using rule 46 (expr -> expr RSHIFT expr .)
    RBRACKET        reduce using rule 46 (expr -> expr RSHIFT expr .)
    ENDFOR          reduce using rule 46 (expr -> expr RSHIFT expr .)
    THEN            reduce using rule 46 (expr -> expr RSHIFT expr .)
    COMMA           reduce using rule 46 (expr -> expr RSHIFT expr .)
    RBRACE          reduce using rule 46 (expr -> expr RSHIFT expr .)
    COLON           reduce using rule 46 (expr -> expr RSHIFT expr .)
    TO              reduce using rule 46 (expr -> expr RSHIFT expr .)
    DOWNTO          reduce using rule 46 (expr -> expr RSHIFT expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38

  ! DOT             [ reduce using rule 46 (expr -> expr RSHIFT expr .) ]
  ! LBRACE          [ reduce using rule 46 (expr -> expr RSHIFT expr .) ]
  ! PLUS            [ reduce using rule 46 (expr -> expr RSHIFT expr .) ]
  ! MINUS           [ reduce using rule 46 (expr -> expr RSHIFT expr .) ]
  ! TIMES           [ reduce using rule 46 (expr -> expr RSHIFT expr .) ]
  ! DIV             [ reduce using rule 46 (expr -> expr RSHIFT expr .) ]
  ! MOD             [ reduce using rule 46 (expr -> expr RSHIFT expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! LSHIFT          [ shift and go to state 41 ]
  ! RSHIFT          [ shift and go to state 42 ]
  ! LSHIFT_LOGICAL  [ shift and go to state 43 ]
  ! RSHIFT_LOGICAL  [ shift and go to state 44 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 85

    (47) expr -> expr LSHIFT_LOGICAL expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    PLUS_EQUAL      reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    OR_EQUAL        reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    QUEST           reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    BITWISE_AND     reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    BITWISE_OR      reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    OP              reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    AND             reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    OR              reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    LSHIFT          reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    RSHIFT          reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    LSHIFT_LOGICAL  reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    RSHIFT_LOGICAL  reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    GREATER         reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    LESS            reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    LESS_EQUAL      reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    GREATER_EQUAL   reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    EQUAL           reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    NOT_EQUAL       reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    XOR             reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    DEFINE          reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    BREAK           reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    CASE            reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    RETURN          reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    DO              reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    FOR             reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    IF              reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    PSEUDO          reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    ID              reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    NOT             reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    BITWISE_NOT     reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    LPAREN          reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    NUMBER          reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    $end            reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    RPAREN          reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    OF              reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    FI              reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    ELSE            reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    OD              reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    ESAC            reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    CASE_HEADER     reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    RBRACKET        reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    ENDFOR          reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    THEN            reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    COMMA           reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    RBRACE          reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    COLON           reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    TO              reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    DOWNTO          reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38

  ! DOT             [ reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .) ]
  ! LBRACE          [ reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .) ]
  ! PLUS            [ reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .) ]
  ! MINUS           [ reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .) ]
  ! TIMES           [ reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .) ]
  ! DIV             [ reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .) ]
  ! MOD             [ reduce using rule 47 (expr -> expr LSHIFT_LOGICAL expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! LSHIFT          [ shift and go to state 41 ]
  ! RSHIFT          [ shift and go to state 42 ]
  ! LSHIFT_LOGICAL  [ shift and go to state 43 ]
  ! RSHIFT_LOGICAL  [ shift and go to state 44 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 86

    (48) expr -> expr RSHIFT_LOGICAL expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    PLUS_EQUAL      reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    OR_EQUAL        reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    QUEST           reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    BITWISE_AND     reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    BITWISE_OR      reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    OP              reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    AND             reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    OR              reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    LSHIFT          reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    RSHIFT          reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    LSHIFT_LOGICAL  reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    RSHIFT_LOGICAL  reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    GREATER         reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    LESS            reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    LESS_EQUAL      reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    GREATER_EQUAL   reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    EQUAL           reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    NOT_EQUAL       reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    XOR             reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    DEFINE          reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    BREAK           reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    CASE            reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    RETURN          reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    DO              reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    FOR             reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    IF              reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    PSEUDO          reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    ID              reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    NOT             reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    BITWISE_NOT     reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    LPAREN          reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    NUMBER          reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    $end            reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    RPAREN          reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    OF              reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    FI              reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    ELSE            reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    OD              reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    ESAC            reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    CASE_HEADER     reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    RBRACKET        reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    ENDFOR          reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    THEN            reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    COMMA           reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    RBRACE          reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    COLON           reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    TO              reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    DOWNTO          reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38

  ! DOT             [ reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .) ]
  ! LBRACE          [ reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .) ]
  ! PLUS            [ reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .) ]
  ! MINUS           [ reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .) ]
  ! TIMES           [ reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .) ]
  ! DIV             [ reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .) ]
  ! MOD             [ reduce using rule 48 (expr -> expr RSHIFT_LOGICAL expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! LSHIFT          [ shift and go to state 41 ]
  ! RSHIFT          [ shift and go to state 42 ]
  ! LSHIFT_LOGICAL  [ shift and go to state 43 ]
  ! RSHIFT_LOGICAL  [ shift and go to state 44 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 87

    (49) expr -> expr GREATER expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 49 (expr -> expr GREATER expr .)
    PLUS_EQUAL      reduce using rule 49 (expr -> expr GREATER expr .)
    OR_EQUAL        reduce using rule 49 (expr -> expr GREATER expr .)
    QUEST           reduce using rule 49 (expr -> expr GREATER expr .)
    BITWISE_AND     reduce using rule 49 (expr -> expr GREATER expr .)
    BITWISE_OR      reduce using rule 49 (expr -> expr GREATER expr .)
    OP              reduce using rule 49 (expr -> expr GREATER expr .)
    AND             reduce using rule 49 (expr -> expr GREATER expr .)
    OR              reduce using rule 49 (expr -> expr GREATER expr .)
    GREATER         reduce using rule 49 (expr -> expr GREATER expr .)
    LESS            reduce using rule 49 (expr -> expr GREATER expr .)
    LESS_EQUAL      reduce using rule 49 (expr -> expr GREATER expr .)
    GREATER_EQUAL   reduce using rule 49 (expr -> expr GREATER expr .)
    EQUAL           reduce using rule 49 (expr -> expr GREATER expr .)
    NOT_EQUAL       reduce using rule 49 (expr -> expr GREATER expr .)
    XOR             reduce using rule 49 (expr -> expr GREATER expr .)
    DEFINE          reduce using rule 49 (expr -> expr GREATER expr .)
    BREAK           reduce using rule 49 (expr -> expr GREATER expr .)
    CASE            reduce using rule 49 (expr -> expr GREATER expr .)
    RETURN          reduce using rule 49 (expr -> expr GREATER expr .)
    DO              reduce using rule 49 (expr -> expr GREATER expr .)
    FOR             reduce using rule 49 (expr -> expr GREATER expr .)
    IF              reduce using rule 49 (expr -> expr GREATER expr .)
    PSEUDO          reduce using rule 49 (expr -> expr GREATER expr .)
    ID              reduce using rule 49 (expr -> expr GREATER expr .)
    NOT             reduce using rule 49 (expr -> expr GREATER expr .)
    BITWISE_NOT     reduce using rule 49 (expr -> expr GREATER expr .)
    LPAREN          reduce using rule 49 (expr -> expr GREATER expr .)
    NUMBER          reduce using rule 49 (expr -> expr GREATER expr .)
    $end            reduce using rule 49 (expr -> expr GREATER expr .)
    RPAREN          reduce using rule 49 (expr -> expr GREATER expr .)
    OF              reduce using rule 49 (expr -> expr GREATER expr .)
    FI              reduce using rule 49 (expr -> expr GREATER expr .)
    ELSE            reduce using rule 49 (expr -> expr GREATER expr .)
    OD              reduce using rule 49 (expr -> expr GREATER expr .)
    ESAC            reduce using rule 49 (expr -> expr GREATER expr .)
    CASE_HEADER     reduce using rule 49 (expr -> expr GREATER expr .)
    RBRACKET        reduce using rule 49 (expr -> expr GREATER expr .)
    ENDFOR          reduce using rule 49 (expr -> expr GREATER expr .)
    THEN            reduce using rule 49 (expr -> expr GREATER expr .)
    COMMA           reduce using rule 49 (expr -> expr GREATER expr .)
    RBRACE          reduce using rule 49 (expr -> expr GREATER expr .)
    COLON           reduce using rule 49 (expr -> expr GREATER expr .)
    TO              reduce using rule 49 (expr -> expr GREATER expr .)
    DOWNTO          reduce using rule 49 (expr -> expr GREATER expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44

  ! DOT             [ reduce using rule 49 (expr -> expr GREATER expr .) ]
  ! LBRACE          [ reduce using rule 49 (expr -> expr GREATER expr .) ]
  ! PLUS            [ reduce using rule 49 (expr -> expr GREATER expr .) ]
  ! MINUS           [ reduce using rule 49 (expr -> expr GREATER expr .) ]
  ! TIMES           [ reduce using rule 49 (expr -> expr GREATER expr .) ]
  ! DIV             [ reduce using rule 49 (expr -> expr GREATER expr .) ]
  ! MOD             [ reduce using rule 49 (expr -> expr GREATER expr .) ]
  ! LSHIFT          [ reduce using rule 49 (expr -> expr GREATER expr .) ]
  ! RSHIFT          [ reduce using rule 49 (expr -> expr GREATER expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 49 (expr -> expr GREATER expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 49 (expr -> expr GREATER expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 88

    (50) expr -> expr LESS expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 50 (expr -> expr LESS expr .)
    PLUS_EQUAL      reduce using rule 50 (expr -> expr LESS expr .)
    OR_EQUAL        reduce using rule 50 (expr -> expr LESS expr .)
    QUEST           reduce using rule 50 (expr -> expr LESS expr .)
    BITWISE_AND     reduce using rule 50 (expr -> expr LESS expr .)
    BITWISE_OR      reduce using rule 50 (expr -> expr LESS expr .)
    OP              reduce using rule 50 (expr -> expr LESS expr .)
    AND             reduce using rule 50 (expr -> expr LESS expr .)
    OR              reduce using rule 50 (expr -> expr LESS expr .)
    GREATER         reduce using rule 50 (expr -> expr LESS expr .)
    LESS            reduce using rule 50 (expr -> expr LESS expr .)
    LESS_EQUAL      reduce using rule 50 (expr -> expr LESS expr .)
    GREATER_EQUAL   reduce using rule 50 (expr -> expr LESS expr .)
    EQUAL           reduce using rule 50 (expr -> expr LESS expr .)
    NOT_EQUAL       reduce using rule 50 (expr -> expr LESS expr .)
    XOR             reduce using rule 50 (expr -> expr LESS expr .)
    DEFINE          reduce using rule 50 (expr -> expr LESS expr .)
    BREAK           reduce using rule 50 (expr -> expr LESS expr .)
    CASE            reduce using rule 50 (expr -> expr LESS expr .)
    RETURN          reduce using rule 50 (expr -> expr LESS expr .)
    DO              reduce using rule 50 (expr -> expr LESS expr .)
    FOR             reduce using rule 50 (expr -> expr LESS expr .)
    IF              reduce using rule 50 (expr -> expr LESS expr .)
    PSEUDO          reduce using rule 50 (expr -> expr LESS expr .)
    ID              reduce using rule 50 (expr -> expr LESS expr .)
    NOT             reduce using rule 50 (expr -> expr LESS expr .)
    BITWISE_NOT     reduce using rule 50 (expr -> expr LESS expr .)
    LPAREN          reduce using rule 50 (expr -> expr LESS expr .)
    NUMBER          reduce using rule 50 (expr -> expr LESS expr .)
    $end            reduce using rule 50 (expr -> expr LESS expr .)
    RPAREN          reduce using rule 50 (expr -> expr LESS expr .)
    OF              reduce using rule 50 (expr -> expr LESS expr .)
    FI              reduce using rule 50 (expr -> expr LESS expr .)
    ELSE            reduce using rule 50 (expr -> expr LESS expr .)
    OD              reduce using rule 50 (expr -> expr LESS expr .)
    ESAC            reduce using rule 50 (expr -> expr LESS expr .)
    CASE_HEADER     reduce using rule 50 (expr -> expr LESS expr .)
    RBRACKET        reduce using rule 50 (expr -> expr LESS expr .)
    ENDFOR          reduce using rule 50 (expr -> expr LESS expr .)
    THEN            reduce using rule 50 (expr -> expr LESS expr .)
    COMMA           reduce using rule 50 (expr -> expr LESS expr .)
    RBRACE          reduce using rule 50 (expr -> expr LESS expr .)
    COLON           reduce using rule 50 (expr -> expr LESS expr .)
    TO              reduce using rule 50 (expr -> expr LESS expr .)
    DOWNTO          reduce using rule 50 (expr -> expr LESS expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44

  ! DOT             [ reduce using rule 50 (expr -> expr LESS expr .) ]
  ! LBRACE          [ reduce using rule 50 (expr -> expr LESS expr .) ]
  ! PLUS            [ reduce using rule 50 (expr -> expr LESS expr .) ]
  ! MINUS           [ reduce using rule 50 (expr -> expr LESS expr .) ]
  ! TIMES           [ reduce using rule 50 (expr -> expr LESS expr .) ]
  ! DIV             [ reduce using rule 50 (expr -> expr LESS expr .) ]
  ! MOD             [ reduce using rule 50 (expr -> expr LESS expr .) ]
  ! LSHIFT          [ reduce using rule 50 (expr -> expr LESS expr .) ]
  ! RSHIFT          [ reduce using rule 50 (expr -> expr LESS expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 50 (expr -> expr LESS expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 50 (expr -> expr LESS expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 89

    (51) expr -> expr LESS_EQUAL expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    PLUS_EQUAL      reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    OR_EQUAL        reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    QUEST           reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    BITWISE_AND     reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    BITWISE_OR      reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    OP              reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    AND             reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    OR              reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    GREATER         reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    LESS            reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    LESS_EQUAL      reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    GREATER_EQUAL   reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    EQUAL           reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    NOT_EQUAL       reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    XOR             reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    DEFINE          reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    BREAK           reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    CASE            reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    RETURN          reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    DO              reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    FOR             reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    IF              reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    PSEUDO          reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    ID              reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    NOT             reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    BITWISE_NOT     reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    LPAREN          reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    NUMBER          reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    $end            reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    RPAREN          reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    OF              reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    FI              reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    ELSE            reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    OD              reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    ESAC            reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    CASE_HEADER     reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    RBRACKET        reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    ENDFOR          reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    THEN            reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    COMMA           reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    RBRACE          reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    COLON           reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    TO              reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    DOWNTO          reduce using rule 51 (expr -> expr LESS_EQUAL expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44

  ! DOT             [ reduce using rule 51 (expr -> expr LESS_EQUAL expr .) ]
  ! LBRACE          [ reduce using rule 51 (expr -> expr LESS_EQUAL expr .) ]
  ! PLUS            [ reduce using rule 51 (expr -> expr LESS_EQUAL expr .) ]
  ! MINUS           [ reduce using rule 51 (expr -> expr LESS_EQUAL expr .) ]
  ! TIMES           [ reduce using rule 51 (expr -> expr LESS_EQUAL expr .) ]
  ! DIV             [ reduce using rule 51 (expr -> expr LESS_EQUAL expr .) ]
  ! MOD             [ reduce using rule 51 (expr -> expr LESS_EQUAL expr .) ]
  ! LSHIFT          [ reduce using rule 51 (expr -> expr LESS_EQUAL expr .) ]
  ! RSHIFT          [ reduce using rule 51 (expr -> expr LESS_EQUAL expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 51 (expr -> expr LESS_EQUAL expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 51 (expr -> expr LESS_EQUAL expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 90

    (52) expr -> expr GREATER_EQUAL expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    PLUS_EQUAL      reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    OR_EQUAL        reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    QUEST           reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    BITWISE_AND     reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    BITWISE_OR      reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    OP              reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    AND             reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    OR              reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    GREATER         reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    LESS            reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    LESS_EQUAL      reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    GREATER_EQUAL   reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    EQUAL           reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    NOT_EQUAL       reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    XOR             reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    DEFINE          reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    BREAK           reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    CASE            reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    RETURN          reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    DO              reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    FOR             reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    IF              reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    PSEUDO          reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    ID              reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    NOT             reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    BITWISE_NOT     reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    LPAREN          reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    NUMBER          reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    $end            reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    RPAREN          reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    OF              reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    FI              reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    ELSE            reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    OD              reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    ESAC            reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    CASE_HEADER     reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    RBRACKET        reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    ENDFOR          reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    THEN            reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    COMMA           reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    RBRACE          reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    COLON           reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    TO              reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    DOWNTO          reduce using rule 52 (expr -> expr GREATER_EQUAL expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44

  ! DOT             [ reduce using rule 52 (expr -> expr GREATER_EQUAL expr .) ]
  ! LBRACE          [ reduce using rule 52 (expr -> expr GREATER_EQUAL expr .) ]
  ! PLUS            [ reduce using rule 52 (expr -> expr GREATER_EQUAL expr .) ]
  ! MINUS           [ reduce using rule 52 (expr -> expr GREATER_EQUAL expr .) ]
  ! TIMES           [ reduce using rule 52 (expr -> expr GREATER_EQUAL expr .) ]
  ! DIV             [ reduce using rule 52 (expr -> expr GREATER_EQUAL expr .) ]
  ! MOD             [ reduce using rule 52 (expr -> expr GREATER_EQUAL expr .) ]
  ! LSHIFT          [ reduce using rule 52 (expr -> expr GREATER_EQUAL expr .) ]
  ! RSHIFT          [ reduce using rule 52 (expr -> expr GREATER_EQUAL expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 52 (expr -> expr GREATER_EQUAL expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 52 (expr -> expr GREATER_EQUAL expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 91

    (53) expr -> expr EQUAL expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 53 (expr -> expr EQUAL expr .)
    PLUS_EQUAL      reduce using rule 53 (expr -> expr EQUAL expr .)
    OR_EQUAL        reduce using rule 53 (expr -> expr EQUAL expr .)
    QUEST           reduce using rule 53 (expr -> expr EQUAL expr .)
    BITWISE_AND     reduce using rule 53 (expr -> expr EQUAL expr .)
    BITWISE_OR      reduce using rule 53 (expr -> expr EQUAL expr .)
    OP              reduce using rule 53 (expr -> expr EQUAL expr .)
    AND             reduce using rule 53 (expr -> expr EQUAL expr .)
    OR              reduce using rule 53 (expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 53 (expr -> expr EQUAL expr .)
    NOT_EQUAL       reduce using rule 53 (expr -> expr EQUAL expr .)
    XOR             reduce using rule 53 (expr -> expr EQUAL expr .)
    DEFINE          reduce using rule 53 (expr -> expr EQUAL expr .)
    BREAK           reduce using rule 53 (expr -> expr EQUAL expr .)
    CASE            reduce using rule 53 (expr -> expr EQUAL expr .)
    RETURN          reduce using rule 53 (expr -> expr EQUAL expr .)
    DO              reduce using rule 53 (expr -> expr EQUAL expr .)
    FOR             reduce using rule 53 (expr -> expr EQUAL expr .)
    IF              reduce using rule 53 (expr -> expr EQUAL expr .)
    PSEUDO          reduce using rule 53 (expr -> expr EQUAL expr .)
    ID              reduce using rule 53 (expr -> expr EQUAL expr .)
    NOT             reduce using rule 53 (expr -> expr EQUAL expr .)
    BITWISE_NOT     reduce using rule 53 (expr -> expr EQUAL expr .)
    LPAREN          reduce using rule 53 (expr -> expr EQUAL expr .)
    NUMBER          reduce using rule 53 (expr -> expr EQUAL expr .)
    $end            reduce using rule 53 (expr -> expr EQUAL expr .)
    RPAREN          reduce using rule 53 (expr -> expr EQUAL expr .)
    OF              reduce using rule 53 (expr -> expr EQUAL expr .)
    FI              reduce using rule 53 (expr -> expr EQUAL expr .)
    ELSE            reduce using rule 53 (expr -> expr EQUAL expr .)
    OD              reduce using rule 53 (expr -> expr EQUAL expr .)
    ESAC            reduce using rule 53 (expr -> expr EQUAL expr .)
    CASE_HEADER     reduce using rule 53 (expr -> expr EQUAL expr .)
    RBRACKET        reduce using rule 53 (expr -> expr EQUAL expr .)
    ENDFOR          reduce using rule 53 (expr -> expr EQUAL expr .)
    THEN            reduce using rule 53 (expr -> expr EQUAL expr .)
    COMMA           reduce using rule 53 (expr -> expr EQUAL expr .)
    RBRACE          reduce using rule 53 (expr -> expr EQUAL expr .)
    COLON           reduce using rule 53 (expr -> expr EQUAL expr .)
    TO              reduce using rule 53 (expr -> expr EQUAL expr .)
    DOWNTO          reduce using rule 53 (expr -> expr EQUAL expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48

  ! DOT             [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! LBRACE          [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! PLUS            [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! MINUS           [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! TIMES           [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! DIV             [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! MOD             [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! LSHIFT          [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! RSHIFT          [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! GREATER         [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! LESS            [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! LESS_EQUAL      [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 53 (expr -> expr EQUAL expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 92

    (54) expr -> expr NOT_EQUAL expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    PLUS_EQUAL      reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    OR_EQUAL        reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    QUEST           reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    BITWISE_AND     reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    BITWISE_OR      reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    OP              reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    AND             reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    OR              reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    EQUAL           reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    NOT_EQUAL       reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    XOR             reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    DEFINE          reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    BREAK           reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    CASE            reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    RETURN          reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    DO              reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    FOR             reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    IF              reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    PSEUDO          reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    ID              reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    NOT             reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    BITWISE_NOT     reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    LPAREN          reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    NUMBER          reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    $end            reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    RPAREN          reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    OF              reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    FI              reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    ELSE            reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    OD              reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    ESAC            reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    CASE_HEADER     reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    RBRACKET        reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    ENDFOR          reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    THEN            reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    COMMA           reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    RBRACE          reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    COLON           reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    TO              reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    DOWNTO          reduce using rule 54 (expr -> expr NOT_EQUAL expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48

  ! DOT             [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! LBRACE          [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! PLUS            [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! MINUS           [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! TIMES           [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! DIV             [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! MOD             [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! LSHIFT          [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! RSHIFT          [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! GREATER         [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! LESS            [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! LESS_EQUAL      [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 54 (expr -> expr NOT_EQUAL expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 93

    (55) expr -> expr XOR expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    UPDATE          reduce using rule 55 (expr -> expr XOR expr .)
    PLUS_EQUAL      reduce using rule 55 (expr -> expr XOR expr .)
    OR_EQUAL        reduce using rule 55 (expr -> expr XOR expr .)
    QUEST           reduce using rule 55 (expr -> expr XOR expr .)
    BITWISE_AND     reduce using rule 55 (expr -> expr XOR expr .)
    BITWISE_OR      reduce using rule 55 (expr -> expr XOR expr .)
    OP              reduce using rule 55 (expr -> expr XOR expr .)
    AND             reduce using rule 55 (expr -> expr XOR expr .)
    OR              reduce using rule 55 (expr -> expr XOR expr .)
    XOR             reduce using rule 55 (expr -> expr XOR expr .)
    DEFINE          reduce using rule 55 (expr -> expr XOR expr .)
    BREAK           reduce using rule 55 (expr -> expr XOR expr .)
    CASE            reduce using rule 55 (expr -> expr XOR expr .)
    RETURN          reduce using rule 55 (expr -> expr XOR expr .)
    DO              reduce using rule 55 (expr -> expr XOR expr .)
    FOR             reduce using rule 55 (expr -> expr XOR expr .)
    IF              reduce using rule 55 (expr -> expr XOR expr .)
    PSEUDO          reduce using rule 55 (expr -> expr XOR expr .)
    ID              reduce using rule 55 (expr -> expr XOR expr .)
    NOT             reduce using rule 55 (expr -> expr XOR expr .)
    BITWISE_NOT     reduce using rule 55 (expr -> expr XOR expr .)
    LPAREN          reduce using rule 55 (expr -> expr XOR expr .)
    NUMBER          reduce using rule 55 (expr -> expr XOR expr .)
    $end            reduce using rule 55 (expr -> expr XOR expr .)
    RPAREN          reduce using rule 55 (expr -> expr XOR expr .)
    OF              reduce using rule 55 (expr -> expr XOR expr .)
    FI              reduce using rule 55 (expr -> expr XOR expr .)
    ELSE            reduce using rule 55 (expr -> expr XOR expr .)
    OD              reduce using rule 55 (expr -> expr XOR expr .)
    ESAC            reduce using rule 55 (expr -> expr XOR expr .)
    CASE_HEADER     reduce using rule 55 (expr -> expr XOR expr .)
    RBRACKET        reduce using rule 55 (expr -> expr XOR expr .)
    ENDFOR          reduce using rule 55 (expr -> expr XOR expr .)
    THEN            reduce using rule 55 (expr -> expr XOR expr .)
    COMMA           reduce using rule 55 (expr -> expr XOR expr .)
    RBRACE          reduce using rule 55 (expr -> expr XOR expr .)
    COLON           reduce using rule 55 (expr -> expr XOR expr .)
    TO              reduce using rule 55 (expr -> expr XOR expr .)
    DOWNTO          reduce using rule 55 (expr -> expr XOR expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50

  ! DOT             [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! LBRACE          [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! PLUS            [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! MINUS           [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! TIMES           [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! DIV             [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! MOD             [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! LSHIFT          [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! RSHIFT          [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! GREATER         [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! LESS            [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! LESS_EQUAL      [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! EQUAL           [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! NOT_EQUAL       [ reduce using rule 55 (expr -> expr XOR expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! XOR             [ shift and go to state 51 ]


state 94

    (6) stmt -> CASE expr OF . cases ESAC
    (7) cases -> . CASE_HEADER stmts
    (8) cases -> . cases CASE_HEADER stmts

    CASE_HEADER     shift and go to state 110

    cases                          shift and go to state 109

state 95

    (14) stmt -> DO WHILE expr . stmts OD
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr
    (1) stmts -> . stmt
    (2) stmts -> . stmts stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 99
    PLUS            shift and go to state 34
    MINUS           shift and go to state 100
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    ID              shift and go to state 4
    NOT             shift and go to state 15
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    expr                           shift and go to state 7
    stmts                          shift and go to state 111
    stmt                           shift and go to state 2

state 96

    (15) stmt -> FOR ID UPDATE . expr TO expr stmts ENDFOR
    (16) stmt -> FOR ID UPDATE . expr DOWNTO expr stmts ENDFOR
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 112

state 97

    (17) stmt -> IF expr THEN . stmts FI
    (18) stmt -> IF expr THEN . stmts ELSE stmts FI
    (1) stmts -> . stmt
    (2) stmts -> . stmts stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    expr                           shift and go to state 7
    stmts                          shift and go to state 113
    stmt                           shift and go to state 2

state 98

    (19) stmt -> IF expr stmts . FI
    (20) stmt -> IF expr stmts . ELSE stmts FI
    (21) stmt -> IF expr stmts . ELSE stmts
    (2) stmts -> stmts . stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    FI              shift and go to state 114
    ELSE            shift and go to state 115
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    expr                           shift and go to state 7
    stmt                           shift and go to state 19

state 99

    (37) expr -> expr OP . expr
    (11) expr -> OP . UPDATE ID
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    UPDATE          shift and go to state 57
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 75

state 100

    (39) expr -> expr MINUS . expr
    (33) expr -> MINUS . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 116

state 101

    (11) expr -> OP UPDATE ID .

    UPDATE          reduce using rule 11 (expr -> OP UPDATE ID .)
    PLUS_EQUAL      reduce using rule 11 (expr -> OP UPDATE ID .)
    OR_EQUAL        reduce using rule 11 (expr -> OP UPDATE ID .)
    DOT             reduce using rule 11 (expr -> OP UPDATE ID .)
    LBRACE          reduce using rule 11 (expr -> OP UPDATE ID .)
    QUEST           reduce using rule 11 (expr -> OP UPDATE ID .)
    BITWISE_AND     reduce using rule 11 (expr -> OP UPDATE ID .)
    BITWISE_OR      reduce using rule 11 (expr -> OP UPDATE ID .)
    OP              reduce using rule 11 (expr -> OP UPDATE ID .)
    PLUS            reduce using rule 11 (expr -> OP UPDATE ID .)
    MINUS           reduce using rule 11 (expr -> OP UPDATE ID .)
    TIMES           reduce using rule 11 (expr -> OP UPDATE ID .)
    DIV             reduce using rule 11 (expr -> OP UPDATE ID .)
    MOD             reduce using rule 11 (expr -> OP UPDATE ID .)
    AND             reduce using rule 11 (expr -> OP UPDATE ID .)
    OR              reduce using rule 11 (expr -> OP UPDATE ID .)
    LSHIFT          reduce using rule 11 (expr -> OP UPDATE ID .)
    RSHIFT          reduce using rule 11 (expr -> OP UPDATE ID .)
    LSHIFT_LOGICAL  reduce using rule 11 (expr -> OP UPDATE ID .)
    RSHIFT_LOGICAL  reduce using rule 11 (expr -> OP UPDATE ID .)
    GREATER         reduce using rule 11 (expr -> OP UPDATE ID .)
    LESS            reduce using rule 11 (expr -> OP UPDATE ID .)
    LESS_EQUAL      reduce using rule 11 (expr -> OP UPDATE ID .)
    GREATER_EQUAL   reduce using rule 11 (expr -> OP UPDATE ID .)
    EQUAL           reduce using rule 11 (expr -> OP UPDATE ID .)
    NOT_EQUAL       reduce using rule 11 (expr -> OP UPDATE ID .)
    XOR             reduce using rule 11 (expr -> OP UPDATE ID .)
    DEFINE          reduce using rule 11 (expr -> OP UPDATE ID .)
    BREAK           reduce using rule 11 (expr -> OP UPDATE ID .)
    CASE            reduce using rule 11 (expr -> OP UPDATE ID .)
    RETURN          reduce using rule 11 (expr -> OP UPDATE ID .)
    DO              reduce using rule 11 (expr -> OP UPDATE ID .)
    FOR             reduce using rule 11 (expr -> OP UPDATE ID .)
    IF              reduce using rule 11 (expr -> OP UPDATE ID .)
    PSEUDO          reduce using rule 11 (expr -> OP UPDATE ID .)
    ID              reduce using rule 11 (expr -> OP UPDATE ID .)
    NOT             reduce using rule 11 (expr -> OP UPDATE ID .)
    BITWISE_NOT     reduce using rule 11 (expr -> OP UPDATE ID .)
    LPAREN          reduce using rule 11 (expr -> OP UPDATE ID .)
    NUMBER          reduce using rule 11 (expr -> OP UPDATE ID .)
    $end            reduce using rule 11 (expr -> OP UPDATE ID .)
    RPAREN          reduce using rule 11 (expr -> OP UPDATE ID .)
    OF              reduce using rule 11 (expr -> OP UPDATE ID .)
    FI              reduce using rule 11 (expr -> OP UPDATE ID .)
    ELSE            reduce using rule 11 (expr -> OP UPDATE ID .)
    OD              reduce using rule 11 (expr -> OP UPDATE ID .)
    ESAC            reduce using rule 11 (expr -> OP UPDATE ID .)
    CASE_HEADER     reduce using rule 11 (expr -> OP UPDATE ID .)
    RBRACKET        reduce using rule 11 (expr -> OP UPDATE ID .)
    ENDFOR          reduce using rule 11 (expr -> OP UPDATE ID .)
    THEN            reduce using rule 11 (expr -> OP UPDATE ID .)
    COMMA           reduce using rule 11 (expr -> OP UPDATE ID .)
    RBRACE          reduce using rule 11 (expr -> OP UPDATE ID .)
    COLON           reduce using rule 11 (expr -> OP UPDATE ID .)
    TO              reduce using rule 11 (expr -> OP UPDATE ID .)
    DOWNTO          reduce using rule 11 (expr -> OP UPDATE ID .)


state 102

    (3) stmt -> DEFINE ID LPAREN args . RPAREN LBRACKET stmts RBRACKET
    (28) args -> args . COMMA expr

    RPAREN          shift and go to state 117
    COMMA           shift and go to state 104


state 103

    (23) expr -> ID LPAREN args RPAREN .

    UPDATE          reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    PLUS_EQUAL      reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    OR_EQUAL        reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    DOT             reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    LBRACE          reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    QUEST           reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    BITWISE_AND     reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    BITWISE_OR      reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    OP              reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    PLUS            reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    MINUS           reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    TIMES           reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    DIV             reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    MOD             reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    AND             reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    OR              reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    LSHIFT          reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    RSHIFT          reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    LSHIFT_LOGICAL  reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    RSHIFT_LOGICAL  reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    GREATER         reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    LESS            reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    LESS_EQUAL      reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    GREATER_EQUAL   reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    EQUAL           reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    NOT_EQUAL       reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    XOR             reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    DEFINE          reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    BREAK           reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    CASE            reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    RETURN          reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    DO              reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    FOR             reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    IF              reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    PSEUDO          reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    ID              reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    NOT             reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    BITWISE_NOT     reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    LPAREN          reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    NUMBER          reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    $end            reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    RPAREN          reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    OF              reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    FI              reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    ELSE            reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    OD              reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    ESAC            reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    CASE_HEADER     reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    RBRACKET        reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    ENDFOR          reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    THEN            reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    COMMA           reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    RBRACE          reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    COLON           reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    TO              reduce using rule 23 (expr -> ID LPAREN args RPAREN .)
    DOWNTO          reduce using rule 23 (expr -> ID LPAREN args RPAREN .)


state 104

    (28) args -> args COMMA . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 118

state 105

    (25) expr -> ID LBRACKET expr RBRACKET .

    UPDATE          reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    PLUS_EQUAL      reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    OR_EQUAL        reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    DOT             reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    LBRACE          reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    QUEST           reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    BITWISE_AND     reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    BITWISE_OR      reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    OP              reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    DIV             reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    MOD             reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    AND             reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    OR              reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    LSHIFT          reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    RSHIFT          reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    LSHIFT_LOGICAL  reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    RSHIFT_LOGICAL  reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    GREATER         reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    LESS            reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    LESS_EQUAL      reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    GREATER_EQUAL   reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    EQUAL           reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    NOT_EQUAL       reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    XOR             reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    DEFINE          reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    BREAK           reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    CASE            reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    RETURN          reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    DO              reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    FOR             reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    IF              reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    PSEUDO          reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    ID              reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    NOT             reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    BITWISE_NOT     reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    LPAREN          reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    NUMBER          reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    $end            reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    OF              reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    FI              reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    ELSE            reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    OD              reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    ESAC            reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    CASE_HEADER     reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    ENDFOR          reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    THEN            reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    RBRACE          reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    COLON           reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    TO              reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)
    DOWNTO          reduce using rule 25 (expr -> ID LBRACKET expr RBRACKET .)


state 106

    (29) expr -> expr LBRACE expr RBRACE .

    UPDATE          reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    PLUS_EQUAL      reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    OR_EQUAL        reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    DOT             reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    LBRACE          reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    QUEST           reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    BITWISE_AND     reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    BITWISE_OR      reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    OP              reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    PLUS            reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    MINUS           reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    TIMES           reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    DIV             reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    MOD             reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    AND             reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    OR              reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    LSHIFT          reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    RSHIFT          reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    LSHIFT_LOGICAL  reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    RSHIFT_LOGICAL  reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    GREATER         reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    LESS            reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    LESS_EQUAL      reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    GREATER_EQUAL   reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    EQUAL           reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    NOT_EQUAL       reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    XOR             reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    DEFINE          reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    BREAK           reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    CASE            reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    RETURN          reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    DO              reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    FOR             reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    IF              reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    PSEUDO          reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    ID              reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    NOT             reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    BITWISE_NOT     reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    LPAREN          reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    NUMBER          reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    $end            reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    RPAREN          reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    OF              reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    FI              reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    ELSE            reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    OD              reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    ESAC            reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    CASE_HEADER     reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    RBRACKET        reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    ENDFOR          reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    THEN            reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    COMMA           reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    RBRACE          reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    COLON           reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    TO              reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)
    DOWNTO          reduce using rule 29 (expr -> expr LBRACE expr RBRACE .)


state 107

    (30) expr -> expr LBRACE expr COLON . expr RBRACE
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 119

state 108

    (31) expr -> expr QUEST expr COLON . expr
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 120

state 109

    (6) stmt -> CASE expr OF cases . ESAC
    (8) cases -> cases . CASE_HEADER stmts

    ESAC            shift and go to state 121
    CASE_HEADER     shift and go to state 122


state 110

    (7) cases -> CASE_HEADER . stmts
    (1) stmts -> . stmt
    (2) stmts -> . stmts stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    stmts                          shift and go to state 123
    stmt                           shift and go to state 2
    expr                           shift and go to state 7

state 111

    (14) stmt -> DO WHILE expr stmts . OD
    (2) stmts -> stmts . stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OD              shift and go to state 124
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    expr                           shift and go to state 7
    stmt                           shift and go to state 19

state 112

    (15) stmt -> FOR ID UPDATE expr . TO expr stmts ENDFOR
    (16) stmt -> FOR ID UPDATE expr . DOWNTO expr stmts ENDFOR
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    TO              shift and go to state 125
    DOWNTO          shift and go to state 126
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51


state 113

    (17) stmt -> IF expr THEN stmts . FI
    (18) stmt -> IF expr THEN stmts . ELSE stmts FI
    (2) stmts -> stmts . stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    FI              shift and go to state 127
    ELSE            shift and go to state 128
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    expr                           shift and go to state 7
    stmt                           shift and go to state 19

state 114

    (19) stmt -> IF expr stmts FI .

    DEFINE          reduce using rule 19 (stmt -> IF expr stmts FI .)
    BREAK           reduce using rule 19 (stmt -> IF expr stmts FI .)
    CASE            reduce using rule 19 (stmt -> IF expr stmts FI .)
    RETURN          reduce using rule 19 (stmt -> IF expr stmts FI .)
    DO              reduce using rule 19 (stmt -> IF expr stmts FI .)
    FOR             reduce using rule 19 (stmt -> IF expr stmts FI .)
    IF              reduce using rule 19 (stmt -> IF expr stmts FI .)
    PSEUDO          reduce using rule 19 (stmt -> IF expr stmts FI .)
    OP              reduce using rule 19 (stmt -> IF expr stmts FI .)
    ID              reduce using rule 19 (stmt -> IF expr stmts FI .)
    NOT             reduce using rule 19 (stmt -> IF expr stmts FI .)
    MINUS           reduce using rule 19 (stmt -> IF expr stmts FI .)
    BITWISE_NOT     reduce using rule 19 (stmt -> IF expr stmts FI .)
    LPAREN          reduce using rule 19 (stmt -> IF expr stmts FI .)
    NUMBER          reduce using rule 19 (stmt -> IF expr stmts FI .)
    $end            reduce using rule 19 (stmt -> IF expr stmts FI .)
    FI              reduce using rule 19 (stmt -> IF expr stmts FI .)
    ELSE            reduce using rule 19 (stmt -> IF expr stmts FI .)
    OD              reduce using rule 19 (stmt -> IF expr stmts FI .)
    ESAC            reduce using rule 19 (stmt -> IF expr stmts FI .)
    CASE_HEADER     reduce using rule 19 (stmt -> IF expr stmts FI .)
    RBRACKET        reduce using rule 19 (stmt -> IF expr stmts FI .)
    ENDFOR          reduce using rule 19 (stmt -> IF expr stmts FI .)


state 115

    (20) stmt -> IF expr stmts ELSE . stmts FI
    (21) stmt -> IF expr stmts ELSE . stmts
    (1) stmts -> . stmt
    (2) stmts -> . stmts stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    expr                           shift and go to state 7
    stmts                          shift and go to state 129
    stmt                           shift and go to state 2

state 116

    (39) expr -> expr MINUS expr .
    (33) expr -> MINUS expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

  ! reduce/reduce conflict for UPDATE resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for PLUS_EQUAL resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for OR_EQUAL resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for DOT resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for LBRACE resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for QUEST resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for BITWISE_AND resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for BITWISE_OR resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for OP resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for PLUS resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for MINUS resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for TIMES resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for DIV resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for MOD resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for AND resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for OR resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for LSHIFT resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for RSHIFT resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for LSHIFT_LOGICAL resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for RSHIFT_LOGICAL resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for GREATER resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for LESS resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for EQUAL resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for XOR resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for DEFINE resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for BREAK resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for CASE resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for RETURN resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for DO resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for FOR resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for IF resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for PSEUDO resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for ID resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for NOT resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for BITWISE_NOT resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for LPAREN resolved using rule 33 (expr -> MINUS expr .)
  ! reduce/reduce conflict for NUMBER resolved using rule 33 (expr -> MINUS expr .)
    THEN            reduce using rule 39 (expr -> expr MINUS expr .)
    UPDATE          reduce using rule 33 (expr -> MINUS expr .)
    PLUS_EQUAL      reduce using rule 33 (expr -> MINUS expr .)
    OR_EQUAL        reduce using rule 33 (expr -> MINUS expr .)
    QUEST           reduce using rule 33 (expr -> MINUS expr .)
    BITWISE_AND     reduce using rule 33 (expr -> MINUS expr .)
    BITWISE_OR      reduce using rule 33 (expr -> MINUS expr .)
    OP              reduce using rule 33 (expr -> MINUS expr .)
    PLUS            reduce using rule 33 (expr -> MINUS expr .)
    MINUS           reduce using rule 33 (expr -> MINUS expr .)
    TIMES           reduce using rule 33 (expr -> MINUS expr .)
    DIV             reduce using rule 33 (expr -> MINUS expr .)
    MOD             reduce using rule 33 (expr -> MINUS expr .)
    AND             reduce using rule 33 (expr -> MINUS expr .)
    OR              reduce using rule 33 (expr -> MINUS expr .)
    LSHIFT          reduce using rule 33 (expr -> MINUS expr .)
    RSHIFT          reduce using rule 33 (expr -> MINUS expr .)
    LSHIFT_LOGICAL  reduce using rule 33 (expr -> MINUS expr .)
    RSHIFT_LOGICAL  reduce using rule 33 (expr -> MINUS expr .)
    GREATER         reduce using rule 33 (expr -> MINUS expr .)
    LESS            reduce using rule 33 (expr -> MINUS expr .)
    LESS_EQUAL      reduce using rule 33 (expr -> MINUS expr .)
    GREATER_EQUAL   reduce using rule 33 (expr -> MINUS expr .)
    EQUAL           reduce using rule 33 (expr -> MINUS expr .)
    NOT_EQUAL       reduce using rule 33 (expr -> MINUS expr .)
    XOR             reduce using rule 33 (expr -> MINUS expr .)
    FI              reduce using rule 33 (expr -> MINUS expr .)
    ELSE            reduce using rule 33 (expr -> MINUS expr .)
    DEFINE          reduce using rule 33 (expr -> MINUS expr .)
    BREAK           reduce using rule 33 (expr -> MINUS expr .)
    CASE            reduce using rule 33 (expr -> MINUS expr .)
    RETURN          reduce using rule 33 (expr -> MINUS expr .)
    DO              reduce using rule 33 (expr -> MINUS expr .)
    FOR             reduce using rule 33 (expr -> MINUS expr .)
    IF              reduce using rule 33 (expr -> MINUS expr .)
    PSEUDO          reduce using rule 33 (expr -> MINUS expr .)
    ID              reduce using rule 33 (expr -> MINUS expr .)
    NOT             reduce using rule 33 (expr -> MINUS expr .)
    BITWISE_NOT     reduce using rule 33 (expr -> MINUS expr .)
    LPAREN          reduce using rule 33 (expr -> MINUS expr .)
    NUMBER          reduce using rule 33 (expr -> MINUS expr .)
    OD              reduce using rule 33 (expr -> MINUS expr .)
    ENDFOR          reduce using rule 33 (expr -> MINUS expr .)
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29

  ! UPDATE          [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! PLUS_EQUAL      [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! OR_EQUAL        [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! DOT             [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! LBRACE          [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! QUEST           [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! BITWISE_AND     [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! BITWISE_OR      [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! OP              [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! PLUS            [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! MINUS           [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! TIMES           [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! DIV             [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! AND             [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! OR              [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! LSHIFT          [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! RSHIFT          [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! GREATER         [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! LESS            [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! LESS_EQUAL      [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! EQUAL           [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! NOT_EQUAL       [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! XOR             [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! DEFINE          [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! BREAK           [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! CASE            [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! RETURN          [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! DO              [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! FOR             [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! IF              [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! PSEUDO          [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! ID              [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! NOT             [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! BITWISE_NOT     [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! LPAREN          [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! NUMBER          [ reduce using rule 39 (expr -> expr MINUS expr .) ]
  ! DOT             [ reduce using rule 33 (expr -> MINUS expr .) ]
  ! LBRACE          [ reduce using rule 33 (expr -> MINUS expr .) ]
  ! UPDATE          [ shift and go to state 25 ]
  ! PLUS_EQUAL      [ shift and go to state 26 ]
  ! OR_EQUAL        [ shift and go to state 27 ]
  ! QUEST           [ shift and go to state 30 ]
  ! BITWISE_AND     [ shift and go to state 31 ]
  ! BITWISE_OR      [ shift and go to state 32 ]
  ! OP              [ shift and go to state 33 ]
  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! TIMES           [ shift and go to state 36 ]
  ! DIV             [ shift and go to state 37 ]
  ! MOD             [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]
  ! LSHIFT          [ shift and go to state 41 ]
  ! RSHIFT          [ shift and go to state 42 ]
  ! LSHIFT_LOGICAL  [ shift and go to state 43 ]
  ! RSHIFT_LOGICAL  [ shift and go to state 44 ]
  ! GREATER         [ shift and go to state 45 ]
  ! LESS            [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 47 ]
  ! GREATER_EQUAL   [ shift and go to state 48 ]
  ! EQUAL           [ shift and go to state 49 ]
  ! NOT_EQUAL       [ shift and go to state 50 ]
  ! XOR             [ shift and go to state 51 ]


state 117

    (3) stmt -> DEFINE ID LPAREN args RPAREN . LBRACKET stmts RBRACKET

    LBRACKET        shift and go to state 130


state 118

    (28) args -> args COMMA expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    RPAREN          reduce using rule 28 (args -> args COMMA expr .)
    COMMA           reduce using rule 28 (args -> args COMMA expr .)
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51


state 119

    (30) expr -> expr LBRACE expr COLON expr . RBRACE
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

    RBRACE          shift and go to state 131
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51


state 120

    (31) expr -> expr QUEST expr COLON expr .
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr

  ! shift/reduce conflict for UPDATE resolved as shift
  ! shift/reduce conflict for PLUS_EQUAL resolved as shift
  ! shift/reduce conflict for OR_EQUAL resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for QUEST resolved as shift
  ! shift/reduce conflict for BITWISE_AND resolved as shift
  ! shift/reduce conflict for BITWISE_OR resolved as shift
  ! shift/reduce conflict for OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT_LOGICAL resolved as shift
  ! shift/reduce conflict for RSHIFT_LOGICAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
    DEFINE          reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    BREAK           reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    CASE            reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    RETURN          reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    DO              reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    FOR             reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    IF              reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    PSEUDO          reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    ID              reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    NOT             reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    BITWISE_NOT     reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    LPAREN          reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    NUMBER          reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    $end            reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    RPAREN          reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    OF              reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    FI              reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    ELSE            reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    OD              reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    ESAC            reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    CASE_HEADER     reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    RBRACKET        reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    ENDFOR          reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    THEN            reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    COMMA           reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    RBRACE          reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    COLON           reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    TO              reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    DOWNTO          reduce using rule 31 (expr -> expr QUEST expr COLON expr .)
    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 33
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51

  ! UPDATE          [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! PLUS_EQUAL      [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! OR_EQUAL        [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! DOT             [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! LBRACE          [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! QUEST           [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! BITWISE_AND     [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! BITWISE_OR      [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! OP              [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! PLUS            [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! MINUS           [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! TIMES           [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! DIV             [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! MOD             [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! AND             [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! OR              [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! LSHIFT          [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! RSHIFT          [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! LSHIFT_LOGICAL  [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! RSHIFT_LOGICAL  [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! GREATER         [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! LESS            [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! LESS_EQUAL      [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! EQUAL           [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! NOT_EQUAL       [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]
  ! XOR             [ reduce using rule 31 (expr -> expr QUEST expr COLON expr .) ]


state 121

    (6) stmt -> CASE expr OF cases ESAC .

    DEFINE          reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    BREAK           reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    CASE            reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    RETURN          reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    DO              reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    FOR             reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    IF              reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    PSEUDO          reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    OP              reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    ID              reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    NOT             reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    MINUS           reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    BITWISE_NOT     reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    LPAREN          reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    NUMBER          reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    $end            reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    FI              reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    ELSE            reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    OD              reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    ESAC            reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    CASE_HEADER     reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    RBRACKET        reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)
    ENDFOR          reduce using rule 6 (stmt -> CASE expr OF cases ESAC .)


state 122

    (8) cases -> cases CASE_HEADER . stmts
    (1) stmts -> . stmt
    (2) stmts -> . stmts stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    stmts                          shift and go to state 132
    stmt                           shift and go to state 2
    expr                           shift and go to state 7

state 123

    (7) cases -> CASE_HEADER stmts .
    (2) stmts -> stmts . stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    ESAC            reduce using rule 7 (cases -> CASE_HEADER stmts .)
    CASE_HEADER     reduce using rule 7 (cases -> CASE_HEADER stmts .)
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    stmt                           shift and go to state 19
    expr                           shift and go to state 7

state 124

    (14) stmt -> DO WHILE expr stmts OD .

    DEFINE          reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    BREAK           reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    CASE            reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    RETURN          reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    DO              reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    FOR             reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    IF              reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    PSEUDO          reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    OP              reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    ID              reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    NOT             reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    MINUS           reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    BITWISE_NOT     reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    LPAREN          reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    NUMBER          reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    $end            reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    FI              reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    ELSE            reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    OD              reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    ESAC            reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    CASE_HEADER     reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    RBRACKET        reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)
    ENDFOR          reduce using rule 14 (stmt -> DO WHILE expr stmts OD .)


state 125

    (15) stmt -> FOR ID UPDATE expr TO . expr stmts ENDFOR
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 133

state 126

    (16) stmt -> FOR ID UPDATE expr DOWNTO . expr stmts ENDFOR
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18
    PSEUDO          shift and go to state 24

    expr                           shift and go to state 134

state 127

    (17) stmt -> IF expr THEN stmts FI .

    DEFINE          reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    BREAK           reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    CASE            reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    RETURN          reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    DO              reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    FOR             reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    IF              reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    PSEUDO          reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    OP              reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    ID              reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    NOT             reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    MINUS           reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    BITWISE_NOT     reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    LPAREN          reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    NUMBER          reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    $end            reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    FI              reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    ELSE            reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    OD              reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    ESAC            reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    CASE_HEADER     reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    RBRACKET        reduce using rule 17 (stmt -> IF expr THEN stmts FI .)
    ENDFOR          reduce using rule 17 (stmt -> IF expr THEN stmts FI .)


state 128

    (18) stmt -> IF expr THEN stmts ELSE . stmts FI
    (1) stmts -> . stmt
    (2) stmts -> . stmts stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    expr                           shift and go to state 7
    stmts                          shift and go to state 135
    stmt                           shift and go to state 2

state 129

    (20) stmt -> IF expr stmts ELSE stmts . FI
    (21) stmt -> IF expr stmts ELSE stmts .
    (2) stmts -> stmts . stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

  ! shift/reduce conflict for FI resolved as shift
  ! shift/reduce conflict for DEFINE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CASE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for DO resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PSEUDO resolved as shift
  ! shift/reduce conflict for OP resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for BITWISE_NOT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
    FI              shift and go to state 136
    $end            reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .)
    ELSE            reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .)
    OD              reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .)
    ESAC            reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .)
    CASE_HEADER     reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .)
    RBRACKET        reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .)
    ENDFOR          reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .)
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

  ! DEFINE          [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! BREAK           [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! CASE            [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! RETURN          [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! DO              [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! FOR             [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! IF              [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! PSEUDO          [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! OP              [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! ID              [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! NOT             [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! MINUS           [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! BITWISE_NOT     [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! LPAREN          [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! NUMBER          [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]
  ! FI              [ reduce using rule 21 (stmt -> IF expr stmts ELSE stmts .) ]

    expr                           shift and go to state 7
    stmt                           shift and go to state 19

state 130

    (3) stmt -> DEFINE ID LPAREN args RPAREN LBRACKET . stmts RBRACKET
    (1) stmts -> . stmt
    (2) stmts -> . stmts stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    stmts                          shift and go to state 137
    stmt                           shift and go to state 2
    expr                           shift and go to state 7

state 131

    (30) expr -> expr LBRACE expr COLON expr RBRACE .

    UPDATE          reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    PLUS_EQUAL      reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    OR_EQUAL        reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    DOT             reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    LBRACE          reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    QUEST           reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    BITWISE_AND     reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    BITWISE_OR      reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    OP              reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    PLUS            reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    MINUS           reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    TIMES           reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    DIV             reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    MOD             reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    AND             reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    OR              reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    LSHIFT          reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    RSHIFT          reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    LSHIFT_LOGICAL  reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    RSHIFT_LOGICAL  reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    GREATER         reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    LESS            reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    LESS_EQUAL      reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    GREATER_EQUAL   reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    EQUAL           reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    NOT_EQUAL       reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    XOR             reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    DEFINE          reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    BREAK           reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    CASE            reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    RETURN          reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    DO              reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    FOR             reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    IF              reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    PSEUDO          reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    ID              reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    NOT             reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    BITWISE_NOT     reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    LPAREN          reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    NUMBER          reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    $end            reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    RPAREN          reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    OF              reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    FI              reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    ELSE            reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    OD              reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    ESAC            reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    CASE_HEADER     reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    RBRACKET        reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    ENDFOR          reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    THEN            reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    COMMA           reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    RBRACE          reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    COLON           reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    TO              reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)
    DOWNTO          reduce using rule 30 (expr -> expr LBRACE expr COLON expr RBRACE .)


state 132

    (8) cases -> cases CASE_HEADER stmts .
    (2) stmts -> stmts . stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    ESAC            reduce using rule 8 (cases -> cases CASE_HEADER stmts .)
    CASE_HEADER     reduce using rule 8 (cases -> cases CASE_HEADER stmts .)
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    stmt                           shift and go to state 19
    expr                           shift and go to state 7

state 133

    (15) stmt -> FOR ID UPDATE expr TO expr . stmts ENDFOR
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr
    (1) stmts -> . stmt
    (2) stmts -> . stmts stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 99
    PLUS            shift and go to state 34
    MINUS           shift and go to state 100
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    ID              shift and go to state 4
    NOT             shift and go to state 15
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    expr                           shift and go to state 7
    stmts                          shift and go to state 138
    stmt                           shift and go to state 2

state 134

    (16) stmt -> FOR ID UPDATE expr DOWNTO expr . stmts ENDFOR
    (10) expr -> expr . UPDATE expr
    (12) expr -> expr . PLUS_EQUAL expr
    (13) expr -> expr . OR_EQUAL expr
    (26) expr -> expr . DOT ID
    (29) expr -> expr . LBRACE expr RBRACE
    (30) expr -> expr . LBRACE expr COLON expr RBRACE
    (31) expr -> expr . QUEST expr COLON expr
    (35) expr -> expr . BITWISE_AND expr
    (36) expr -> expr . BITWISE_OR expr
    (37) expr -> expr . OP expr
    (38) expr -> expr . PLUS expr
    (39) expr -> expr . MINUS expr
    (40) expr -> expr . TIMES expr
    (41) expr -> expr . DIV expr
    (42) expr -> expr . MOD expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . OR expr
    (45) expr -> expr . LSHIFT expr
    (46) expr -> expr . RSHIFT expr
    (47) expr -> expr . LSHIFT_LOGICAL expr
    (48) expr -> expr . RSHIFT_LOGICAL expr
    (49) expr -> expr . GREATER expr
    (50) expr -> expr . LESS expr
    (51) expr -> expr . LESS_EQUAL expr
    (52) expr -> expr . GREATER_EQUAL expr
    (53) expr -> expr . EQUAL expr
    (54) expr -> expr . NOT_EQUAL expr
    (55) expr -> expr . XOR expr
    (1) stmts -> . stmt
    (2) stmts -> . stmts stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    UPDATE          shift and go to state 25
    PLUS_EQUAL      shift and go to state 26
    OR_EQUAL        shift and go to state 27
    DOT             shift and go to state 28
    LBRACE          shift and go to state 29
    QUEST           shift and go to state 30
    BITWISE_AND     shift and go to state 31
    BITWISE_OR      shift and go to state 32
    OP              shift and go to state 99
    PLUS            shift and go to state 34
    MINUS           shift and go to state 100
    TIMES           shift and go to state 36
    DIV             shift and go to state 37
    MOD             shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    LSHIFT          shift and go to state 41
    RSHIFT          shift and go to state 42
    LSHIFT_LOGICAL  shift and go to state 43
    RSHIFT_LOGICAL  shift and go to state 44
    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    LESS_EQUAL      shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    EQUAL           shift and go to state 49
    NOT_EQUAL       shift and go to state 50
    XOR             shift and go to state 51
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    ID              shift and go to state 4
    NOT             shift and go to state 15
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    expr                           shift and go to state 7
    stmts                          shift and go to state 139
    stmt                           shift and go to state 2

state 135

    (18) stmt -> IF expr THEN stmts ELSE stmts . FI
    (2) stmts -> stmts . stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    FI              shift and go to state 140
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    expr                           shift and go to state 7
    stmt                           shift and go to state 19

state 136

    (20) stmt -> IF expr stmts ELSE stmts FI .

    DEFINE          reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    BREAK           reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    CASE            reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    RETURN          reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    DO              reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    FOR             reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    IF              reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    PSEUDO          reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    OP              reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    ID              reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    NOT             reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    MINUS           reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    BITWISE_NOT     reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    LPAREN          reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    NUMBER          reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    $end            reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    FI              reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    ELSE            reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    OD              reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    ESAC            reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    CASE_HEADER     reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    RBRACKET        reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)
    ENDFOR          reduce using rule 20 (stmt -> IF expr stmts ELSE stmts FI .)


state 137

    (3) stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts . RBRACKET
    (2) stmts -> stmts . stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    RBRACKET        shift and go to state 141
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    stmt                           shift and go to state 19
    expr                           shift and go to state 7

state 138

    (15) stmt -> FOR ID UPDATE expr TO expr stmts . ENDFOR
    (2) stmts -> stmts . stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    ENDFOR          shift and go to state 142
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    expr                           shift and go to state 7
    stmt                           shift and go to state 19

state 139

    (16) stmt -> FOR ID UPDATE expr DOWNTO expr stmts . ENDFOR
    (2) stmts -> stmts . stmt
    (3) stmt -> . DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET
    (4) stmt -> . BREAK
    (5) stmt -> . expr
    (6) stmt -> . CASE expr OF cases ESAC
    (9) stmt -> . RETURN expr
    (14) stmt -> . DO WHILE expr stmts OD
    (15) stmt -> . FOR ID UPDATE expr TO expr stmts ENDFOR
    (16) stmt -> . FOR ID UPDATE expr DOWNTO expr stmts ENDFOR
    (17) stmt -> . IF expr THEN stmts FI
    (18) stmt -> . IF expr THEN stmts ELSE stmts FI
    (19) stmt -> . IF expr stmts FI
    (20) stmt -> . IF expr stmts ELSE stmts FI
    (21) stmt -> . IF expr stmts ELSE stmts
    (22) stmt -> . PSEUDO
    (10) expr -> . expr UPDATE expr
    (11) expr -> . OP UPDATE ID
    (12) expr -> . expr PLUS_EQUAL expr
    (13) expr -> . expr OR_EQUAL expr
    (23) expr -> . ID LPAREN args RPAREN
    (24) expr -> . ID LPAREN RPAREN
    (25) expr -> . ID LBRACKET expr RBRACKET
    (26) expr -> . expr DOT ID
    (29) expr -> . expr LBRACE expr RBRACE
    (30) expr -> . expr LBRACE expr COLON expr RBRACE
    (31) expr -> . expr QUEST expr COLON expr
    (32) expr -> . NOT expr
    (33) expr -> . MINUS expr
    (34) expr -> . BITWISE_NOT expr
    (35) expr -> . expr BITWISE_AND expr
    (36) expr -> . expr BITWISE_OR expr
    (37) expr -> . expr OP expr
    (38) expr -> . expr PLUS expr
    (39) expr -> . expr MINUS expr
    (40) expr -> . expr TIMES expr
    (41) expr -> . expr DIV expr
    (42) expr -> . expr MOD expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr OR expr
    (45) expr -> . expr LSHIFT expr
    (46) expr -> . expr RSHIFT expr
    (47) expr -> . expr LSHIFT_LOGICAL expr
    (48) expr -> . expr RSHIFT_LOGICAL expr
    (49) expr -> . expr GREATER expr
    (50) expr -> . expr LESS expr
    (51) expr -> . expr LESS_EQUAL expr
    (52) expr -> . expr GREATER_EQUAL expr
    (53) expr -> . expr EQUAL expr
    (54) expr -> . expr NOT_EQUAL expr
    (55) expr -> . expr XOR expr
    (56) expr -> . LPAREN expr RPAREN
    (57) expr -> . ID
    (58) expr -> . NUMBER
    (59) expr -> . PSEUDO

    ENDFOR          shift and go to state 143
    DEFINE          shift and go to state 3
    BREAK           shift and go to state 6
    CASE            shift and go to state 8
    RETURN          shift and go to state 9
    DO              shift and go to state 10
    FOR             shift and go to state 11
    IF              shift and go to state 12
    PSEUDO          shift and go to state 13
    OP              shift and go to state 14
    ID              shift and go to state 4
    NOT             shift and go to state 15
    MINUS           shift and go to state 16
    BITWISE_NOT     shift and go to state 17
    LPAREN          shift and go to state 5
    NUMBER          shift and go to state 18

    expr                           shift and go to state 7
    stmt                           shift and go to state 19

state 140

    (18) stmt -> IF expr THEN stmts ELSE stmts FI .

    DEFINE          reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    BREAK           reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    CASE            reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    RETURN          reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    DO              reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    FOR             reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    IF              reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    PSEUDO          reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    OP              reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    ID              reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    NOT             reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    MINUS           reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    BITWISE_NOT     reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    LPAREN          reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    NUMBER          reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    $end            reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    FI              reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    ELSE            reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    OD              reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    ESAC            reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    CASE_HEADER     reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    RBRACKET        reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)
    ENDFOR          reduce using rule 18 (stmt -> IF expr THEN stmts ELSE stmts FI .)


state 141

    (3) stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .

    DEFINE          reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    BREAK           reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    CASE            reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    RETURN          reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    DO              reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    FOR             reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    IF              reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    PSEUDO          reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    OP              reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    ID              reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    NOT             reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    MINUS           reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    BITWISE_NOT     reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    LPAREN          reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    NUMBER          reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    $end            reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    FI              reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    ELSE            reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    OD              reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    ESAC            reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    CASE_HEADER     reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    RBRACKET        reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)
    ENDFOR          reduce using rule 3 (stmt -> DEFINE ID LPAREN args RPAREN LBRACKET stmts RBRACKET .)


state 142

    (15) stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .

    DEFINE          reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    BREAK           reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    CASE            reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    RETURN          reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    DO              reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    FOR             reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    IF              reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    PSEUDO          reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    OP              reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    ID              reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    NOT             reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    MINUS           reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    BITWISE_NOT     reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    LPAREN          reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    NUMBER          reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    $end            reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    FI              reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    ELSE            reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    OD              reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    ESAC            reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    CASE_HEADER     reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    RBRACKET        reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)
    ENDFOR          reduce using rule 15 (stmt -> FOR ID UPDATE expr TO expr stmts ENDFOR .)


state 143

    (16) stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .

    DEFINE          reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    BREAK           reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    CASE            reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    RETURN          reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    DO              reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    FOR             reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    IF              reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    PSEUDO          reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    OP              reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    ID              reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    NOT             reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    MINUS           reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    BITWISE_NOT     reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    LPAREN          reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    NUMBER          reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    $end            reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    FI              reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    ELSE            reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    OD              reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    ESAC            reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    CASE_HEADER     reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    RBRACKET        reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)
    ENDFOR          reduce using rule 16 (stmt -> FOR ID UPDATE expr DOWNTO expr stmts ENDFOR .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 4 resolved as shift
WARNING: shift/reduce conflict for OP in state 7 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 7 resolved as shift
WARNING: shift/reduce conflict for OP in state 53 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 53 resolved as shift
WARNING: shift/reduce conflict for UPDATE in state 67 resolved as shift
WARNING: shift/reduce conflict for PLUS_EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for OR_EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for DOT in state 67 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 67 resolved as shift
WARNING: shift/reduce conflict for QUEST in state 67 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 67 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 67 resolved as shift
WARNING: shift/reduce conflict for OP in state 67 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 67 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 67 resolved as shift
WARNING: shift/reduce conflict for DIV in state 67 resolved as shift
WARNING: shift/reduce conflict for MOD in state 67 resolved as shift
WARNING: shift/reduce conflict for AND in state 67 resolved as shift
WARNING: shift/reduce conflict for OR in state 67 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 67 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 67 resolved as shift
WARNING: shift/reduce conflict for LSHIFT_LOGICAL in state 67 resolved as shift
WARNING: shift/reduce conflict for RSHIFT_LOGICAL in state 67 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 67 resolved as shift
WARNING: shift/reduce conflict for LESS in state 67 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for XOR in state 67 resolved as shift
WARNING: shift/reduce conflict for UPDATE in state 68 resolved as shift
WARNING: shift/reduce conflict for PLUS_EQUAL in state 68 resolved as shift
WARNING: shift/reduce conflict for OR_EQUAL in state 68 resolved as shift
WARNING: shift/reduce conflict for DOT in state 68 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 68 resolved as shift
WARNING: shift/reduce conflict for QUEST in state 68 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 68 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 68 resolved as shift
WARNING: shift/reduce conflict for OP in state 68 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 68 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 68 resolved as shift
WARNING: shift/reduce conflict for DIV in state 68 resolved as shift
WARNING: shift/reduce conflict for MOD in state 68 resolved as shift
WARNING: shift/reduce conflict for AND in state 68 resolved as shift
WARNING: shift/reduce conflict for OR in state 68 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 68 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 68 resolved as shift
WARNING: shift/reduce conflict for LSHIFT_LOGICAL in state 68 resolved as shift
WARNING: shift/reduce conflict for RSHIFT_LOGICAL in state 68 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 68 resolved as shift
WARNING: shift/reduce conflict for LESS in state 68 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 68 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 68 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 68 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 68 resolved as shift
WARNING: shift/reduce conflict for XOR in state 68 resolved as shift
WARNING: shift/reduce conflict for UPDATE in state 69 resolved as shift
WARNING: shift/reduce conflict for PLUS_EQUAL in state 69 resolved as shift
WARNING: shift/reduce conflict for OR_EQUAL in state 69 resolved as shift
WARNING: shift/reduce conflict for DOT in state 69 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 69 resolved as shift
WARNING: shift/reduce conflict for QUEST in state 69 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 69 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 69 resolved as shift
WARNING: shift/reduce conflict for OP in state 69 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 69 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 69 resolved as shift
WARNING: shift/reduce conflict for DIV in state 69 resolved as shift
WARNING: shift/reduce conflict for MOD in state 69 resolved as shift
WARNING: shift/reduce conflict for AND in state 69 resolved as shift
WARNING: shift/reduce conflict for OR in state 69 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 69 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 69 resolved as shift
WARNING: shift/reduce conflict for LSHIFT_LOGICAL in state 69 resolved as shift
WARNING: shift/reduce conflict for RSHIFT_LOGICAL in state 69 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 69 resolved as shift
WARNING: shift/reduce conflict for LESS in state 69 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 69 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 69 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 69 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 69 resolved as shift
WARNING: shift/reduce conflict for XOR in state 69 resolved as shift
WARNING: shift/reduce conflict for UPDATE in state 75 resolved as shift
WARNING: shift/reduce conflict for PLUS_EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for OR_EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for DOT in state 75 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 75 resolved as shift
WARNING: shift/reduce conflict for QUEST in state 75 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 75 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 75 resolved as shift
WARNING: shift/reduce conflict for OP in state 75 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 75 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 75 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 75 resolved as shift
WARNING: shift/reduce conflict for DIV in state 75 resolved as shift
WARNING: shift/reduce conflict for MOD in state 75 resolved as shift
WARNING: shift/reduce conflict for AND in state 75 resolved as shift
WARNING: shift/reduce conflict for OR in state 75 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 75 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 75 resolved as shift
WARNING: shift/reduce conflict for LSHIFT_LOGICAL in state 75 resolved as shift
WARNING: shift/reduce conflict for RSHIFT_LOGICAL in state 75 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 75 resolved as shift
WARNING: shift/reduce conflict for LESS in state 75 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for XOR in state 75 resolved as shift
WARNING: shift/reduce conflict for UPDATE in state 120 resolved as shift
WARNING: shift/reduce conflict for PLUS_EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for OR_EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for DOT in state 120 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 120 resolved as shift
WARNING: shift/reduce conflict for QUEST in state 120 resolved as shift
WARNING: shift/reduce conflict for BITWISE_AND in state 120 resolved as shift
WARNING: shift/reduce conflict for BITWISE_OR in state 120 resolved as shift
WARNING: shift/reduce conflict for OP in state 120 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 120 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 120 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 120 resolved as shift
WARNING: shift/reduce conflict for DIV in state 120 resolved as shift
WARNING: shift/reduce conflict for MOD in state 120 resolved as shift
WARNING: shift/reduce conflict for AND in state 120 resolved as shift
WARNING: shift/reduce conflict for OR in state 120 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 120 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 120 resolved as shift
WARNING: shift/reduce conflict for LSHIFT_LOGICAL in state 120 resolved as shift
WARNING: shift/reduce conflict for RSHIFT_LOGICAL in state 120 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 120 resolved as shift
WARNING: shift/reduce conflict for LESS in state 120 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for XOR in state 120 resolved as shift
WARNING: shift/reduce conflict for FI in state 129 resolved as shift
WARNING: shift/reduce conflict for DEFINE in state 129 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 129 resolved as shift
WARNING: shift/reduce conflict for CASE in state 129 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 129 resolved as shift
WARNING: shift/reduce conflict for DO in state 129 resolved as shift
WARNING: shift/reduce conflict for FOR in state 129 resolved as shift
WARNING: shift/reduce conflict for IF in state 129 resolved as shift
WARNING: shift/reduce conflict for PSEUDO in state 129 resolved as shift
WARNING: shift/reduce conflict for OP in state 129 resolved as shift
WARNING: shift/reduce conflict for ID in state 129 resolved as shift
WARNING: shift/reduce conflict for NOT in state 129 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 129 resolved as shift
WARNING: shift/reduce conflict for BITWISE_NOT in state 129 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 129 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 129 resolved as shift
WARNING: reduce/reduce conflict in state 13 resolved using rule (stmt -> PSEUDO)
WARNING: rejected rule (expr -> PSEUDO) in state 13
WARNING: reduce/reduce conflict in state 116 resolved using rule (expr -> MINUS expr)
WARNING: rejected rule (expr -> expr MINUS expr) in state 116
