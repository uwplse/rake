#lang rosette

(require rake/util)

(require rake/halide/ir/types)
(require rake/halide/ir/interpreter)

(require rake/hvx/ast/types)
(require rake/hvx/ast/visitor)
(require rake/hvx/interpreter)

(define (verify-equiv? halide-spec hvx-expr ctx axioms)
  (display "Verifying expression equivalence over full-length vectors...\n")
  (display "============================================================\n")

  (define VEC_LANES (num-elems-hal halide-spec))

  ;; The visitor clones each node in the AST, converting it from a graph to a tree
  (define (iden node) node)
  (set! hvx-expr (visit-hvx hvx-expr iden))

  (define interpreted-s-expr (interpret-hvx hvx-expr))
  (define interpreted-o-expr (interpret-halide halide-spec))
  
  ;; Verify multiple lanes at once (Slower...takes 1554 seconds (128 lanes) for baseline gaussian stage 2 example)
  (define (equiv-output? oe se)
    (for ([lane 8])
      (cond
        [(hvx-pair? se)
         (set-curr-cn-hvx lane)
         (assert (eq? (oe lane) (v0-elem-hvx se lane)))]
        [else
         (set-curr-cn-hvx lane)
         (assert (eq? (oe lane) (elem-hvx se lane)))])))
  
  (clear-vc!)
  (for ([axiom axioms]) (assume axiom))
  (define st (current-seconds))
  (define sol (synthesize #:forall ctx
                          #:guarantee (equiv-output? interpreted-o-expr interpreted-s-expr)))
  (define runtime (- (current-seconds) st))
  (define correct? (not (unsat? sol)))
  
  ;; Verify all lanes incrementally (Faster...takes 30 seconds for baseline gaussian stage 2 example)
  (define (lane-eq? oe se lane)
    (cond
      [(hvx-pair? se)
       (set-curr-cn-hvx lane)
       (assert (eq? (oe lane) (v0-elem-hvx se lane)))]
      [else
       (set-curr-cn-hvx lane)
       (assert (eq? (oe lane) (elem-hvx se lane)))]))
  
  (define sols (list))
  (clear-vc!)
  (for ([axiom axioms]) (assume axiom))
  (set! st (current-seconds))
  (for ([lane VEC_LANES])
    (set-curr-cn-hvx lane)
    (define sol (synthesize #:forall ctx
                            #:guarantee (lane-eq? interpreted-o-expr interpreted-s-expr lane)))
    (set! sols (append sols (list sol))))
  (set! runtime (- (current-seconds) st))
  (set! correct? (and correct? (eq? (vec-len halide-spec) (num-elems-hvx interpreted-s-expr)) (not (for/or ([sol sols]) (unsat? sol)))))
  
  ;; Print solution
  (debug (format "Verification time: ~a seconds\n\n" runtime))

  correct?)

;; We can simplify our verification query by replacing each array access as a unique symbolic variable.
;; This allows z3 to not reason about the indexing expressions.
;; Currently, I am assuming that if two indexing expression generated by Halide are *syntactically* different, then they access
;; different points of the array. If this assumption is incorrect, we can easily make a z3 query to confirm this assumption before
;; applying the simplification.
;(define abstractions (make-hash))
;
;(define (abstract-arr-accesses buff-reads)
;  (for/list ([lane-buff-reads buff-reads])
;    (for/list ([buff-read lane-buff-reads])
;      (define v (eval buff-read))
;      (define t (type buff-read))
;      (define bits (bw buff-read))
;      (when (not (hash-has-key? abstractions v))
;        (define-symbolic* arr-read (bitvector bits))
;        (hash-set! abstractions v (mk-typed-expr arr-read t)))
;      (hash-ref abstractions v))))
;
;(define (replace-arr-accesses expr)
;  (match expr
;    [(int8_t v) (int8_t (replace-arr-accesses v))]
;    [(int16_t v) (int16_t (replace-arr-accesses v))]
;    [(int32_t v) (int32_t (replace-arr-accesses v))]
;    [(uint8_t v) (uint8_t (replace-arr-accesses v))]
;    [(uint16_t v) (uint16_t (replace-arr-accesses v))]
;    [(uint32_t v) (uint32_t (replace-arr-accesses v))]
;
;    [(expression op operands ...)
;
;     ;; Silly workaround -- ask rosette folks how to do this properly
;     (define-symbolic hack (~> integer? (bitvector 16)))
;     (define hack2 (hack 0))
;     (define app (match hack2 [(expression op2 ops2 ...) op2]))
;
;     (cond
;       [(eq? op bvadd) (foldr bvadd (replace-arr-accesses (car operands)) (for/list ([operand (cdr operands)]) (replace-arr-accesses operand)))]
;       [(eq? op bvmul) (foldr bvmul (replace-arr-accesses (car operands)) (for/list ([operand (cdr operands)]) (replace-arr-accesses operand)))]
;       [(eq? op bvsdiv) (bvsdiv (replace-arr-accesses (list-ref operands 0)) (replace-arr-accesses (list-ref operands 1)))]
;       [(eq? op bvudiv) (bvudiv (replace-arr-accesses (list-ref operands 0)) (replace-arr-accesses (list-ref operands 1)))]
;       [(eq? op extract) (extract (list-ref operands 0) (list-ref operands 1) (replace-arr-accesses (list-ref operands 3)))]
;       [(eq? op zero-extend) (zero-extend (replace-arr-accesses (list-ref operands 0)) (list-ref operands 1))]
;       [(eq? op app) (eval (hash-ref abstractions expr))]
;       [else (error "NYI: abstract array accesses for" expr)])]
;     
;    [_ expr]))


(provide verify-equiv?)