#lang rosette/safe

(require
  (only-in racket/base error bitwise-and)
  rosette/lib/destruct
  rake/cpp
  rake/halide/ir/types)

(provide (prefix-out halide: (all-defined-out)))

;; Infer the length of vector generated by the expression
(define (elem-type expr)
  (define intr-expr (interpret expr))
  (cpp:type (intr-expr 0)))

;; Infer the length of vector generated by the expression
(define (vec-len expr)
  (destruct expr
    ;; Abstract expressions
    [(abstr-halide-expr orig-expr abstr-vals) (vec-len orig-expr)]
    
    ;; Constructors
    [(ramp base stride len) len]
    [(load buf idxs alignment) (vec-len idxs)]
    [(load-sca buf idx) 1]
    [(sca-broadcast sca len) len]

    ;; Operations
    [(vec-cast vec type len) len]
    
    [(vec-add v1 v2) (vec-len v1)]
    [(vec-sub v1 v2) (vec-len v1)]
    [(vec-mul v1 v2) (vec-len v1)]
    [(vec-div v1 v2) (vec-len v1)]
    [(vec-mod v1 v2) (vec-len v1)]
    [(vec-min v1 v2) (vec-len v1)]
    [(vec-max v1 v2) (vec-len v1)]

    [(vec-if v1 v2 v3) (vec-len v2)]
    [(vec-eq v1 v2) (vec-len v1)]
    [(vec-lt v1 v2) (vec-len v1)]
    [(vec-le v1 v2) (vec-len v1)]

    [(vec-abs v1) (vec-len v1)]
    [(vec-clz v1) (vec-len v1)]

    [(vec-absd v1 v2) (vec-len v1)]
    [(vec-shl v1 v2) (vec-len v1)]
    [(vec-shr v1 v2) (vec-len v1)]

    [(vec-bwand v1 v2) (vec-len v1)]

    [(vector_reduce op width vec) (quotient (vec-len vec) width)]

    ;; Shuffles
    [(slice_vectors vec base stride len) len]
    [(concat_vectors v1 v2) (+ (vec-len v1) (vec-len v2))]
    [(interleave v1 v2) (+ (vec-len v1) (vec-len v2))]
    [(interleave4 v1 v2 v3 v4) (+ (vec-len v1) (vec-len v2) (vec-len v3) (vec-len v4))]
    [(dynamic_shuffle vec idxs st end) (vec-len idxs)]

    [(vec-broadcast n vec) (* n (vec-len vec))]
    
    ;; Base case
    [_ (error "halide\\ir\\interpreter.rkt: Don't know how to infer vector length for Halide expression:" expr)]))

;; Get the (vector) sub-expressions
(define (sub-exprs expr)
  (destruct expr
    ;; Constructors
    [(ramp base stride len) (list)]
    [(load buf idxs alignment) (list)]
    [(load-sca buf idx) (list)]
    [(sca-broadcast sca len) (list)]

    ;; Operations
    [(vec-cast vec type len) (list vec)]
    
    [(vec-add v1 v2) (list v1 v2)]
    [(vec-sub v1 v2) (list v1 v2)]
    [(vec-mul v1 v2) (list v1 v2)]
    [(vec-div v1 v2) (list v1 v2)]
    [(vec-mod v1 v2) (list v1 v2)]
    [(vec-min v1 v2) (list v1 v2)]
    [(vec-max v1 v2) (list v1 v2)]
    [(vec-if v1 v2 v3) (list v1 v2 v3)]
    [(vec-eq v1 v2) (list v1 v2)]
    [(vec-lt v1 v2) (list v1 v2)]
    [(vec-le v1 v2) (list v1 v2)]

    [(vec-abs v1) (list v1)]
    [(vec-clz v1) (list v1)]
    
    [(vec-absd v1 v2) (list v1 v2)]
    [(vec-shl v1 v2) (list v1 v2)]
    [(vec-shr v1 v2) (list v1 v2)]

    [(vec-bwand v1 v2) (list v1 v2)]

    [(vector_reduce op width vec) (list vec)]

    ;; Shuffles
    [(vec-broadcast n vec) (list vec)]
    [(slice_vectors vec base stride len) (list vec)]
    [(concat_vectors v1 v2) (list v1 v2)]
    [(interleave v1 v2) (list v1 v2)]
    [(interleave4 v1 v2 v3 v4) (list v1 v2 v3 v4)]
    [(dynamic_shuffle vec idxs st end) (list vec idxs)]
    
    ;; Base case
    [_ (error "halide\\ir\\interpreter.rkt: Don't know how to return sub-expressions for Halide expression:" expr)]))

(define (interpret p)
  (destruct p
    ;; Abstract expressions
    [(abstr-halide-expr orig-expr abstr-vals) (lambda (i) (buffer-ref abstr-vals i))]

    ;; Var lookups
    [(var-lookup var val) (interpret val)]
    
    ;; Constructors
    [(ramp base stride len)
     (define intr-base (interpret base))
     (define intr-stride (interpret stride))
     (cond
       [(integer? intr-base)
        (lambda (i) (+ (interpret base) (* i (interpret stride))))]
       [else
        (lambda (i)
          (mk-cpp-expr
           (bvadd
            (cpp:eval intr-base)
            (bvmul
             (integer->bitvector i (bitvector (cpp:expr-bw intr-stride)))
             (cpp:eval intr-stride)))
           (cpp:type intr-base)))])]

    [(load buf idxs alignment) (lambda (i) (buffer-ref (interpret buf) ((interpret idxs) i)))]
    [(load-sca buf idx) (buffer-ref (interpret buf) (interpret idx))]
    [(sca-broadcast sca lanes) (lambda (i) (interpret sca))]
    
    ;; Operations
    [(sca-cast v type) (cpp:cast (interpret v) type)]
    
    [(sca-add v1 v2) (do-add (interpret v1) (interpret v2))]
    [(sca-sub v1 v2) (do-sub (interpret v1) (interpret v2))]
    [(sca-mul v1 v2) (do-mul (interpret v1) (interpret v2))]
    [(sca-div v1 v2) (do-div (interpret v1) (interpret v2))]
    [(sca-mod v1 v2) (do-mod (interpret v1) (interpret v2))]
    [(sca-min v1 v2) (do-min (interpret v1) (interpret v2))]
    [(sca-max v1 v2) (do-max (interpret v1) (interpret v2))]

    [(sca-if v1 v2 v3) (do-if (interpret v1) (interpret v2) (interpret v3))]
    [(sca-eq v1 v2) (do-eq (interpret v1) (interpret v2))]
    [(sca-lt v1 v2) (do-lt (interpret v1) (interpret v2))]
    [(sca-le v1 v2) (do-le (interpret v1) (interpret v2))]

    [(sca-abs v1) (do-abs (interpret v1))]
    [(sca-absd v1 v2) (do-absd (interpret v1) (interpret v2))]
    [(sca-shl v1 v2) (do-shl (interpret v1) (interpret v2))]
    [(sca-shr v1 v2) (do-shr (interpret v1) (interpret v2))]
    [(sca-clz v1) (do-clz (interpret v1))]

    [(sca-bwand v1 v2) (do-bwand (interpret v1) (interpret v2))]

    [(vec-cast vec type len) (lambda (i) (cpp:cast ((interpret vec) i) type))]
    
    [(vec-add v1 v2) (lambda (i) (do-add ((interpret v1) i) ((interpret v2) i)))]
    [(vec-sub v1 v2) (lambda (i) (do-sub ((interpret v1) i) ((interpret v2) i)))]
    [(vec-mul v1 v2) (lambda (i) (do-mul ((interpret v1) i) ((interpret v2) i)))]
    [(vec-div v1 v2) (lambda (i) (do-div ((interpret v1) i) ((interpret v2) i)))]
    [(vec-mod v1 v2) (lambda (i) (do-mod ((interpret v1) i) ((interpret v2) i)))]
    [(vec-min v1 v2) (lambda (i) (do-min ((interpret v1) i) ((interpret v2) i)))]
    [(vec-max v1 v2) (lambda (i) (do-max ((interpret v1) i) ((interpret v2) i)))]

    [(vec-if v1 v2 v3) (lambda (i) (do-if ((interpret v1) i) ((interpret v2) i) ((interpret v3) i)))]
    [(vec-eq v1 v2) (lambda (i) (do-eq ((interpret v1) i) ((interpret v2) i)))]
    [(vec-lt v1 v2) (lambda (i) (do-lt ((interpret v1) i) ((interpret v2) i)))]
    [(vec-le v1 v2) (lambda (i) (do-le ((interpret v1) i) ((interpret v2) i)))]

    [(vec-abs v1) (lambda (i) (do-abs ((interpret v1) i)))]
    [(vec-shl v1 v2) (lambda (i) (do-shl ((interpret v1) i) ((interpret v2) i)))]
    [(vec-shr v1 v2) (lambda (i) (do-shr ((interpret v1) i) ((interpret v2) i)))]
    [(vec-absd v1 v2) (lambda (i) (do-absd ((interpret v1) i) ((interpret v2) i)))]
    [(vec-clz v1) (lambda (i) (do-clz ((interpret v1) i)))]

    [(vec-bwand v1 v2) (lambda (i) (do-bwand ((interpret v1) i) ((interpret v2) i)))]

    [(vector_reduce op width vec)
     (cond
       [(eq? op 'add)
        (lambda (i) (do-reduce (interpret vec) bvadd (* i width) width))]
       [else (error "Unexpected vector_reduce op:" op)])]

    ;; Shuffles
    [(vec-broadcast n vec) (define l (vec-len vec)) (lambda (i) ((interpret vec) (modulo i l)))]
    [(slice_vectors vec base stride len) (lambda (i) ((interpret vec) (+ (interpret base) (* i (interpret stride)))))]
    [(concat_vectors v1 v2) (lambda (i) (if (< i (vec-len v1)) ((interpret v1) i) ((interpret v2) (- i (vec-len v1)))))]
    [(dynamic_shuffle vec idxs st end) (lambda (i) ((interpret vec) (+ ((interpret idxs) i) st)))]
    [(interleave v1 v2) (lambda (i) (if (even? i) ((interpret v1) (quotient i 2)) ((interpret v2) (quotient i 2))))]
    [(interleave4 v1 v2 v3 v4)
     (lambda (i)
       (cond
         [(eq? 0 (remainder i 4)) ((interpret v1) (quotient i 4))]
         [(eq? 1 (remainder i 4)) ((interpret v2) (quotient i 4))]
         [(eq? 2 (remainder i 4)) ((interpret v3) (quotient i 4))]
         [(eq? 3 (remainder i 4)) ((interpret v4) (quotient i 4))]))]
    
    ;; Base case
    [_ p]))

(define (buffer-ref buffer idx)
  (define elemT (buffer-elemT buffer))
  (define data (buffer-data buffer))
  (cond
    [(eq? elemT 'int8) (int8_t (data idx))]
    [(eq? elemT 'int16) (int16_t (data idx))]
    [(eq? elemT 'int32) (int32_t (data idx))]
    [(eq? elemT 'int64) (int64_t (data idx))]
    [(eq? elemT 'uint1) (uint1_t (data idx))]
    [(eq? elemT 'uint8) (uint8_t (data idx))]
    [(eq? elemT 'uint16) (uint16_t (data idx))]
    [(eq? elemT 'uint32) (uint32_t (data idx))]
    [(eq? elemT 'uint64) (uint64_t (data idx))]
    [else (error "halide/ir/interpreter.rkt: Unexpected buffer type" buffer)]))

;; Model basic arithmetic
(define (infer-out-type lhs rhs)
  (define max-bw (if (> (cpp:expr-bw lhs) (cpp:expr-bw rhs)) (cpp:expr-bw lhs) (cpp:expr-bw rhs)))
  (cond
    [(and (cpp:signed-expr? lhs) (cpp:signed-expr? rhs)) (mk-cpp-type max-bw #t)]
    [(and (cpp:unsigned-expr? lhs) (cpp:unsigned-expr? rhs)) (mk-cpp-type max-bw #f)]
    [else (mk-cpp-type max-bw #t)]))

(define (do-add lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (+ lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (mk-cpp-expr (bvadd (cpp:eval lhs) (cpp:eval rhs)) outT)]))

(define (do-sub lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (- lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (mk-cpp-expr (bvsub (cpp:eval lhs) (cpp:eval rhs)) outT)]))

(define (do-mul lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (- lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (mk-cpp-expr (bvmul (cpp:eval lhs) (cpp:eval rhs)) outT)]))

(define (do-div lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (quotient lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (cond
       [(cpp:signed-type? outT)
        (cpp:euclidean-div lhs rhs outT)]
       [else
        (mk-cpp-expr (bvudiv (cpp:eval lhs) (cpp:eval rhs)) outT)])]))

(define (do-mod lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (remainder lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (cond
       [(cpp:signed-type? outT)
        (mk-cpp-expr (bvsrem (cpp:eval lhs) (cpp:eval rhs)) outT)]
       [else
        (mk-cpp-expr (bvurem (cpp:eval lhs) (cpp:eval rhs)) outT)])]))

(define (do-min lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (min lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (cond
       [(cpp:signed-type? outT)
        (define minF
          (cond
            [(eq? (cpp:type-bw outT) 8) cpp:min8]
            [(eq? (cpp:type-bw outT) 16) cpp:min16]
            [(eq? (cpp:type-bw outT) 32) cpp:min32]
            [(eq? (cpp:type-bw outT) 64) cpp:min64]))
        (minF lhs rhs)]
       [else
        (define minF
          (cond
            [(eq? (cpp:type-bw outT) 8) cpp:minu8]
            [(eq? (cpp:type-bw outT) 16) cpp:minu16]
            [(eq? (cpp:type-bw outT) 32) cpp:minu32]
            [(eq? (cpp:type-bw outT) 64) cpp:minu64]))
        (minF lhs rhs)])]))

(define (do-max lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (max lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (cond
       [(cpp:signed-type? outT)
        (define maxF
          (cond
            [(eq? (cpp:type-bw outT) 8) cpp:max8]
            [(eq? (cpp:type-bw outT) 16) cpp:max16]
            [(eq? (cpp:type-bw outT) 32) cpp:max32]
            [(eq? (cpp:type-bw outT) 64) cpp:max64]))
        (maxF lhs rhs)]
       [else
        (define maxF
          (cond
            [(eq? (cpp:type-bw outT) 8) cpp:maxu8]
            [(eq? (cpp:type-bw outT) 16) cpp:maxu16]
            [(eq? (cpp:type-bw outT) 32) cpp:maxu32]
            [(eq? (cpp:type-bw outT) 64) cpp:maxu64]))
        (maxF lhs rhs)])]))

(define (do-shr lhs rhs)
  (define outT (cpp:type lhs))
  (cond
    [(cpp:signed-type? outT)
     (mk-cpp-expr (bvashr (cpp:eval lhs) (cpp:eval rhs)) outT)]
    [else
     (mk-cpp-expr (bvlshr (cpp:eval lhs) (cpp:eval rhs)) outT)]))

(define (do-shl lhs rhs)
  (define outT (cpp:type lhs))
  (mk-cpp-expr (bvshl (cpp:eval lhs) (cpp:eval rhs)) outT))

(define (do-if condition lhs rhs)
  (cond
    [(and (and (integer? lhs) (integer? rhs) (boolean? condition)))
     (if condition lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (mk-cpp-expr (if (cpp:eval condition) (cpp:eval lhs) (cpp:eval rhs)) outT)]))

(define (do-eq lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (eq? lhs rhs)]
    [(cpp:signed-expr? lhs)
     (mk-cpp-expr (bveq (cpp:eval lhs) (cpp:eval rhs)) 'uint1)]
    [else
     (mk-cpp-expr (bveq (cpp:eval lhs) (cpp:eval rhs)) 'uint1)]))

(define (do-lt lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (< lhs rhs)]
    [(cpp:signed-expr? lhs)
     (mk-cpp-expr (bvslt (cpp:eval lhs) (cpp:eval rhs)) 'uint1)]
    [else
     (mk-cpp-expr (bvult (cpp:eval lhs) (cpp:eval rhs)) 'uint1)]))

(define (do-le lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (<= lhs rhs)]
    [(cpp:signed-expr? lhs)
     (mk-cpp-expr (bvsle (cpp:eval lhs) (cpp:eval rhs)) 'uint1)]
    [else
     (mk-cpp-expr (bvule (cpp:eval lhs) (cpp:eval rhs)) 'uint1)]))

(define (do-abs lhs)
  (define outT (infer-out-type lhs lhs))
  (define zero (cpp:cast (int8_t (bv 1 8)) (cpp:type-str outT)))
  (define minus1 (cpp:cast (int8_t (bv -1 8)) (cpp:type-str outT)))
  (if (bvsge (cpp:eval lhs) (cpp:eval zero)) lhs (mk-cpp-expr (bvmul (cpp:eval lhs) (cpp:eval minus1)) outT)))

(define (do-absd lhs rhs)
  (define outT (infer-out-type lhs rhs))
  (cond
    [(cpp:signed-type? outT)
     (mk-cpp-expr (if (bvsle (cpp:eval lhs) (cpp:eval rhs)) (bvsub (cpp:eval rhs) (cpp:eval lhs)) (bvsub (cpp:eval lhs) (cpp:eval rhs))) (mk-cpp-type (cpp:type-bw outT) #f))]
    [else
     (mk-cpp-expr (if (bvule (cpp:eval lhs) (cpp:eval rhs)) (bvsub (cpp:eval rhs) (cpp:eval lhs)) (bvsub (cpp:eval lhs) (cpp:eval rhs))) (mk-cpp-type (cpp:type-bw outT) #f))]))

(define (do-clz lhs)
  (define outT (infer-out-type lhs lhs))
  (cond
    [(eq? int32_t outT) (cpp:clz32 lhs)]))

(define (do-bwand lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (bitwise-and lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (mk-cpp-expr (bvand (cpp:eval lhs) (cpp:eval rhs)) outT)]))

(define (do-reduce vec op base width)
  (define outT (cpp:type (vec 0)))
  (mk-cpp-expr
   (cond
     [(eq? width 2) (op (cpp:eval (vec base)) (cpp:eval (vec (+ base 1))))]
     [(eq? width 3) (op (cpp:eval (vec base)) (cpp:eval (vec (+ base 1))) (cpp:eval (vec (+ base 2))))]
     [(eq? width 4) (op (cpp:eval (vec base)) (cpp:eval (vec (+ base 1))) (cpp:eval (vec (+ base 2))) (cpp:eval (vec (+ base 3))))]
     [else (error "NYI: Halide vector_reduce for reduction factor of:" width)])
   outT))