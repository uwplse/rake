#lang rosette/safe

(require
  (only-in racket/base error)
  rosette/lib/destruct
  rake/cpp
  rake/halide/ir/types)

(provide
 (rename-out
  [buffer-ref halide-buffer-ref]
  [elem-type halide-elem-type]
  [vec-len halide-vec-len]
  [sub-exprs halide-sub-exprs]
  [interpret interpret-halide]))

;; Infer the length of vector generated by the expression
(define (elem-type expr)
  (define intr-expr (interpret expr))
  (cpp-type (intr-expr 0)))

;; Infer the length of vector generated by the expression
(define (vec-len expr)
  (destruct expr
    ;; Constructors
    [(x32 sca) 32]
    [(x64 sca) 64]
    [(x128 sca) 128]
    [(x256 sca) 256]
    [(x512 sca) 512]

    [(ramp base stride len) (quotient len stride)]
    [(load buf idxs alignment) (vec-len idxs)]
    [(load-sca buf idx) 1]

    ;; Type Casts
    [(uint8x1 sca) 1]
    [(uint16x1 sca) 1]
    [(uint32x1 sca) 1]
    [(uint64x1 sca) 1]
    
    [(int8x1 sca) 1]
    [(int16x1 sca) 1]
    [(int32x1 sca) 1]
    [(int64x1 sca) 1]

    [(uint1x32 vec) 32]
    [(uint1x64 vec) 64]
    [(uint1x128 vec) 128]
    [(uint1x256 vec) 256]    
   
    [(uint8x32 vec) 32]
    [(uint16x32 vec) 32]
    [(uint32x32 vec) 32]
    [(uint64x32 vec) 32]
    
    [(int8x32 vec) 32]
    [(int16x32 vec) 32]
    [(int32x32 vec) 32]
    [(int64x32 vec) 32]
    
    [(uint8x64 vec) 64]
    [(uint16x64 vec) 64]
    [(uint32x64 vec) 64]
    [(uint64x64 vec) 64]
    
    [(int8x64 vec) 64]
    [(int16x64 vec) 64]
    [(int32x64 vec) 64]
    [(int64x64 vec) 64]
    
    [(uint8x128 vec) 128]
    [(uint16x128 vec) 128]
    [(uint32x128 vec) 128]
    [(uint64x128 vec) 128]
    
    [(int8x128 vec) 128]
    [(int16x128 vec) 128]
    [(int32x128 vec) 128]
    [(int64x128 vec) 128]
    
    [(uint8x256 vec) 256]
    [(uint16x256 vec) 256]
    [(uint32x256 vec) 256]
    [(uint64x256 vec) 256]

    [(int8x256 vec) 256]
    [(int16x256 vec) 256]
    [(int32x256 vec) 256]
    [(int64x256 vec) 256]

    ;; Operations
    [(vec-add v1 v2) (vec-len v1)]
    [(vec-sub v1 v2) (vec-len v1)]
    [(vec-mul v1 v2) (vec-len v1)]
    [(vec-div v1 v2) (vec-len v1)]
    [(vec-mod v1 v2) (vec-len v1)]
    [(vec-min v1 v2) (vec-len v1)]
    [(vec-max v1 v2) (vec-len v1)]
    [(vec-if v1 v2 v3) (vec-len v2)]
    [(vec-lt v1 v2) (vec-len v1)]
    [(vec-le v1 v2) (vec-len v1)]
    
    [(vec-absd v1 v2) (vec-len v1)]
    [(vec-shl v1 v2) (vec-len v1)]
    [(vec-shr v1 v2) (vec-len v1)]

    ;; Shuffles
    [(slice_vectors vec base stride len) len]
    [(concat_vectors v1 v2) (+ (vec-len v1) (vec-len v2))]
    [(interleave v1 v2) (+ (vec-len v1) (vec-len v2))]
    [(dynamic_shuffle vec idxs st end) (vec-len idxs)]
    
    ;; Base case
    [_ (error "halide\\ir\\interpreter.rkt: Don't know how to infer vector length for Halide expression:" expr)]))

;; Get the (vector) sub-expressions
(define (sub-exprs expr)
  (destruct expr
    ;; Constructors
    [(x32 sca) (list)]
    [(x64 sca) (list)]
    [(x128 sca) (list)]
    [(x256 sca) (list)]
    [(x512 sca) (list)]

    [(ramp base stride len) (list)]
    [(load buf idxs alignment) (list)]
    [(load-sca buf idx) (list)]

    ;; Type Casts
    [(uint8x1 sca) (list)]
    [(uint16x1 sca) (list)]
    [(uint32x1 sca) (list)]
    [(uint64x1 sca) (list)]
    
    [(int8x1 sca) (list)]
    [(int16x1 sca) (list)]
    [(int32x1 sca) (list)]
    [(int64x1 sca) (list)]

    [(uint1x32 vec) (list vec)]
    [(uint1x64 vec) (list vec)]
    [(uint1x128 vec) (list vec)]
    [(uint1x256 vec) (list vec)]
   
    [(uint8x32 vec) (list vec)]
    [(uint16x32 vec) (list vec)]
    [(uint32x32 vec) (list vec)]
    [(uint64x32 vec) (list vec)]
    
    [(int8x32 vec) (list vec)]
    [(int16x32 vec) (list vec)]
    [(int32x32 vec) (list vec)]
    [(int64x32 vec) (list vec)]
    
    [(uint8x64 vec) (list vec)]
    [(uint16x64 vec) (list vec)]
    [(uint32x64 vec) (list vec)]
    [(uint64x64 vec) (list vec)]
    
    [(int8x64 vec) (list vec)]
    [(int16x64 vec) (list vec)]
    [(int32x64 vec) (list vec)]
    [(int64x64 vec) (list vec)]
    
    [(uint8x128 vec) (list vec)]
    [(uint16x128 vec) (list vec)]
    [(uint32x128 vec) (list vec)]
    [(uint64x128 vec) (list vec)]
    
    [(int8x128 vec) (list vec)]
    [(int16x128 vec) (list vec)]
    [(int32x128 vec) (list vec)]
    [(int64x128 vec) (list vec)]
    
    [(uint8x256 vec) (list vec)]
    [(uint16x256 vec) (list vec)]
    [(uint32x256 vec) (list vec)]
    [(uint64x256 vec) (list vec)]

    [(int8x256 vec) (list vec)]
    [(int16x256 vec) (list vec)]
    [(int32x256 vec) (list vec)]
    [(int64x256 vec) (list vec)]

    ;; Operations
    [(vec-add v1 v2) (list v1 v2)]
    [(vec-sub v1 v2) (list v1 v2)]
    [(vec-mul v1 v2) (list v1 v2)]
    [(vec-div v1 v2) (list v1 v2)]
    [(vec-mod v1 v2) (list v1 v2)]
    [(vec-min v1 v2) (list v1 v2)]
    [(vec-max v1 v2) (list v1 v2)]
    [(vec-if v1 v2 v3) (list v1 v2 v3)]
    [(vec-lt v1 v2) (list v1 v2)]
    [(vec-le v1 v2) (list v1 v2)]
    
    [(vec-absd v1 v2) (list v1 v2)]
    [(vec-shl v1 v2) (list v1 v2)]
    [(vec-shr v1 v2) (list v1 v2)]

    ;; Shuffles
    [(slice_vectors vec base stride len) (list vec)]
    [(concat_vectors v1 v2) (list v1 v2)]
    [(interleave v1 v2) (list v1 v2)]
    [(dynamic_shuffle vec idxs st end) (list vec idxs)]
    
    ;; Base case
    [_ (error "halide\\ir\\interpreter.rkt: Don't know how to return sub-expressions for Halide expression:" expr)]))

(define (interpret p)
  (destruct p
    ;; Constructors
    [(x32 sca) (lambda (i) (interpret sca))]
    [(x64 sca) (lambda (i) (interpret sca))]
    [(x128 sca) (lambda (i) (interpret sca))]
    [(x256 sca) (lambda (i) (interpret sca))]
    [(x512 sca) (lambda (i) (interpret sca))]

    [(ramp base stride len) (lambda (i) (+ (interpret base) (* i (interpret stride))))]
    [(load buf idxs alignment) (lambda (i) (buffer-ref (interpret buf) ((interpret idxs) i)))]
    [(load-sca buf idx) (buffer-ref (interpret buf) (interpret idx))]

    ;; Type Casts
    [(uint8x1 sca) (cpp-cast (interpret sca) 'uint8)]
    [(uint16x1 sca) (cpp-cast (interpret sca) 'uint16)]    
    [(uint32x1 sca) (cpp-cast (interpret sca) 'uint32)]
    [(uint64x1 sca) (cpp-cast (interpret sca) 'uint64)]

    [(int8x1 sca) (cpp-cast (interpret sca) 'int8)]
    [(int16x1 sca) (cpp-cast (interpret sca) 'int16)]
    [(int32x1 sca) (cpp-cast (interpret sca) 'int32)]
    [(int64x1 sca) (cpp-cast (interpret sca) 'int64)]

    ;[(uint1x32 vec) NYI: Not sure what would be casted into uint1?]
    ;[(uint1x64 vec) NYI: Not sure what would be casted into uint1?]
    ;[(uint1x128 vec) NYI: Not sure what would be casted into uint1?]
    ;[(uint1x256 vec) NYI: Not sure what would be casted into uint1?]    

    [(uint8x32 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint8))]
    [(uint8x64 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint8))]
    [(uint8x128 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint8))]
    [(uint8x256 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint8))]

    [(int8x32 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int8))]
    [(int8x64 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int8))]
    [(int8x128 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int8))]
    [(int8x256 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int8))]

    [(uint16x32 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint16))]
    [(uint16x64 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint16))]
    [(uint16x128 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint16))]
    [(uint16x256 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint16))]

    [(int16x32 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int16))]
    [(int16x64 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int16))]
    [(int16x128 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int16))]
    [(int16x256 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int16))]
    
    [(uint32x32 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint32))]
    [(uint32x64 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint32))]
    [(uint32x128 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint32))]
    [(uint32x256 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint32))]

    [(int32x32 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int32))]
    [(int32x64 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int32))]
    [(int32x128 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int32))]
    [(int32x64 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int32))]
    
    [(uint64x32 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint64))]
    [(uint64x64 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint64))]
    [(uint64x128 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint64))]
    [(uint64x256 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'uint64))]

    [(int64x32 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int64))]
    [(int64x64 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int64))]
    [(int64x128 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int64))]
    [(int64x256 vec) (lambda (i) (cpp-cast ((interpret vec) i) 'int64))]
    
    ;; Operations
    [(sca-add v1 v2) (do-add v1 v2)]
    [(sca-sub v1 v2) (do-sub v1 v2)]
    [(sca-mul v1 v2) (do-mul v1 v2)]
    [(sca-div v1 v2) (do-div v1 v2)]
    [(sca-min v1 v2) (do-min v1 v2)]
    [(sca-max v1 v2) (do-max v1 v2)]
    [(vec-add v1 v2) (lambda (i) (do-add ((interpret v1) i) ((interpret v2) i)))]
    [(vec-sub v1 v2) (lambda (i) (do-sub ((interpret v1) i) ((interpret v2) i)))]
    [(vec-mul v1 v2) (lambda (i) (do-mul ((interpret v1) i) ((interpret v2) i)))]
    [(vec-div v1 v2) (lambda (i) (do-div ((interpret v1) i) ((interpret v2) i)))]
    [(vec-mod v1 v2) (lambda (i) (do-mod ((interpret v1) i) ((interpret v2) i)))]
    [(vec-min v1 v2) (lambda (i) (do-min ((interpret v1) i) ((interpret v2) i)))]
    [(vec-max v1 v2) (lambda (i) (do-max ((interpret v1) i) ((interpret v2) i)))]
    [(vec-if v1 v2 v3) (lambda (i) (do-if ((interpret v1) i) ((interpret v2) i) ((interpret v3) i)))]
    [(vec-lt v1 v2) (lambda (i) (do-lt ((interpret v1) i) ((interpret v2) i)))]
    [(vec-le v1 v2) (lambda (i) (do-le ((interpret v1) i) ((interpret v2) i)))]        

    [(vec-shl v1 v2) (lambda (i) (do-shl ((interpret v1) i) ((interpret v2) i)))]
    [(vec-shr v1 v2) (lambda (i) (do-shr ((interpret v1) i) ((interpret v2) i)))]
    [(vec-absd v1 v2) (lambda (i) (do-absd ((interpret v1) i) ((interpret v2) i)))]

    ;; Shuffles
    [(slice_vectors vec base stride len) (lambda (i) ((interpret vec) (+ (interpret base) (* i (interpret stride)))))]
    [(concat_vectors v1 v2) (lambda (i) (if (< i (vec-len v1)) ((interpret v1) i) ((interpret v2) (- i (vec-len v1)))))]
    [(interleave v1 v2) (lambda (i) (if (even? i) ((interpret v1) (quotient i 2)) ((interpret v2) (quotient i 2))))]
    [(dynamic_shuffle vec idxs st end) (lambda (i) ((interpret vec) (+ ((interpret idxs) i) st)))]
    
    ;; Base case
    [_ p]))

(define (buffer-ref buffer idx)
  (define elemT (buffer-elemT buffer))
  (define data (buffer-data buffer))
  (cond
    [(eq? elemT 'int8) (int8_t (data idx))]
    [(eq? elemT 'int16) (int16_t (data idx))]
    [(eq? elemT 'int32) (int32_t (data idx))]
    [(eq? elemT 'int64) (int64_t (data idx))]
    [(eq? elemT 'uint8) (uint8_t (data idx))]
    [(eq? elemT 'uint16) (uint16_t (data idx))]
    [(eq? elemT 'uint32) (uint32_t (data idx))]
    [(eq? elemT 'uint64) (uint64_t (data idx))]
    [else (error "halide/ir/interpreter.rkt: Unexpected buffer type" buffer)]))

;; Model basic arithmetic
(define (infer-out-type lhs rhs)
  (define max-bw (if (> (expr-bw lhs) (expr-bw rhs)) (expr-bw lhs) (expr-bw rhs)))
  (cond
    [(and (signed-expr? lhs) (signed-expr? rhs)) (mk-cpp-type max-bw #t)]
    [(and (unsigned-expr? lhs) (unsigned-expr? rhs)) (mk-cpp-type max-bw #f)]
    [else (mk-cpp-type max-bw #t)]))

(define (do-add lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (+ lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (mk-cpp-expr (bvadd (eval lhs) (eval rhs)) outT)]))

(define (do-sub lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (- lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (mk-cpp-expr (bvsub (eval lhs) (eval rhs)) outT)]))

(define (do-mul lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (- lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (mk-cpp-expr (bvmul (eval lhs) (eval rhs)) outT)]))

(define (do-div lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (quotient lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (cond
       [(signed-type? outT)
        (define lhs64 (cpp-cast lhs 'int64))
        (define rhs64 (cpp-cast rhs 'int64))
        (define ia (eval lhs64))
        (define ib (eval rhs64))
        (define a-neg (bvashr ia (bv 63 64)))
        (define b-neg (bvashr ib (bv 63 64)))
        (define b-zero (if (bveq ib (bv 0 64)) (bv -1 64) (bv 0 64)))
        (set! ib (bvsub ib b-zero))
        (set! ia (bvsub ia a-neg))
        (define q (bvsdiv ia ib))
        (set! q (bvadd q (bvand a-neg (bvsub (bvnot b-neg) b-neg))))
        (set! q (bvand q (bvnot b-zero)))
        (cpp-cast (int64_t q) (cpp-type-str outT))]
       [else
        (mk-cpp-expr (bvudiv (eval lhs) (eval rhs)) outT)])]))

(define (do-mod lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (remainder lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (cond
       [(signed-type? outT)
        (mk-cpp-expr (bvsrem (eval lhs) (eval rhs)) outT)]
       [else
        (mk-cpp-expr (bvurem (eval lhs) (eval rhs)) outT)])]))

(define (do-min lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (min lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (cond
       [(signed-type? outT)
        (define minF (cond [(eq? (type-bw outT) 8) min8] [(eq? (type-bw outT) 16) min16] [(eq? (type-bw outT) 32) min32]))
        (minF lhs rhs)]
       [else
        (define minF (cond [(eq? (type-bw outT) 8) minu8] [(eq? (type-bw outT) 16) minu16] [(eq? (type-bw outT) 32) minu32]))
        (minF lhs rhs)])]))

(define (do-max lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (max lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (cond
       [(signed-type? outT)
        (define maxF (cond [(eq? (type-bw outT) 8) max8] [(eq? (type-bw outT) 16) max16] [(eq? (type-bw outT) 32) max32]))
        (maxF lhs rhs)]
       [else
        (define maxF (cond [(eq? (type-bw outT) 8) maxu8] [(eq? (type-bw outT) 16) maxu16] [(eq? (type-bw outT) 32) maxu32]))
        (maxF lhs rhs)])]))

(define (do-shr lhs rhs)
  (define outT (infer-out-type lhs rhs))
  (cond
    [(signed-type? outT)
     (mk-cpp-expr (bvashr (eval lhs) (eval rhs)) outT)]
    [else
     (mk-cpp-expr (bvlshr (eval lhs) (eval rhs)) outT)]))

(define (do-shl lhs rhs)
  (define outT (infer-out-type lhs rhs))
  (mk-cpp-expr (bvshl (eval lhs) (eval rhs)) outT))

(define (do-if condition lhs rhs)
  (cond
    [(and (and (integer? lhs) (integer? rhs) (boolean? condition)))
     (if condition lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (mk-cpp-expr (if (eval condition) (eval lhs) (eval rhs)) outT)]))

(define (do-lt lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (< lhs rhs)]
    [(signed-expr? lhs)
     (mk-cpp-expr (bvslt (eval lhs) (eval rhs)) 'uint1)]
    [else
     (mk-cpp-expr (bvult (eval lhs) (eval rhs)) 'uint1)]))

(define (do-le lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (<= lhs rhs)]
    [(signed-expr? lhs)
     (mk-cpp-expr (bvsle (eval lhs) (eval rhs)) 'uint1)]
    [else
     (mk-cpp-expr (bvule (eval lhs) (eval rhs)) 'uint1)]))

(define (do-absd lhs rhs)
  (define outT (infer-out-type lhs rhs))
  (cond
    [(signed-type? outT)
     (mk-cpp-expr (if (bvsle (eval lhs) (eval rhs)) (bvsub (eval rhs) (eval lhs)) (bvsub (eval lhs) (eval rhs))) outT)]
    [else
     (mk-cpp-expr (if (bvule (eval lhs) (eval rhs)) (bvsub (eval rhs) (eval lhs)) (bvsub (eval lhs) (eval rhs))) outT)]))