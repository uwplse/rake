Lifting input expression to x86 IR...
=====================================

"Building Expr:"
(load
 (buffer input 'uint8)
 (ramp (sca-add (sca-mul sum_input.s1.rc$x.rc$x 16) (var-lookup 't661)) 1 16)
 (aligned 1 0))
"Fold templates"
'()
here()

"Replace templates"
'()
"Success?"
#f
#<void>
run-x86-synthesizer
halide-expr:
  (load
 (buffer input 'uint8)
 (ramp (sca-add (sca-mul sum_input.s1.rc$x.rc$x 16) (var-lookup 't661)) 1 16)
 (aligned 1 0))
template:
  #<load-data>
axioms:
  '()
optimized-halide-expr:
  (load
 (buffer input 'uint8)
 (ramp (sca-add (sca-mul sum_input.s1.rc$x.rc$x 16) (var-lookup 't661)) 1 16)
 (aligned 1 0))
optimized-template:
  #<load-data>
optimized Halide 0:
  (uint8_t
 (app input (+ (+ -16 sum_input.s1.rc$x.rc$x) (+ t763 (- (+ t737 t762))))))
optimized x86 0:
  (uint8_t
 (app input (+ (+ -16 sum_input.s1.rc$x.rc$x) (+ t763 (- (+ t737 t762))))))
Ran synthesizer for 27 ms
(model
 [idx$0 0])
(load
 (buffer input 'uint8)
 (ramp (sca-add (sca-mul sum_input.s1.rc$x.rc$x 16) (var-lookup 't661)) 1 16)
 (aligned 1 0))
#<load-data>
Ran bounds analysis for 23 ms
Ran bounds analysis for 13 ms
"Extended success?"
#t
#<load-data>
"Building Expr:"
(vec-cast
 (load
  (buffer input 'uint8)
  (ramp (sca-add (sca-mul sum_input.s1.rc$x.rc$x 16) (var-lookup 't661)) 1 16)
  (aligned 1 0))
 'uint32
 16)
"Fold templates"
'(#<load-data>)
here(#<load-data>)

"Replace templates"
'()
run-x86-synthesizer
halide-expr:
  (vec-cast
 (load
  (buffer input 'uint8)
  (ramp (sca-add (sca-mul sum_input.s1.rc$x.rc$x 16) (var-lookup 't661)) 1 16)
  (aligned 1 0))
 'uint32
 16)
template:
  #<load-data>
axioms:
  '()
optimized-halide-expr:
  (vec-cast
 (load
  (buffer input 'uint8)
  (ramp (sca-add (sca-mul sum_input.s1.rc$x.rc$x 16) (var-lookup 't661)) 1 16)
  (aligned 1 0))
 'uint32
 16)
optimized-template:
  #<load-data>
optimized Halide 0:
  (uint32_t
 (zero-extend (app input (+ (+ -16 sum_input.s1.rc$x.rc$x) (+ t763 (- (+ t737 t762))))) (bitvector 32)))
optimized x86 0:
  (uint8_t
 (app input (+ (+ -16 sum_input.s1.rc$x.rc$x) (+ t763 (- (+ t737 t762))))))
Ran synthesizer for 1 ms
(unsat)
"Success?"
#f
#<void>
run-x86-synthesizer
halide-expr:
  (vec-cast
 (load
  (buffer input 'uint8)
  (ramp (sca-add (sca-mul sum_input.s1.rc$x.rc$x 16) (var-lookup 't661)) 1 16)
  (aligned 1 0))
 'uint32
 16)
template:
  (cast ... #<load-data> 'uint32 #f)
axioms:
  '(#t)
optimized-halide-expr:
  (vec-cast #<abstr-halide-expr> 'uint32 16)
optimized-template:
  (cast ... #<abstr-expr> 'uint32 #f)
optimized Halide 0:
  (uint32_t (zero-extend (app abstr-vals$129 0) (bitvector 32)))
optimized x86 0:
  (uint32_t (zero-extend (app abstr-vals$129 0) (bitvector 32)))
Ran synthesizer for 17 ms
(model)
(vec-cast #<abstr-halide-expr> 'uint32 16)
(cast ... #<load-data> 'uint32 #f)
Ran bounds analysis for 37 ms
Ran bounds analysis for 28 ms
"Extended success?"
#t
(cast ... #<load-data> 'uint32 #f)

(x86) Successfully found an equivalent IR expression.

(cast ... #<load-data> 'uint32 #f)

Synthesis time: 1 seconds

Synthesizing x86 for:
(vec-cast
 (load
  (buffer input 'uint8)
  (ramp (sca-add (sca-mul sum_input.s1.rc$x.rc$x 16) (var-lookup 't661)) 1 16)
  (aligned 1 0))
 'uint32
 16)


synthesize-x86 output:
#<void>
#f
