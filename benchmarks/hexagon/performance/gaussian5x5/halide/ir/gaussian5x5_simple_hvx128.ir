+ ./tmp/gaussian5x5_simple_generator -o tmp -e o,h,assembly,bitcode -g gaussian5x5 -f gaussian5x5_hvx128 target=hexagon-32-noos-no_bounds_query-no_asserts-hvx_128
assert((reinterpret(uint64, output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output"))
assert((reinterpret(uint64, input.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input"))
let input = _halide_buffer_get_host(input.buffer)
let input.min.0 = _halide_buffer_get_min(input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride(input.buffer, 0)
let input.min.1 = _halide_buffer_get_min(input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride(input.buffer, 1)
let output = _halide_buffer_get_host(output.buffer)
let output.min.0 = _halide_buffer_get_min(output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent(output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride(output.buffer, 0)
let output.min.1 = _halide_buffer_get_min(output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent(output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride(output.buffer, 1)
assert((input.stride.0 == 1), 0)
assert((input.min.0 == 0), 0)
assert(((input.stride.1 % 128) == 0), 0)
assert((input.min.1 == 0), 0)
assert((output.stride.0 == 1), 0)
assert((output.min.0 == 0), 0)
assert(((output.stride.1 % 128) == 0), 0)
assert((output.min.1 == 0), 0)
produce output {
  let t53 = (((output.extent.0 + 127)/128) - max((output.extent.0/128), 0))
  let t56 = (output.extent.0 - (input.stride.1*2))
  for<Hexagon> (output.s0.__outermost, 0, 1) {
    for (output.s0.y, 0, output.extent.1) {
      for (output.s0.x.x, 0, max((output.extent.0/128), 0)) {
        output[ramp(((output.s0.x.x*128) + (output.s0.y*output.stride.1)), 1, 128) aligned(128, 0)] = (let t103 = ((output.s0.x.x*128) + (input.stride.1*output.s0.y)) in (let t106 = (t103 - (input.stride.1*2)) in 

        halide.hexagon.trunclo.vh(
          halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b((((halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(
            halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(
              halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(
                halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(
                  halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(
                    halide.hexagon.add_2mpy.vub.vub.b.b(input[ramp(t103, 1, 128) aligned(128, 0)], input[ramp(t106, 1, 128) aligned(128, 0)], (int8)36, (int8)6), input[ramp((t103 - input.stride.1), 1, 128) aligned(128, 0)], input[ramp((input.stride.1 + t103), 1, 128) aligned(128, 0)], (int8)24, (int8)24), input[ramp((t106 + 1), 1, 128) aligned(128, 1)], input[ramp((((input.stride.1*2) + t103) + 1), 1, 128) aligned(128, 1)], (int8)4, (int8)4), input[ramp(((input.stride.1 + t103) + 1), 1, 128) aligned(128, 1)], input[ramp((t103 + 1), 1, 128) aligned(128, 1)], (int8)16, (int8)24), input[ramp((((input.stride.1*2) + t103) + -1), 1, 128) aligned(128, 127)], input[ramp(((t103 - input.stride.1) + 1), 1, 128) aligned(128, 1)], (int8)4, (int8)16), input[ramp((t103 + -1), 1, 128) aligned(128, 127)], input[ramp((t106 + -1), 1, 128) aligned(128, 127)], (int8)24, (int8)4), input[ramp(((t103 - input.stride.1) + -1), 1, 128) aligned(128, 127)], input[ramp(((input.stride.1 + t103) + -1), 1, 128) aligned(128, 127)], (int8)16, (int8)16), input[ramp((t103 + -2), 1, 128) aligned(128, 126)], input[ramp(((input.stride.1 + t103) + -2), 1, 128) aligned(128, 126)], (int8)6, (int8)4), input[ramp(((input.stride.1 + t103) + 2), 1, 128) aligned(128, 2)], input[ramp(((t103 - input.stride.1) + -2), 1, 128) aligned(128, 126)], (int8)4, (int8)4), input[ramp(((t103 - input.stride.1) + 2), 1, 128) aligned(128, 2)], input[ramp((t103 + 2), 1, 128) aligned(128, 2)], (int8)4, (int8)6) + halide.hexagon.zxt.vub(input[ramp((((input.stride.1*2) + t103) + -2), 1, 128) aligned(128, 126)])) + halide.hexagon.zxt.vub(input[ramp((t106 + 2), 1, 128) aligned(128, 2)])) + halide.hexagon.zxt.vub(input[ramp((((input.stride.1*2) + t103) + 2), 1, 128) aligned(128, 2)])), input[ramp(((input.stride.1*2) + t103), 1, 128) aligned(128, 0)], input[ramp((t106 + -2), 1, 128) aligned(128, 126)], (int8)6, (int8)1))))
      }
      for (output.s0.x.x, max((output.extent.0/128), 0), t53) {
        output[ramp((((output.s0.y*output.stride.1) + output.extent.0) + -128), 1, 128)] = (let t109 = ((input.stride.1*output.s0.y) + ((input.stride.1*2) + output.extent.0)) in halide.hexagon.trunclo.vh(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b((((halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.add_2mpy.vub.vub.b.b(input[ramp((((input.stride.1*output.s0.y) + output.extent.0) + -128), 1, 128)], input[ramp((((input.stride.1*output.s0.y) + t56) + -128), 1, 128)], (int8)36, (int8)6), input[ramp((((input.stride.1*output.s0.y) + (output.extent.0 - input.stride.1)) + -128), 1, 128)], input[ramp((((input.stride.1*output.s0.y) + (input.stride.1 + output.extent.0)) + -128), 1, 128)], (int8)24, (int8)24), input[ramp((((input.stride.1*output.s0.y) + t56) + -127), 1, 128)], input[ramp((t109 + -127), 1, 128)], (int8)4, (int8)4), input[ramp((((input.stride.1*output.s0.y) + (input.stride.1 + output.extent.0)) + -127), 1, 128)], input[ramp((((input.stride.1*output.s0.y) + output.extent.0) + -127), 1, 128)], (int8)16, (int8)24), input[ramp((t109 + -129), 1, 128)], input[ramp((((input.stride.1*output.s0.y) + (output.extent.0 - input.stride.1)) + -127), 1, 128)], (int8)4, (int8)16), input[ramp((((input.stride.1*output.s0.y) + output.extent.0) + -129), 1, 128)], input[ramp((((input.stride.1*output.s0.y) + t56) + -129), 1, 128)], (int8)24, (int8)4), input[ramp((((input.stride.1*output.s0.y) + (output.extent.0 - input.stride.1)) + -129), 1, 128)], input[ramp((((input.stride.1*output.s0.y) + (input.stride.1 + output.extent.0)) + -129), 1, 128)], (int8)16, (int8)16), input[ramp((((input.stride.1*output.s0.y) + output.extent.0) + -130), 1, 128)], input[ramp((((input.stride.1*output.s0.y) + (input.stride.1 + output.extent.0)) + -130), 1, 128)], (int8)6, (int8)4), input[ramp((((input.stride.1*output.s0.y) + (input.stride.1 + output.extent.0)) + -126), 1, 128)], input[ramp((((input.stride.1*output.s0.y) + (output.extent.0 - input.stride.1)) + -130), 1, 128)], (int8)4, (int8)4), input[ramp((((input.stride.1*output.s0.y) + (output.extent.0 - input.stride.1)) + -126), 1, 128)], input[ramp((((input.stride.1*output.s0.y) + output.extent.0) + -126), 1, 128)], (int8)4, (int8)6) + halide.hexagon.zxt.vub(input[ramp((t109 + -130), 1, 128)])) + halide.hexagon.zxt.vub(input[ramp((((input.stride.1*output.s0.y) + t56) + -126), 1, 128)])) + halide.hexagon.zxt.vub(input[ramp((t109 + -126), 1, 128)])), input[ramp((t109 + -128), 1, 128)], input[ramp((((input.stride.1*output.s0.y) + t56) + -130), 1, 128)], (int8)6, (int8)1)))
      }
    }
  }
}

