+ ./tmp/gaussian5x5_simple_generator -o tmp -e o,h,assembly,bitcode -g gaussian5x5 -f gaussian5x5_hvx128 target=hexagon-32-noos-no_bounds_query-no_asserts-hvx_128
assert((reinterpret(uint64, output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output"))
assert((reinterpret(uint64, input.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input"))
let input = _halide_buffer_get_host(input.buffer)
let input.min.0 = _halide_buffer_get_min(input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent(input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride(input.buffer, 0)
let input.min.1 = _halide_buffer_get_min(input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent(input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride(input.buffer, 1)
let output = _halide_buffer_get_host(output.buffer)
let output.min.0 = _halide_buffer_get_min(output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent(output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride(output.buffer, 0)
let output.min.1 = _halide_buffer_get_min(output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent(output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride(output.buffer, 1)
assert((input.stride.0 == 1), 0)
assert((input.min.0 == 0), 0)
assert(((input.stride.1 % 128) == 0), 0)
assert((input.min.1 == 0), 0)
assert((output.stride.0 == 1), 0)
assert((output.min.0 == 0), 0)
assert(((output.stride.1 % 128) == 0), 0)
assert((output.min.1 == 0), 0)
produce output {
  let t56.s = min(((((output.extent.0 + 127)/128)*128) + 126), input.extent.0)
  let t44 = (max(t56.s, 1) <= input.extent.0)
  let t48 = (-128 < output.extent.0)
  let t47 = max(min(((output.extent.0 + 255)/128), 1), ((min((output.extent.0 + 253), input.extent.0) + 2)/128))
  for<Hexagon> (output.s0.__outermost, 0, 1) {
    for (output.s0.y, 0, output.extent.1) {
      let bounded_input.s0.y.max_1.s = min((output.s0.y + 2), input.extent.1)
      let bounded_input.s0.y.min_1.s = min((output.s0.y + -2), input.extent.1)
      if ((((max(bounded_input.s0.y.max_1.s, 0) + 1) <= input.extent.1) && t44)) {
        prefetch(input, (max(bounded_input.s0.y.min_1.s, 0)*input.stride.1), max(t56.s, 1), 1, ((max(min((output.s0.y + 2), input.extent.1), 0) - max(min((output.s0.y + -2), input.extent.1), 0)) + 1), input.stride.1)
      }
      let bounded_input.y.extent_realized.s = (max(bounded_input.s0.y.max_1.s, 0) - max(bounded_input.s0.y.min_1.s, 0))
      allocate bounded_input[uint8 * (((output.extent.0 + 255)/128)*128) * (bounded_input.y.extent_realized.s + 1)]
      let bounded_input.s0.y.loop_extent.s = (max(bounded_input.s0.y.max_1.s, 0) - max(bounded_input.s0.y.min_1.s, 0))
      produce bounded_input {
        for (bounded_input.s0.y, max(bounded_input.s0.y.min_1.s, 0), (bounded_input.s0.y.loop_extent.s + 1)) {
          if (t48) {
            bounded_input[ramp(((((output.extent.0 + 255)/128)*(bounded_input.s0.y - max(bounded_input.s0.y.min_1.s, 0)))*128), 1, 128) aligned(128, 0)] = dynamic_shuffle(input[ramp((bounded_input.s0.y*input.stride.1), 1, 128) aligned(128, 0)], halide.hexagon.pack.vh(halide.hexagon.pack.vw(max(min(ramp(-2, 1, 128), x128((input.extent.0 + -1))), x128(0)))), 0, 127)
          }
          let t87 = (((output.extent.0 + 255)/128)*(bounded_input.s0.y - max(bounded_input.s0.y.min_1.s, 0)))
          let t64 = (t47 - min(((output.extent.0 + 255)/128), 1))
          for (bounded_input.s0.x.x, min(((output.extent.0 + 255)/128), 1), t64) {
            bounded_input[ramp(((bounded_input.s0.x.x + t87)*128), 1, 128) aligned(128, 0)] = input[ramp((((bounded_input.s0.x.x*128) + (bounded_input.s0.y*input.stride.1)) + -2), 1, 128) aligned(128, 126)]
          }
          for (bounded_input.s0.x.x, t47, (((output.extent.0 + 255)/128) - t47)) {
            bounded_input[ramp(((bounded_input.s0.x.x + t87)*128), 1, 128) aligned(128, 0)] = (let t80.s = (max(min((bounded_input.s0.x.x*128), (input.extent.0 + 1)), 2) + (bounded_input.s0.y*input.stride.1)) in dynamic_shuffle(input[ramp((t80.s + -2), 1, 128)], halide.hexagon.pack.vh(halide.hexagon.pack.vw(((max(min(ramp(((bounded_input.s0.x.x*128) + -2), 1, 128), x128((input.extent.0 + -1))), x128(0)) + x128((bounded_input.s0.y*input.stride.1))) - x128((t80.s + -2))))), 0, 127))
          }
        }
      }
      allocate rows[int16 * (((output.extent.0 + 255)/128)*128) * 1]
      produce rows {
        consume bounded_input {
          let t71.s = min((output.s0.y + 1), input.extent.1)
          let t73.s = min((output.s0.y + -1), input.extent.1)
          let t72.s = min(input.extent.1, output.s0.y)
          for (rows.s0.x.x, 0, ((output.extent.0 + 255)/128)) {
            rows[ramp((rows.s0.x.x*128), 1, 128) aligned(128, 0)] = halide.hexagon.interleave.vh(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.zxt.vub(bounded_input[ramp((((((output.extent.0 + 255)/128)*(max(bounded_input.s0.y.max_1.s, 0) - max(bounded_input.s0.y.min_1.s, 0))) + rows.s0.x.x)*128), 1, 128) aligned(128, 0)]), bounded_input[ramp((((((output.extent.0 + 255)/128)*(max(t73.s, 0) - max(bounded_input.s0.y.min_1.s, 0))) + rows.s0.x.x)*128), 1, 128) aligned(128, 0)], bounded_input[ramp((((((output.extent.0 + 255)/128)*(max(t71.s, 0) - max(bounded_input.s0.y.min_1.s, 0))) + rows.s0.x.x)*128), 1, 128) aligned(128, 0)], (int8)4, (int8)4), bounded_input[ramp((((((output.extent.0 + 255)/128)*(max(t72.s, 0) - max(bounded_input.s0.y.min_1.s, 0))) + rows.s0.x.x)*128), 1, 128) aligned(128, 0)], bounded_input[ramp((rows.s0.x.x*128), 1, 128) aligned(128, 0)], (int8)6, (int8)1))
          }
        }
      }
      free bounded_input
      consume rows {
        if ((0 < output.extent.0)) {
          allocate c2[int16 * 128] in Stack
          c2[ramp(0, 1, 64)] = rows[ramp(0, 1, 64)]
          for (output.s0.x.x, 0, ((output.extent.0 + 127)/128)) {
            c2[ramp(64, 1, 64)] = rows[ramp(((output.s0.x.x*128) + 128), 1, 64) aligned(128, 0)]
            output[ramp(((output.s0.x.x*128) + (output.s0.y*output.stride.1)), 1, 128) aligned(128, 0)] = (let t84 = rows[ramp(((output.s0.x.x*128) + 64), 1, 64) aligned(128, 64)] in (let t85.s = c2[ramp(0, 1, 64)] in (let t86.s = c2[ramp(64, 1, 64)] in halide.hexagon.packhi.vh(halide.hexagon.add_mul.vh.vh.b((concat_vectors(t85.s, t84) + halide.hexagon.add_mul.vh.vh.b(halide.hexagon.add_mul.vh.vh.b(concat_vectors(slice_vectors(concat_vectors(t85.s, t84), 4, 1, 64), slice_vectors(concat_vectors(t84, t86.s), 4, 1, 64)), concat_vectors(slice_vectors(concat_vectors(t85.s, t84), 3, 1, 64), slice_vectors(concat_vectors(t84, t86.s), 3, 1, 64)), (int8)4), concat_vectors(slice_vectors(concat_vectors(t85.s, t84), 2, 1, 64), slice_vectors(concat_vectors(t84, t86.s), 2, 1, 64)), (int8)6)), concat_vectors(slice_vectors(concat_vectors(t85.s, t84), 1, 1, 64), slice_vectors(concat_vectors(t84, t86.s), 1, 1, 64)), (int8)4)))))
            c2[ramp(0, 1, 64)] = c2[ramp(64, 1, 64)]
          }
        }
      }
      free rows
    }
  }
}

