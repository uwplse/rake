+ ./tmp/gaussian3x3_generator -o tmp -e o,h,assembly,bitcode -g gaussian3x3 -f gaussian3x3_hvx64 target=hexagon-32-noos-no_bounds_query-no_asserts-hvx_64
assert((reinterpret(uint64, output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output"))
assert((reinterpret(uint64, input.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input"))
let input = _halide_buffer_get_host(input.buffer)
let input.min.0 = _halide_buffer_get_min(input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride(input.buffer, 0)
let input.min.1 = _halide_buffer_get_min(input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride(input.buffer, 1)
let output = _halide_buffer_get_host(output.buffer)
let output.min.0 = _halide_buffer_get_min(output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent(output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride(output.buffer, 0)
let output.min.1 = _halide_buffer_get_min(output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent(output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride(output.buffer, 1)
assert((input.stride.0 == 1), 0)
assert((input.min.0 == 0), 0)
assert(((input.stride.1 % 64) == 0), 0)
assert((input.min.1 == 0), 0)
assert((output.stride.0 == 1), 0)
assert((output.min.0 == 0), 0)
assert(((output.stride.1 % 64) == 0), 0)
assert((output.min.1 == 0), 0)
produce output {
  for<Hexagon> (output.s0.__outermost, 0, 1) {
    for (output.s0.y.y, 0, ((output.extent.1 + 3)/4)) {
      prefetch(input, ((((input.stride.1*output.s0.y.y)*4) + (input.stride.1*7)) + -1), ((((output.extent.0 + 63)/64)*64) + 64), 1, 6, input.stride.1)
      for (output.s0.y.yi, 0, 4) {
        allocate rows[int16 * (((output.extent.0 + 127)/64)*64) * 1]
        produce rows {
          for (rows.s0.x.x, 0, ((output.extent.0 + 127)/64)) {
            rows[ramp((rows.s0.x.x*64), 1, 64) aligned(64, 0)] = halide.hexagon.interleave.vh((let t40 = ((rows.s0.x.x*64) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) in halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.zxt.vub(input[ramp(((input.stride.1 + t40) + -1), 1, 64) aligned(64, 63)]), input[ramp((t40 + -1), 1, 64) aligned(64, 63)], input[ramp(((t40 - input.stride.1) + -1), 1, 64) aligned(64, 63)], (int8)2, (int8)1)))
          }
        }
        consume rows {
          if ((0 < output.extent.0)) {
            allocate c1[int16 * 64] in Stack
            c1[ramp(0, 1, 32)] = rows[ramp(0, 1, 32)]
            for (output.s0.x.x, 0, ((output.extent.0 + 63)/64)) {
              c1[ramp(32, 1, 32)] = rows[ramp(((output.s0.x.x*64) + 64), 1, 32) aligned(64, 0)]
              output[ramp(((output.s0.x.x*64) + (((output.s0.y.y*4) + output.s0.y.yi)*output.stride.1)), 1, 64) aligned(64, 0)] = (let t45 = rows[ramp(((output.s0.x.x*64) + 32), 1, 32) aligned(64, 32)] in (let t46.s = c1[ramp(0, 1, 32)] in (let t47.s = c1[ramp(32, 1, 32)] in (let t48 = concat_vectors(slice_vectors(concat_vectors(t46.s, t45), 1, 1, 32), slice_vectors(concat_vectors(t45, t47.s), 1, 1, 32)) in halide.hexagon.pack.vh((halide.hexagon.add_mul.vh.vh.b((concat_vectors(slice_vectors(concat_vectors(t46.s, t45), 2, 1, 32), slice_vectors(concat_vectors(t45, t47.s), 2, 1, 32)) + concat_vectors(t46.s, t45)), t48, (int8)2)/t48))))))
              c1[ramp(0, 1, 32)] = c1[ramp(32, 1, 32)]
            }
          }
        }
        free rows
      }
    }
  }
}

