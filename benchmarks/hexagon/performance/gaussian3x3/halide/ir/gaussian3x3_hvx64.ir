+ ./tmp/gaussian3x3_generator -o tmp -e o,h,assembly,bitcode -g gaussian3x3 -f gaussian3x3_hvx64 target=hexagon-32-noos-no_bounds_query-no_asserts-hvx_64
assert((reinterpret(uint64, output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output"))
assert((reinterpret(uint64, input.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input"))
let input = _halide_buffer_get_host(input.buffer)
let input.min.0 = _halide_buffer_get_min(input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride(input.buffer, 0)
let input.min.1 = _halide_buffer_get_min(input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride(input.buffer, 1)
let output = _halide_buffer_get_host(output.buffer)
let output.min.0 = _halide_buffer_get_min(output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent(output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride(output.buffer, 0)
let output.min.1 = _halide_buffer_get_min(output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent(output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride(output.buffer, 1)
assert((input.stride.0 == 1), 0)
assert((input.min.0 == 0), 0)
assert(((input.stride.1 % 64) == 0), 0)
assert((input.min.1 == 0), 0)
assert((output.stride.0 == 1), 0)
assert((output.min.0 == 0), 0)
assert(((output.stride.1 % 64) == 0), 0)
assert((output.min.1 == 0), 0)
produce output {
  for<Hexagon> (output.s0.__outermost, 0, 1) {
    for (output.s0.y.y, 0, ((output.extent.1 + 3)/4)) {
      prefetch(input, ((((input.stride.1*output.s0.y.y)*4) + (input.stride.1*7)) + -1), ((((output.extent.0 + -1)/64)*64) + 66), 1, 6, input.stride.1)
      for (output.s0.x.x, 0, ((output.extent.0 + 63)/64)) {
        for (output.s0.y.yi, 0, 4) {
          output[ramp(((((output.s0.y.y*4) + output.s0.y.yi)*output.stride.1) + (output.s0.x.x*64)), 1, 64) aligned(64, 0)] = (let t40 = ((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + (output.s0.x.x*64)) in halide.hexagon.trunc.vh((halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(((((halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.add_2mpy.vub.vub.b.b(input[ramp((t40 - input.stride.1), 1, 64) aligned(64, 0)], input[ramp((input.stride.1 + t40), 1, 64) aligned(64, 0)], (int8)2, (int8)2), input[ramp(t40, 1, 64) aligned(64, 0)], input[ramp((t40 + 1), 1, 64) aligned(64, 1)], (int8)4, (int8)2) + halide.hexagon.zxt.vub(input[ramp(((input.stride.1 + t40) + -1), 1, 64) aligned(64, 63)])) + halide.hexagon.zxt.vub(input[ramp(((t40 - input.stride.1) + 1), 1, 64) aligned(64, 1)])) + halide.hexagon.zxt.vub(input[ramp(((input.stride.1 + t40) + 1), 1, 64) aligned(64, 1)])) + x64((int16)8)), input[ramp((t40 + -1), 1, 64) aligned(64, 63)], input[ramp(((t40 - input.stride.1) + -1), 1, 64) aligned(64, 63)], (int8)2, (int8)1)/x64((int16)16))))
        }
      }
    }
  }
}

