+ ./tmp/gaussian5x5_generator -o tmp -e o,h,assembly,bitcode -g gaussian5x5 -f gaussian5x5_hvx128 target=hexagon-32-noos-no_bounds_query-no_asserts-hvx_128
assert((reinterpret(uint64, output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output"))
assert((reinterpret(uint64, input.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input"))
let input = _halide_buffer_get_host(input.buffer)
let input.min.0 = _halide_buffer_get_min(input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride(input.buffer, 0)
let input.min.1 = _halide_buffer_get_min(input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride(input.buffer, 1)
let output = _halide_buffer_get_host(output.buffer)
let output.min.0 = _halide_buffer_get_min(output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent(output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride(output.buffer, 0)
let output.min.1 = _halide_buffer_get_min(output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent(output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride(output.buffer, 1)
assert((input.stride.0 == 1), 0)
assert((input.min.0 == 0), 0)
assert(((input.stride.1 % 128) == 0), 0)
assert((input.min.1 == 0), 0)
assert((output.stride.0 == 1), 0)
assert((output.min.0 == 0), 0)
assert(((output.stride.1 % 128) == 0), 0)
assert((output.min.1 == 0), 0)
allocate input_16[int16 * (((output.extent.0 + 255)/128)*128) * 8]
allocate rows[int16 * (((output.extent.0 + 255)/128)*128) * 4]
produce output {
  for<Hexagon> (output.s0.__outermost, 0, 1) {
    for (output.s0.y.y, 0, ((output.extent.1 + 3)/4)) {
      let input_16.s0.y.min_1 = (select((0 < output.s0.y.y), 2, -2) + (output.s0.y.y*4))
      produce input_16 {
        let t151 = select((0 < output.s0.y.y), 4, 8)
        for (input_16.s0.y, input_16.s0.y.min_1, t151) {
          let t153 = (((output.extent.0 + 255)/128)*(input_16.s0.y % 8))
          for (input_16.s0.x.x, 0, ((output.extent.0 + 255)/128)) {
            input_16[ramp(((input_16.s0.x.x + t153)*128), 1, 128) aligned(128, 0)] = halide.hexagon.zxt.vub(input[ramp((((input_16.s0.x.x*128) + (input.stride.1*input_16.s0.y)) + -2), 1, 128) aligned(128, 126)])
          }
        }
      }
      produce rows {
        consume input_16 {
          for (rows.s0.y, (output.s0.y.y*4), 4) {
            let t159 = (((output.extent.0 + 255)/128)*((rows.s0.y + 7) % 8))
            let t158 = (((output.extent.0 + 255)/128)*((rows.s0.y + 6) % 8))
            let t155 = (((output.extent.0 + 255)/128)*((rows.s0.y + 2) % 8))
            let t156 = (((output.extent.0 + 255)/128)*((rows.s0.y + 1) % 8))
            let t157 = (((output.extent.0 + 255)/128)*(rows.s0.y % 8))
            let t160 = (((output.extent.0 + 255)/128)*(rows.s0.y % 4))
            for (rows.s0.x.x, 0, ((output.extent.0 + 255)/128)) {
              rows[ramp(((rows.s0.x.x + t160)*128), 1, 128) aligned(128, 0)] = halide.hexagon.interleave.vh(halide.hexagon.add_mul.vh.vh.b((input_16[ramp(((rows.s0.x.x + t158)*128), 1, 128) aligned(128, 0)] + halide.hexagon.add_mul.vh.vh.b(halide.hexagon.add_mul.vh.vh.b(input_16[ramp(((rows.s0.x.x + t155)*128), 1, 128) aligned(128, 0)], input_16[ramp(((rows.s0.x.x + t156)*128), 1, 128) aligned(128, 0)], (int8)4), input_16[ramp(((rows.s0.x.x + t157)*128), 1, 128) aligned(128, 0)], (int8)6)), input_16[ramp(((rows.s0.x.x + t159)*128), 1, 128) aligned(128, 0)], (int8)4))
            }
          }
        }
      }
      consume rows {
        for (output.s0.y.yi, 0, 4) {
          if ((0 < output.extent.0)) {
            allocate c1[int16 * 128] in Stack
            c1[ramp(0, 1, 64)] = rows[ramp(((((output.extent.0 + 255)/128)*output.s0.y.yi)*128), 1, 64) aligned(128, 0)]
            for (output.s0.x.x, 0, ((output.extent.0 + 127)/128)) {
              c1[ramp(64, 1, 64)] = rows[ramp(((((((output.extent.0 + 255)/128)*output.s0.y.yi) + output.s0.x.x)*128) + 128), 1, 64) aligned(128, 0)]
              output[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + output.s0.y.yi)*output.stride.1)), 1, 128) aligned(128, 0)] = (let t173 = rows[ramp(((((((output.extent.0 + 255)/128)*output.s0.y.yi) + output.s0.x.x)*128) + 64), 1, 64) aligned(128, 64)] in (let t174.s = c1[ramp(0, 1, 64)] in (let t175.s = c1[ramp(64, 1, 64)] in halide.hexagon.packhi.vh(halide.hexagon.add_mul.vh.vh.b((concat_vectors(t174.s, t173) + halide.hexagon.add_mul.vh.vh.b(halide.hexagon.add_mul.vh.vh.b(concat_vectors(slice_vectors(concat_vectors(t174.s, t173), 4, 1, 64), slice_vectors(concat_vectors(t173, t175.s), 4, 1, 64)), concat_vectors(slice_vectors(concat_vectors(t174.s, t173), 3, 1, 64), slice_vectors(concat_vectors(t173, t175.s), 3, 1, 64)), (int8)4), concat_vectors(slice_vectors(concat_vectors(t174.s, t173), 2, 1, 64), slice_vectors(concat_vectors(t173, t175.s), 2, 1, 64)), (int8)6)), concat_vectors(slice_vectors(concat_vectors(t174.s, t173), 1, 1, 64), slice_vectors(concat_vectors(t173, t175.s), 1, 1, 64)), (int8)4)))))
              c1[ramp(0, 1, 64)] = c1[ramp(64, 1, 64)]
            }
          }
        }
      }
    }
  }
}
free input_16
free rows

