+ ./tmp/gaussian5x5_generator -o tmp -e o,h,assembly,bitcode -g gaussian5x5 -f gaussian5x5_hvx128 target=hexagon-32-noos-no_bounds_query-no_asserts-hvx_128
assert((reinterpret(uint64, output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output"))
assert((reinterpret(uint64, input.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input"))
let input = _halide_buffer_get_host(input.buffer)
let input.min.0 = _halide_buffer_get_min(input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent(input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride(input.buffer, 0)
let input.min.1 = _halide_buffer_get_min(input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent(input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride(input.buffer, 1)
let output = _halide_buffer_get_host(output.buffer)
let output.min.0 = _halide_buffer_get_min(output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent(output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride(output.buffer, 0)
let output.min.1 = _halide_buffer_get_min(output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent(output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride(output.buffer, 1)
assert((input.stride.0 == 1), 0)
assert((input.min.0 == 0), 0)
assert(((input.stride.1 % 128) == 0), 0)
assert((input.min.1 == 0), 0)
assert((output.stride.0 == 1), 0)
assert((output.min.0 == 0), 0)
assert(((output.stride.1 % 128) == 0), 0)
assert((output.min.1 == 0), 0)
let bounded_input.y.extent_realized.s = min(((((output.extent.1 + -1)/4)*4) + 6), input.extent.1)
allocate bounded_input[uint8 * (((output.extent.0 + 255)/128)*128) * max(bounded_input.y.extent_realized.s, 1)]
allocate rows[int16 * (((output.extent.0 + 255)/128)*128) * 4]
produce output {
  let t255.s = min(((((output.extent.0 + 127)/128)*128) + 126), input.extent.0)
  let t243 = (max(t255.s, 1) <= input.extent.0)
  let t246 = (-128 < output.extent.0)
  let t245 = max(min(((output.extent.0 + 255)/128), 1), ((min((output.extent.0 + 253), input.extent.0) + 2)/128))
  for<Hexagon> (output.s0.__outermost, 0, 1) {
    for (output.s0.y.y, 0, ((output.extent.1 + 3)/4)) {
      let bounded_input.s0.y.max_1.s = min(((output.s0.y.y*4) + 6), input.extent.1)
      let bounded_input.s0.y.min_1 = (let t289.s = min(((output.s0.y.y*4) + 2), input.extent.1) in select((0 < output.s0.y.y), max(t289.s, 1), min(min(max(min((output.s0.y.y*4), (input.extent.1 + -1)), 0), (min(max(min((output.s0.y.y*4), (input.extent.1 + 1)), 2), (max(min((output.s0.y.y*4), input.extent.1), 1) + 1)) + -2)), (max(t289.s, 1) + -1))))
      if (((max(bounded_input.s0.y.max_1.s, 1) <= input.extent.1) && t243)) {
        let t233.s = min(((output.s0.y.y*4) + 2), input.extent.1)
        prefetch(input, (bounded_input.s0.y.min_1*input.stride.1), max(t255.s, 1), 1, (max(min(((output.s0.y.y*4) + 6), input.extent.1), 1) - select((0 < output.s0.y.y), max(t233.s, 1), min(min(max(min((output.s0.y.y*4), (input.extent.1 + -1)), 0), (min(max(min((output.s0.y.y*4), (input.extent.1 + 1)), 2), (max(min((output.s0.y.y*4), input.extent.1), 1) + 1)) + -2)), (max(t233.s, 1) + -1)))), input.stride.1)
      }
      produce bounded_input {
        let t265.s = min(((output.s0.y.y*4) + 2), input.extent.1)
        let t261 = (max(min(((output.s0.y.y*4) + 6), input.extent.1), 1) - select((0 < output.s0.y.y), max(t265.s, 1), min(min(max(min((output.s0.y.y*4), (input.extent.1 + -1)), 0), (min(max(min((output.s0.y.y*4), (input.extent.1 + 1)), 2), (max(min((output.s0.y.y*4), input.extent.1), 1) + 1)) + -2)), (max(t265.s, 1) + -1))))
        for (bounded_input.s0.y, bounded_input.s0.y.min_1, t261) {
          if (t246) {
            bounded_input[ramp(((((output.extent.0 + 255)/128)*bounded_input.s0.y)*128), 1, 128) aligned(128, 0)] = dynamic_shuffle(input[ramp((bounded_input.s0.y*input.stride.1), 1, 128) aligned(128, 0)], halide.hexagon.pack.vh(halide.hexagon.pack.vw(max(min(ramp(-2, 1, 128), x128((input.extent.0 + -1))), x128(0)))), 0, 127)
          }
          let t266 = (t245 - min(((output.extent.0 + 255)/128), 1))
          for (bounded_input.s0.x.x, min(((output.extent.0 + 255)/128), 1), t266) {
            bounded_input[ramp((((((output.extent.0 + 255)/128)*bounded_input.s0.y) + bounded_input.s0.x.x)*128), 1, 128) aligned(128, 0)] = input[ramp((((bounded_input.s0.x.x*128) + (bounded_input.s0.y*input.stride.1)) + -2), 1, 128) aligned(128, 126)]
          }
          for (bounded_input.s0.x.x, t245, (((output.extent.0 + 255)/128) - t245)) {
            bounded_input[ramp((((((output.extent.0 + 255)/128)*bounded_input.s0.y) + bounded_input.s0.x.x)*128), 1, 128) aligned(128, 0)] = (let t291.s = (max(min((bounded_input.s0.x.x*128), (input.extent.0 + 1)), 2) + (bounded_input.s0.y*input.stride.1)) in dynamic_shuffle(input[ramp((t291.s + -2), 1, 128)], halide.hexagon.pack.vh(halide.hexagon.pack.vw(((max(min(ramp(((bounded_input.s0.x.x*128) + -2), 1, 128), x128((input.extent.0 + -1))), x128(0)) + x128((bounded_input.s0.y*input.stride.1))) - x128((t291.s + -2))))), 0, 127))
          }
        }
      }
      produce rows {
        consume bounded_input {
          for (rows.s0.y, (output.s0.y.y*4), 4) {
            let t277 = (max(min((input.extent.1 + -1), rows.s0.y), 0)*((output.extent.0 + 255)/128))
            let t281 = (((output.extent.0 + 255)/128)*(rows.s0.y % 4))
            let t280 = (((output.extent.0 + 255)/128)*(max(min((rows.s0.y + 3), input.extent.1), 1) + -1))
            let t276 = (((output.extent.0 + 255)/128)*(max(min((rows.s0.y + 2), input.extent.1), 1) + -1))
            let t279 = (((output.extent.0 + 255)/128)*(max(min((input.extent.1 + 1), rows.s0.y), 2) + -2))
            let t278 = (((output.extent.0 + 255)/128)*(max(min(input.extent.1, rows.s0.y), 1) + -1))
            for (rows.s0.x.x, 0, ((output.extent.0 + 255)/128)) {
              rows[ramp(((rows.s0.x.x + t281)*128), 1, 128) aligned(128, 0)] = halide.hexagon.interleave.vh(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(halide.hexagon.zxt.vub(bounded_input[ramp(((rows.s0.x.x + t280)*128), 1, 128) aligned(128, 0)]), bounded_input[ramp(((rows.s0.x.x + t278)*128), 1, 128) aligned(128, 0)], bounded_input[ramp(((rows.s0.x.x + t276)*128), 1, 128) aligned(128, 0)], (int8)4, (int8)4), bounded_input[ramp(((rows.s0.x.x + t277)*128), 1, 128) aligned(128, 0)], bounded_input[ramp(((rows.s0.x.x + t279)*128), 1, 128) aligned(128, 0)], (int8)6, (int8)1))
            }
          }
        }
      }
      consume rows {
        for (output.s0.y.yi, 0, 4) {
          if ((0 < output.extent.0)) {
            allocate c2[int16 * 128] in Stack
            c2[ramp(0, 1, 64)] = rows[ramp(((((output.extent.0 + 255)/128)*output.s0.y.yi)*128), 1, 64) aligned(128, 0)]
            for (output.s0.x.x, 0, ((output.extent.0 + 127)/128)) {
              c2[ramp(64, 1, 64)] = rows[ramp(((((((output.extent.0 + 255)/128)*output.s0.y.yi) + output.s0.x.x)*128) + 128), 1, 64) aligned(128, 0)]
              output[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + output.s0.y.yi)*output.stride.1)), 1, 128) aligned(128, 0)] = (let t296 = rows[ramp(((((((output.extent.0 + 255)/128)*output.s0.y.yi) + output.s0.x.x)*128) + 64), 1, 64) aligned(128, 64)] in (let t297.s = c2[ramp(0, 1, 64)] in (let t298.s = c2[ramp(64, 1, 64)] in halide.hexagon.packhi.vh(halide.hexagon.add_mul.vh.vh.b((concat_vectors(t297.s, t296) + halide.hexagon.add_mul.vh.vh.b(halide.hexagon.add_mul.vh.vh.b(concat_vectors(slice_vectors(concat_vectors(t297.s, t296), 4, 1, 64), slice_vectors(concat_vectors(t296, t298.s), 4, 1, 64)), concat_vectors(slice_vectors(concat_vectors(t297.s, t296), 3, 1, 64), slice_vectors(concat_vectors(t296, t298.s), 3, 1, 64)), (int8)4), concat_vectors(slice_vectors(concat_vectors(t297.s, t296), 2, 1, 64), slice_vectors(concat_vectors(t296, t298.s), 2, 1, 64)), (int8)6)), concat_vectors(slice_vectors(concat_vectors(t297.s, t296), 1, 1, 64), slice_vectors(concat_vectors(t296, t298.s), 1, 1, 64)), (int8)4)))))
              c2[ramp(0, 1, 64)] = c2[ramp(64, 1, 64)]
            }
          }
        }
      }
    }
  }
}
free bounded_input
free rows

