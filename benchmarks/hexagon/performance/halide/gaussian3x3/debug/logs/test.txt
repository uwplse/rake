g++ --std=c++11 -DLOG2VLEN=7 -I /home/maaz/Software/Halide-10.0.0/distrib/include -I ALIDE_ROOT/tools -fno-rtti -O3 -g src/gaussian3x3_generator.cpp /home/maaz/Software/Halide-10.0.0/distrib/tools/GenGen.cpp -o bin/gaussian3x3_generator -L /home/maaz/Software/Halide-10.0.0/distrib/lib -lHalide -ldl -lpthread
export LD_LIBRARY_PATH=/home/maaz/Software/Halide-10.0.0/distrib/lib; ./bin/gaussian3x3_generator -o bin -g gaussian3x3 -e o,h,assembly,bitcode -f gaussian3x3_hvx128 target=hexagon-32-noos-no_bounds_query-hvx_128
Section: 
Section: .interp
Section: .note.ABI-tag
Section: .note.gnu.build-id
Section: .gnu.hash
Section: .dynsym
Section: .dynstr
Section: .gnu.version
Section: .gnu.version_r
Section: .rela.dyn
Section: .rela.plt
Section: .init
Section: .plt
Section: .plt.got
Section: .text
Section: .fini
Section: .rodata
Section: .eh_frame_hdr
Section: .eh_frame
Section: .gcc_except_table
Section: .init_array
Section: .fini_array
Section: .data.rel.ro
Section: .dynamic
Section: .got
Section: .data
Section: .bss
Section: .comment
Section: .debug_aranges
Section: .debug_info
Section: .debug_abbrev
Section: .debug_line
Section: .debug_str
Section: .debug_loc
Section: .debug_ranges
Section: .symtab
Section: .strtab
Section: .shstrtab
Generator gaussian3x3 has base_path bin/gaussian3x3_hvx128
compile_multitarget: single target is hexagon-32-noos-hvx_128-no_bounds_query
Creating initial loop nests...
Injecting realization of { output }
for (.__root, 0, 1) {
 produce output {
  let output.s0.y.loop_max = output.s0.y.max
  let output.s0.y.loop_min = output.s0.y.min
  let output.s0.y.loop_extent = (output.s0.y.max + 1) - output.s0.y.min
  let output.s0.x.loop_max = output.s0.x.max
  let output.s0.x.loop_min = output.s0.x.min
  let output.s0.x.loop_extent = (output.s0.x.max + 1) - output.s0.x.min
  let output.s0.__outermost.loop_extent = 1
  let output.s0.__outermost.loop_max = 0
  let output.s0.__outermost.loop_min = 0
  let output.s0.x.x.loop_extent = ((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128
  let output.s0.x.x.loop_max = (((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128) - 1
  let output.s0.x.x.loop_min = 0
  let output.s0.x.xi.loop_extent = 128
  let output.s0.x.xi.loop_max = 128 - 1
  let output.s0.x.xi.loop_min = 0
  let output.s0.y.y.loop_extent = ((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4
  let output.s0.y.y.loop_max = (((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4) - 1
  let output.s0.y.y.loop_min = 0
  let output.s0.y.yi.loop_extent = 4
  let output.s0.y.yi.loop_max = 4 - 1
  let output.s0.y.yi.loop_min = 0
  for<Hexagon> (output.s0.__outermost, output.s0.__outermost.loop_min, output.s0.__outermost.loop_extent) {
   for (output.s0.y.y, output.s0.y.y.loop_min, output.s0.y.y.loop_extent) {
    prefetch input()
    let output.s0.y.yi.base = (output.s0.y.y*4) + output.s0.y.loop_min
    for (output.s0.x.x, output.s0.x.x.loop_min, output.s0.x.x.loop_extent) {
     let output.s0.x.xi.base = (output.s0.x.x*128) + output.s0.x.loop_min
     unrolled (output.s0.y.yi, output.s0.y.yi.loop_min, output.s0.y.yi.loop_extent) {
      let output.s0.y = output.s0.y.yi.base + output.s0.y.yi
      vectorized (output.s0.x.xi, output.s0.x.xi.loop_min, output.s0.x.xi.loop_extent) {
       let output.s0.x = output.s0.x.xi.base + output.s0.x.xi
       output(output.s0.x, output.s0.y) = uint8((int16)shift_right((int16)cols(output.s0.x, output.s0.y) + (int16)8, (int16)4))
      }
     }
    }
   }
  }
 }
}

Inlining cols
for (.__root, 0, 1) {
 produce output {
  let output.s0.y.loop_max = output.s0.y.max
  let output.s0.y.loop_min = output.s0.y.min
  let output.s0.y.loop_extent = (output.s0.y.max + 1) - output.s0.y.min
  let output.s0.x.loop_max = output.s0.x.max
  let output.s0.x.loop_min = output.s0.x.min
  let output.s0.x.loop_extent = (output.s0.x.max + 1) - output.s0.x.min
  let output.s0.__outermost.loop_extent = 1
  let output.s0.__outermost.loop_max = 0
  let output.s0.__outermost.loop_min = 0
  let output.s0.x.x.loop_extent = ((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128
  let output.s0.x.x.loop_max = (((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128) - 1
  let output.s0.x.x.loop_min = 0
  let output.s0.x.xi.loop_extent = 128
  let output.s0.x.xi.loop_max = 128 - 1
  let output.s0.x.xi.loop_min = 0
  let output.s0.y.y.loop_extent = ((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4
  let output.s0.y.y.loop_max = (((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4) - 1
  let output.s0.y.y.loop_min = 0
  let output.s0.y.yi.loop_extent = 4
  let output.s0.y.yi.loop_max = 4 - 1
  let output.s0.y.yi.loop_min = 0
  for<Hexagon> (output.s0.__outermost, output.s0.__outermost.loop_min, output.s0.__outermost.loop_extent) {
   for (output.s0.y.y, output.s0.y.y.loop_min, output.s0.y.y.loop_extent) {
    prefetch input()
    let output.s0.y.yi.base = (output.s0.y.y*4) + output.s0.y.loop_min
    for (output.s0.x.x, output.s0.x.x.loop_min, output.s0.x.x.loop_extent) {
     let output.s0.x.xi.base = (output.s0.x.x*128) + output.s0.x.loop_min
     unrolled (output.s0.y.yi, output.s0.y.yi.loop_min, output.s0.y.yi.loop_extent) {
      let output.s0.y = output.s0.y.yi.base + output.s0.y.yi
      vectorized (output.s0.x.xi, output.s0.x.xi.loop_min, output.s0.x.xi.loop_extent) {
       let output.s0.x = output.s0.x.xi.base + output.s0.x.xi
       output(output.s0.x, output.s0.y) = uint8((int16)shift_right((((int16)rows(output.s0.x - 1, output.s0.y) + ((int16)2*(int16)rows(output.s0.x, output.s0.y))) + (int16)rows(output.s0.x + 1, output.s0.y)) + (int16)8, (int16)4))
      }
     }
    }
   }
  }
 }
}

Inlining rows
for (.__root, 0, 1) {
 produce output {
  let output.s0.y.loop_max = output.s0.y.max
  let output.s0.y.loop_min = output.s0.y.min
  let output.s0.y.loop_extent = (output.s0.y.max + 1) - output.s0.y.min
  let output.s0.x.loop_max = output.s0.x.max
  let output.s0.x.loop_min = output.s0.x.min
  let output.s0.x.loop_extent = (output.s0.x.max + 1) - output.s0.x.min
  let output.s0.__outermost.loop_extent = 1
  let output.s0.__outermost.loop_max = 0
  let output.s0.__outermost.loop_min = 0
  let output.s0.x.x.loop_extent = ((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128
  let output.s0.x.x.loop_max = (((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128) - 1
  let output.s0.x.x.loop_min = 0
  let output.s0.x.xi.loop_extent = 128
  let output.s0.x.xi.loop_max = 128 - 1
  let output.s0.x.xi.loop_min = 0
  let output.s0.y.y.loop_extent = ((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4
  let output.s0.y.y.loop_max = (((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4) - 1
  let output.s0.y.y.loop_min = 0
  let output.s0.y.yi.loop_extent = 4
  let output.s0.y.yi.loop_max = 4 - 1
  let output.s0.y.yi.loop_min = 0
  for<Hexagon> (output.s0.__outermost, output.s0.__outermost.loop_min, output.s0.__outermost.loop_extent) {
   for (output.s0.y.y, output.s0.y.y.loop_min, output.s0.y.y.loop_extent) {
    prefetch input()
    let output.s0.y.yi.base = (output.s0.y.y*4) + output.s0.y.loop_min
    for (output.s0.x.x, output.s0.x.x.loop_min, output.s0.x.x.loop_extent) {
     let output.s0.x.xi.base = (output.s0.x.x*128) + output.s0.x.loop_min
     unrolled (output.s0.y.yi, output.s0.y.yi.loop_min, output.s0.y.yi.loop_extent) {
      let output.s0.y = output.s0.y.yi.base + output.s0.y.yi
      vectorized (output.s0.x.xi, output.s0.x.xi.loop_min, output.s0.x.xi.loop_extent) {
       let output.s0.x = output.s0.x.xi.base + output.s0.x.xi
       output(output.s0.x, output.s0.y) = uint8((int16)shift_right((((((int16)input_16(output.s0.x - 1, output.s0.y - 1) + ((int16)2*(int16)input_16(output.s0.x - 1, output.s0.y))) + (int16)input_16(output.s0.x - 1, output.s0.y + 1)) + ((int16)2*(((int16)input_16(output.s0.x, output.s0.y - 1) + ((int16)2*(int16)input_16(output.s0.x, output.s0.y))) + (int16)input_16(output.s0.x, output.s0.y + 1)))) + (((int16)input_16(output.s0.x + 1, output.s0.y - 1) + ((int16)2*(int16)input_16(output.s0.x + 1, output.s0.y))) + (int16)input_16(output.s0.x + 1, output.s0.y + 1))) + (int16)8, (int16)4))
      }
     }
    }
   }
  }
 }
}

Inlining input_16
for (.__root, 0, 1) {
 produce output {
  let output.s0.y.loop_max = output.s0.y.max
  let output.s0.y.loop_min = output.s0.y.min
  let output.s0.y.loop_extent = (output.s0.y.max + 1) - output.s0.y.min
  let output.s0.x.loop_max = output.s0.x.max
  let output.s0.x.loop_min = output.s0.x.min
  let output.s0.x.loop_extent = (output.s0.x.max + 1) - output.s0.x.min
  let output.s0.__outermost.loop_extent = 1
  let output.s0.__outermost.loop_max = 0
  let output.s0.__outermost.loop_min = 0
  let output.s0.x.x.loop_extent = ((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128
  let output.s0.x.x.loop_max = (((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128) - 1
  let output.s0.x.x.loop_min = 0
  let output.s0.x.xi.loop_extent = 128
  let output.s0.x.xi.loop_max = 128 - 1
  let output.s0.x.xi.loop_min = 0
  let output.s0.y.y.loop_extent = ((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4
  let output.s0.y.y.loop_max = (((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4) - 1
  let output.s0.y.y.loop_min = 0
  let output.s0.y.yi.loop_extent = 4
  let output.s0.y.yi.loop_max = 4 - 1
  let output.s0.y.yi.loop_min = 0
  for<Hexagon> (output.s0.__outermost, output.s0.__outermost.loop_min, output.s0.__outermost.loop_extent) {
   for (output.s0.y.y, output.s0.y.y.loop_min, output.s0.y.y.loop_extent) {
    prefetch input()
    let output.s0.y.yi.base = (output.s0.y.y*4) + output.s0.y.loop_min
    for (output.s0.x.x, output.s0.x.x.loop_min, output.s0.x.x.loop_extent) {
     let output.s0.x.xi.base = (output.s0.x.x*128) + output.s0.x.loop_min
     unrolled (output.s0.y.yi, output.s0.y.yi.loop_min, output.s0.y.yi.loop_extent) {
      let output.s0.y = output.s0.y.yi.base + output.s0.y.yi
      vectorized (output.s0.x.xi, output.s0.x.xi.loop_min, output.s0.x.xi.loop_extent) {
       let output.s0.x = output.s0.x.xi.base + output.s0.x.xi
       output(output.s0.x, output.s0.y) = uint8((int16)shift_right(((((int16((uint8)input_im(output.s0.x - 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input_im(output.s0.x - 1, output.s0.y)))) + int16((uint8)input_im(output.s0.x - 1, output.s0.y + 1))) + ((int16)2*((int16((uint8)input_im(output.s0.x, output.s0.y - 1)) + ((int16)2*int16((uint8)input_im(output.s0.x, output.s0.y)))) + int16((uint8)input_im(output.s0.x, output.s0.y + 1))))) + ((int16((uint8)input_im(output.s0.x + 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input_im(output.s0.x + 1, output.s0.y)))) + int16((uint8)input_im(output.s0.x + 1, output.s0.y + 1)))) + (int16)8, (int16)4))
      }
     }
    }
   }
  }
 }
}

Inlining input_im
for (.__root, 0, 1) {
 produce output {
  let output.s0.y.loop_max = output.s0.y.max
  let output.s0.y.loop_min = output.s0.y.min
  let output.s0.y.loop_extent = (output.s0.y.max + 1) - output.s0.y.min
  let output.s0.x.loop_max = output.s0.x.max
  let output.s0.x.loop_min = output.s0.x.min
  let output.s0.x.loop_extent = (output.s0.x.max + 1) - output.s0.x.min
  let output.s0.__outermost.loop_extent = 1
  let output.s0.__outermost.loop_max = 0
  let output.s0.__outermost.loop_min = 0
  let output.s0.x.x.loop_extent = ((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128
  let output.s0.x.x.loop_max = (((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128) - 1
  let output.s0.x.x.loop_min = 0
  let output.s0.x.xi.loop_extent = 128
  let output.s0.x.xi.loop_max = 128 - 1
  let output.s0.x.xi.loop_min = 0
  let output.s0.y.y.loop_extent = ((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4
  let output.s0.y.y.loop_max = (((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4) - 1
  let output.s0.y.y.loop_min = 0
  let output.s0.y.yi.loop_extent = 4
  let output.s0.y.yi.loop_max = 4 - 1
  let output.s0.y.yi.loop_min = 0
  for<Hexagon> (output.s0.__outermost, output.s0.__outermost.loop_min, output.s0.__outermost.loop_extent) {
   for (output.s0.y.y, output.s0.y.y.loop_min, output.s0.y.y.loop_extent) {
    prefetch input()
    let output.s0.y.yi.base = (output.s0.y.y*4) + output.s0.y.loop_min
    for (output.s0.x.x, output.s0.x.x.loop_min, output.s0.x.x.loop_extent) {
     let output.s0.x.xi.base = (output.s0.x.x*128) + output.s0.x.loop_min
     unrolled (output.s0.y.yi, output.s0.y.yi.loop_min, output.s0.y.yi.loop_extent) {
      let output.s0.y = output.s0.y.yi.base + output.s0.y.yi
      vectorized (output.s0.x.xi, output.s0.x.xi.loop_min, output.s0.x.xi.loop_extent) {
       let output.s0.x = output.s0.x.xi.base + output.s0.x.xi
       output(output.s0.x, output.s0.y) = uint8((int16)shift_right(((((int16((uint8)input(output.s0.x - 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x - 1, output.s0.y)))) + int16((uint8)input(output.s0.x - 1, output.s0.y + 1))) + ((int16)2*((int16((uint8)input(output.s0.x, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x, output.s0.y)))) + int16((uint8)input(output.s0.x, output.s0.y + 1))))) + ((int16((uint8)input(output.s0.x + 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x + 1, output.s0.y)))) + int16((uint8)input(output.s0.x + 1, output.s0.y + 1)))) + (int16)8, (int16)4))
      }
     }
    }
   }
  }
 }
}

Lowering after creating initial loop nests:
produce output {
 let output.s0.y.loop_max = output.s0.y.max
 let output.s0.y.loop_min = output.s0.y.min
 let output.s0.y.loop_extent = (output.s0.y.max + 1) - output.s0.y.min
 let output.s0.x.loop_max = output.s0.x.max
 let output.s0.x.loop_min = output.s0.x.min
 let output.s0.x.loop_extent = (output.s0.x.max + 1) - output.s0.x.min
 let output.s0.x.x.loop_extent = ((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128
 let output.s0.x.x.loop_max = (((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128) - 1
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 128 - 1
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = ((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4
 let output.s0.y.y.loop_max = (((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4) - 1
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 4 - 1
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, output.s0.y.y.loop_min, output.s0.y.y.loop_extent) {
   prefetch input()
   let output.s0.y.yi.base = (output.s0.y.y*4) + output.s0.y.loop_min
   for (output.s0.x.x, output.s0.x.x.loop_min, output.s0.x.x.loop_extent) {
    let output.s0.x.xi.base = (output.s0.x.x*128) + output.s0.x.loop_min
    unrolled (output.s0.y.yi, output.s0.y.yi.loop_min, output.s0.y.yi.loop_extent) {
     let output.s0.y = output.s0.y.yi.base + output.s0.y.yi
     vectorized (output.s0.x.xi, output.s0.x.xi.loop_min, output.s0.x.xi.loop_extent) {
      let output.s0.x = output.s0.x.xi.base + output.s0.x.xi
      output(output.s0.x, output.s0.y) = uint8((int16)shift_right(((((int16((uint8)input(output.s0.x - 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x - 1, output.s0.y)))) + int16((uint8)input(output.s0.x - 1, output.s0.y + 1))) + ((int16)2*((int16((uint8)input(output.s0.x, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x, output.s0.y)))) + int16((uint8)input(output.s0.x, output.s0.y + 1))))) + ((int16((uint8)input(output.s0.x + 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x + 1, output.s0.y)))) + int16((uint8)input(output.s0.x + 1, output.s0.y + 1)))) + (int16)8, (int16)4))
     }
    }
   }
  }
 }
}

Skipping injecting memoization...
Injecting tracing...
Lowering after injecting tracing:
produce output {
 let output.s0.y.loop_max = output.s0.y.max
 let output.s0.y.loop_min = output.s0.y.min
 let output.s0.y.loop_extent = (output.s0.y.max + 1) - output.s0.y.min
 let output.s0.x.loop_max = output.s0.x.max
 let output.s0.x.loop_min = output.s0.x.min
 let output.s0.x.loop_extent = (output.s0.x.max + 1) - output.s0.x.min
 let output.s0.x.x.loop_extent = ((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128
 let output.s0.x.x.loop_max = (((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128) - 1
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 128 - 1
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = ((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4
 let output.s0.y.y.loop_max = (((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4) - 1
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 4 - 1
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, output.s0.y.y.loop_min, output.s0.y.y.loop_extent) {
   prefetch input()
   let output.s0.y.yi.base = (output.s0.y.y*4) + output.s0.y.loop_min
   for (output.s0.x.x, output.s0.x.x.loop_min, output.s0.x.x.loop_extent) {
    let output.s0.x.xi.base = (output.s0.x.x*128) + output.s0.x.loop_min
    unrolled (output.s0.y.yi, output.s0.y.yi.loop_min, output.s0.y.yi.loop_extent) {
     let output.s0.y = output.s0.y.yi.base + output.s0.y.yi
     vectorized (output.s0.x.xi, output.s0.x.xi.loop_min, output.s0.x.xi.loop_extent) {
      let output.s0.x = output.s0.x.xi.base + output.s0.x.xi
      output(output.s0.x, output.s0.y) = uint8((int16)shift_right(((((int16((uint8)input(output.s0.x - 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x - 1, output.s0.y)))) + int16((uint8)input(output.s0.x - 1, output.s0.y + 1))) + ((int16)2*((int16((uint8)input(output.s0.x, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x, output.s0.y)))) + int16((uint8)input(output.s0.x, output.s0.y + 1))))) + ((int16((uint8)input(output.s0.x + 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x + 1, output.s0.y)))) + int16((uint8)input(output.s0.x + 1, output.s0.y + 1)))) + (int16)8, (int16)4))
     }
    }
   }
  }
 }
}

Adding checks for parameters
Lowering after injecting parameter checks:
produce output {
 let output.s0.y.loop_max = output.s0.y.max
 let output.s0.y.loop_min = output.s0.y.min
 let output.s0.y.loop_extent = (output.s0.y.max + 1) - output.s0.y.min
 let output.s0.x.loop_max = output.s0.x.max
 let output.s0.x.loop_min = output.s0.x.min
 let output.s0.x.loop_extent = (output.s0.x.max + 1) - output.s0.x.min
 let output.s0.x.x.loop_extent = ((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128
 let output.s0.x.x.loop_max = (((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128) - 1
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 128 - 1
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = ((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4
 let output.s0.y.y.loop_max = (((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4) - 1
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 4 - 1
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, output.s0.y.y.loop_min, output.s0.y.y.loop_extent) {
   prefetch input()
   let output.s0.y.yi.base = (output.s0.y.y*4) + output.s0.y.loop_min
   for (output.s0.x.x, output.s0.x.x.loop_min, output.s0.x.x.loop_extent) {
    let output.s0.x.xi.base = (output.s0.x.x*128) + output.s0.x.loop_min
    unrolled (output.s0.y.yi, output.s0.y.yi.loop_min, output.s0.y.yi.loop_extent) {
     let output.s0.y = output.s0.y.yi.base + output.s0.y.yi
     vectorized (output.s0.x.xi, output.s0.x.xi.loop_min, output.s0.x.xi.loop_extent) {
      let output.s0.x = output.s0.x.xi.base + output.s0.x.xi
      output(output.s0.x, output.s0.y) = uint8((int16)shift_right(((((int16((uint8)input(output.s0.x - 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x - 1, output.s0.y)))) + int16((uint8)input(output.s0.x - 1, output.s0.y + 1))) + ((int16)2*((int16((uint8)input(output.s0.x, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x, output.s0.y)))) + int16((uint8)input(output.s0.x, output.s0.y + 1))))) + ((int16((uint8)input(output.s0.x + 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x + 1, output.s0.y)))) + int16((uint8)input(output.s0.x + 1, output.s0.y + 1)))) + (int16)8, (int16)4))
     }
    }
   }
  }
 }
}

Computing bounds of each function's value
Bounds on value 0 for func input_im are: (uint8)0, (uint8)255
Bounds on value 0 for func input_16 are: (int16)0, (int16)255
Bounds on value 0 for func rows are: (int16)0, (int16)1020
Bounds on value 0 for func cols are: (int16)0, (int16)4080
Bounds on value 0 for func output are: (uint8)0, (uint8)255
Performing computation bounds inference...
Lowering after computation bounds inference:
let output.s0.y.max = (0 + output.extent.1) - 1
let output.s0.y.min = 0
let output.s0.x.max = (0 + output.extent.0) - 1
let output.s0.x.min = 0
add_image_checks_marker()
produce output {
 let output.s0.y.loop_max = output.s0.y.max
 let output.s0.y.loop_min = output.s0.y.min
 let output.s0.y.loop_extent = (output.s0.y.max + 1) - output.s0.y.min
 let output.s0.x.loop_max = output.s0.x.max
 let output.s0.x.loop_min = output.s0.x.min
 let output.s0.x.loop_extent = (output.s0.x.max + 1) - output.s0.x.min
 let output.s0.x.x.loop_extent = ((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128
 let output.s0.x.x.loop_max = (((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128) - 1
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 128 - 1
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = ((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4
 let output.s0.y.y.loop_max = (((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4) - 1
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 4 - 1
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, output.s0.y.y.loop_min, output.s0.y.y.loop_extent) {
   prefetch input()
   let output.s0.y.yi.base = (output.s0.y.y*4) + output.s0.y.loop_min
   for (output.s0.x.x, output.s0.x.x.loop_min, output.s0.x.x.loop_extent) {
    let output.s0.x.xi.base = (output.s0.x.x*128) + output.s0.x.loop_min
    unrolled (output.s0.y.yi, output.s0.y.yi.loop_min, output.s0.y.yi.loop_extent) {
     let output.s0.y = output.s0.y.yi.base + output.s0.y.yi
     vectorized (output.s0.x.xi, output.s0.x.xi.loop_min, output.s0.x.xi.loop_extent) {
      let output.s0.x = output.s0.x.xi.base + output.s0.x.xi
      output(output.s0.x, output.s0.y) = uint8((int16)shift_right(((((int16((uint8)input(output.s0.x - 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x - 1, output.s0.y)))) + int16((uint8)input(output.s0.x - 1, output.s0.y + 1))) + ((int16)2*((int16((uint8)input(output.s0.x, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x, output.s0.y)))) + int16((uint8)input(output.s0.x, output.s0.y + 1))))) + ((int16((uint8)input(output.s0.x + 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x + 1, output.s0.y)))) + int16((uint8)input(output.s0.x + 1, output.s0.y + 1)))) + (int16)8, (int16)4))
     }
    }
   }
  }
 }
}

Removing extern loops...
Lowering after removing extern loops:
let output.s0.y.max = (0 + output.extent.1) - 1
let output.s0.y.min = 0
let output.s0.x.max = (0 + output.extent.0) - 1
let output.s0.x.min = 0
add_image_checks_marker()
produce output {
 let output.s0.y.loop_max = output.s0.y.max
 let output.s0.y.loop_min = output.s0.y.min
 let output.s0.y.loop_extent = (output.s0.y.max + 1) - output.s0.y.min
 let output.s0.x.loop_max = output.s0.x.max
 let output.s0.x.loop_min = output.s0.x.min
 let output.s0.x.loop_extent = (output.s0.x.max + 1) - output.s0.x.min
 let output.s0.x.x.loop_extent = ((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128
 let output.s0.x.x.loop_max = (((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128) - 1
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 128 - 1
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = ((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4
 let output.s0.y.y.loop_max = (((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4) - 1
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 4 - 1
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, output.s0.y.y.loop_min, output.s0.y.y.loop_extent) {
   prefetch input()
   let output.s0.y.yi.base = (output.s0.y.y*4) + output.s0.y.loop_min
   for (output.s0.x.x, output.s0.x.x.loop_min, output.s0.x.x.loop_extent) {
    let output.s0.x.xi.base = (output.s0.x.x*128) + output.s0.x.loop_min
    unrolled (output.s0.y.yi, output.s0.y.yi.loop_min, output.s0.y.yi.loop_extent) {
     let output.s0.y = output.s0.y.yi.base + output.s0.y.yi
     vectorized (output.s0.x.xi, output.s0.x.xi.loop_min, output.s0.x.xi.loop_extent) {
      let output.s0.x = output.s0.x.xi.base + output.s0.x.xi
      output(output.s0.x, output.s0.y) = uint8((int16)shift_right(((((int16((uint8)input(output.s0.x - 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x - 1, output.s0.y)))) + int16((uint8)input(output.s0.x - 1, output.s0.y + 1))) + ((int16)2*((int16((uint8)input(output.s0.x, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x, output.s0.y)))) + int16((uint8)input(output.s0.x, output.s0.y + 1))))) + ((int16((uint8)input(output.s0.x + 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x + 1, output.s0.y)))) + int16((uint8)input(output.s0.x + 1, output.s0.y + 1)))) + (int16)8, (int16)4))
     }
    }
   }
  }
 }
}

Performing sliding window optimization...
Lowering after sliding window:
let output.s0.y.max = (0 + output.extent.1) - 1
let output.s0.y.min = 0
let output.s0.x.max = (0 + output.extent.0) - 1
let output.s0.x.min = 0
add_image_checks_marker()
produce output {
 let output.s0.y.loop_max = output.s0.y.max
 let output.s0.y.loop_min = output.s0.y.min
 let output.s0.y.loop_extent = (output.s0.y.max + 1) - output.s0.y.min
 let output.s0.x.loop_max = output.s0.x.max
 let output.s0.x.loop_min = output.s0.x.min
 let output.s0.x.loop_extent = (output.s0.x.max + 1) - output.s0.x.min
 let output.s0.x.x.loop_extent = ((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128
 let output.s0.x.x.loop_max = (((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128) - 1
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 128 - 1
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = ((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4
 let output.s0.y.y.loop_max = (((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4) - 1
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 4 - 1
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, output.s0.y.y.loop_min, output.s0.y.y.loop_extent) {
   prefetch input()
   let output.s0.y.yi.base = (output.s0.y.y*4) + output.s0.y.loop_min
   for (output.s0.x.x, output.s0.x.x.loop_min, output.s0.x.x.loop_extent) {
    let output.s0.x.xi.base = (output.s0.x.x*128) + output.s0.x.loop_min
    unrolled (output.s0.y.yi, output.s0.y.yi.loop_min, output.s0.y.yi.loop_extent) {
     let output.s0.y = output.s0.y.yi.base + output.s0.y.yi
     vectorized (output.s0.x.xi, output.s0.x.xi.loop_min, output.s0.x.xi.loop_extent) {
      let output.s0.x = output.s0.x.xi.base + output.s0.x.xi
      output(output.s0.x, output.s0.y) = uint8((int16)shift_right(((((int16((uint8)input(output.s0.x - 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x - 1, output.s0.y)))) + int16((uint8)input(output.s0.x - 1, output.s0.y + 1))) + ((int16)2*((int16((uint8)input(output.s0.x, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x, output.s0.y)))) + int16((uint8)input(output.s0.x, output.s0.y + 1))))) + ((int16((uint8)input(output.s0.x + 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x + 1, output.s0.y)))) + int16((uint8)input(output.s0.x + 1, output.s0.y + 1)))) + (int16)8, (int16)4))
     }
    }
   }
  }
 }
}

Uniquifying variable names...
Lowering after uniquifying variable names:
let output.s0.y.max = (0 + output.extent.1) - 1
let output.s0.y.min = 0
let output.s0.x.max = (0 + output.extent.0) - 1
let output.s0.x.min = 0
add_image_checks_marker()
produce output {
 let output.s0.y.loop_max = output.s0.y.max
 let output.s0.y.loop_min = output.s0.y.min
 let output.s0.y.loop_extent = (output.s0.y.max + 1) - output.s0.y.min
 let output.s0.x.loop_max = output.s0.x.max
 let output.s0.x.loop_min = output.s0.x.min
 let output.s0.x.loop_extent = (output.s0.x.max + 1) - output.s0.x.min
 let output.s0.x.x.loop_extent = ((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128
 let output.s0.x.x.loop_max = (((output.s0.x.loop_max - output.s0.x.loop_min) + 128)/128) - 1
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 128 - 1
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = ((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4
 let output.s0.y.y.loop_max = (((output.s0.y.loop_max - output.s0.y.loop_min) + 4)/4) - 1
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 4 - 1
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, output.s0.y.y.loop_min, output.s0.y.y.loop_extent) {
   prefetch input()
   let output.s0.y.yi.base = (output.s0.y.y*4) + output.s0.y.loop_min
   for (output.s0.x.x, output.s0.x.x.loop_min, output.s0.x.x.loop_extent) {
    let output.s0.x.xi.base = (output.s0.x.x*128) + output.s0.x.loop_min
    unrolled (output.s0.y.yi, output.s0.y.yi.loop_min, output.s0.y.yi.loop_extent) {
     let output.s0.y = output.s0.y.yi.base + output.s0.y.yi
     vectorized (output.s0.x.xi, output.s0.x.xi.loop_min, output.s0.x.xi.loop_extent) {
      let output.s0.x = output.s0.x.xi.base + output.s0.x.xi
      output(output.s0.x, output.s0.y) = uint8((int16)shift_right(((((int16((uint8)input(output.s0.x - 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x - 1, output.s0.y)))) + int16((uint8)input(output.s0.x - 1, output.s0.y + 1))) + ((int16)2*((int16((uint8)input(output.s0.x, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x, output.s0.y)))) + int16((uint8)input(output.s0.x, output.s0.y + 1))))) + ((int16((uint8)input(output.s0.x + 1, output.s0.y - 1)) + ((int16)2*int16((uint8)input(output.s0.x + 1, output.s0.y)))) + int16((uint8)input(output.s0.x + 1, output.s0.y + 1)))) + (int16)8, (int16)4))
     }
    }
   }
  }
 }
}


Simplifying...
Lowering after first simplification:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
add_image_checks_marker()
produce output {
 let output.s0.y.loop_max = output.extent.1 + -1
 let output.s0.y.loop_min = 0
 let output.s0.y.loop_extent = output.extent.1
 let output.s0.x.loop_max = output.extent.0 + -1
 let output.s0.x.loop_min = 0
 let output.s0.x.loop_extent = output.extent.0
 let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
 let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 127
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
 let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 3
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   prefetch input()
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi) = uint8(((((((((int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))*(int16)2) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}


Simplifying correlated differences...
Lowering after simplifying correlated differences:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
add_image_checks_marker()
produce output {
 let output.s0.y.loop_max = output.extent.1 + -1
 let output.s0.y.loop_min = 0
 let output.s0.y.loop_extent = output.extent.1
 let output.s0.x.loop_max = output.extent.0 + -1
 let output.s0.x.loop_min = 0
 let output.s0.x.loop_extent = output.extent.0
 let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
 let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 127
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
 let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 3
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   prefetch input()
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi) = uint8(((((((((int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))*(int16)2) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}

Performing allocation bounds inference...
Lowering after allocation bounds inference:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
add_image_checks_marker()
produce output {
 let output.s0.y.loop_max = output.extent.1 + -1
 let output.s0.y.loop_min = 0
 let output.s0.y.loop_extent = output.extent.1
 let output.s0.x.loop_max = output.extent.0 + -1
 let output.s0.x.loop_min = 0
 let output.s0.x.loop_extent = output.extent.0
 let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
 let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 127
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
 let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 3
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   prefetch input()
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi) = uint8(((((((((int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))*(int16)2) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}

Adding checks for images
Injecting constraints for input.0
Injecting constraints for input.1
Injecting constraints for output.0
Injecting constraints for output.1
Lowering after injecting image checks:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
let input.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 128) + 1) - -1
let input.min.0.required = -1
let input.stride.0.required = 1
let input.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 4) + 1) - -1
let input.min.1.required = -1
let input.stride.1.required = input.stride.0.required*input.extent.0.required
let output.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 127) + 1) - ((0*128) + 0)
let output.min.0.required = (0*128) + 0
let output.stride.0.required = 1
let output.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 3) + 1) - ((0*4) + 0)
let output.min.1.required = (0*4) + 0
let output.stride.1.required = output.stride.0.required*output.extent.0.required
let input.stride.0.constrained = 1
let input.min.0.constrained = 0
let input.stride.1.constrained = (input.stride.1/128)*128
let input.min.1.constrained = 0
let output.stride.0.constrained = 1
let output.min.0.constrained = 0
let output.stride.1.constrained = (output.stride.1/128)*128
let output.min.1.constrained = 0
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = (input.stride.1.required/128)*128
let input.min.1.proposed = 0
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = (output.stride.1.required/128)*128
let output.min.1.proposed = 0
let output.extent.1.proposed = output.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, (input.min.0.proposed + input.extent.0.proposed) - 1, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, (input.min.1.proposed + input.extent.1.proposed) - 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, (output.min.0.proposed + output.extent.0.proposed) - 1, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, (output.min.1.proposed + output.extent.1.proposed) - 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1))
assert((uint32)input.type == (uint32)67585, halide_error_bad_type("Input buffer input", (uint32)input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert((uint32)output.type == (uint32)67585, halide_error_bad_type("Output buffer output", (uint32)output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1, input.min.0, (input.min.0 + input.extent.0) - 1))
assert(input.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1, input.min.1, (input.min.1 + input.extent.1) - 1))
assert(input.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1, output.min.0, (output.min.0 + output.extent.0) - 1))
assert(output.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1, output.min.1, (output.min.1 + output.extent.1) - 1))
assert(output.extent.1 >= 0, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == input.stride.0.constrained, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
assert(input.min.0 == input.min.0.constrained, halide_error_constraint_violated("input.min.0", input.min.0, "0", input.min.0.constrained))
assert(input.stride.1 == input.stride.1.constrained, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", input.stride.1.constrained))
assert(input.min.1 == input.min.1.constrained, halide_error_constraint_violated("input.min.1", input.min.1, "0", input.min.1.constrained))
assert(output.stride.0 == output.stride.0.constrained, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
assert(output.min.0 == output.min.0.constrained, halide_error_constraint_violated("output.min.0", output.min.0, "0", output.min.0.constrained))
assert(output.stride.1 == output.stride.1.constrained, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", output.stride.1.constrained))
assert(output.min.1 == output.min.1.constrained, halide_error_constraint_violated("output.min.1", output.min.1, "0", output.min.1.constrained))
let input.total_extent.0 = int64(input.extent.0)
let input.total_extent.1 = int64(input.extent.1)*input.total_extent.0
let output.total_extent.0 = int64(output.extent.0)
let output.total_extent.1 = int64(output.extent.1)*output.total_extent.0
assert((uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 let output.s0.y.loop_max = output.extent.1 + -1
 let output.s0.y.loop_min = 0
 let output.s0.y.loop_extent = output.extent.1
 let output.s0.x.loop_max = output.extent.0 + -1
 let output.s0.x.loop_min = 0
 let output.s0.x.loop_extent = output.extent.0
 let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
 let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 127
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
 let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 3
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   prefetch input()
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi) = uint8(((((((((int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))*(int16)2) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}

Removing code that depends on undef values...
Lowering after removing code that depends on undef values:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
let input.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 128) + 1) - -1
let input.min.0.required = -1
let input.stride.0.required = 1
let input.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 4) + 1) - -1
let input.min.1.required = -1
let input.stride.1.required = input.stride.0.required*input.extent.0.required
let output.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 127) + 1) - ((0*128) + 0)
let output.min.0.required = (0*128) + 0
let output.stride.0.required = 1
let output.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 3) + 1) - ((0*4) + 0)
let output.min.1.required = (0*4) + 0
let output.stride.1.required = output.stride.0.required*output.extent.0.required
let input.stride.0.constrained = 1
let input.min.0.constrained = 0
let input.stride.1.constrained = (input.stride.1/128)*128
let input.min.1.constrained = 0
let output.stride.0.constrained = 1
let output.min.0.constrained = 0
let output.stride.1.constrained = (output.stride.1/128)*128
let output.min.1.constrained = 0
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = (input.stride.1.required/128)*128
let input.min.1.proposed = 0
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = (output.stride.1.required/128)*128
let output.min.1.proposed = 0
let output.extent.1.proposed = output.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, (input.min.0.proposed + input.extent.0.proposed) - 1, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, (input.min.1.proposed + input.extent.1.proposed) - 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, (output.min.0.proposed + output.extent.0.proposed) - 1, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, (output.min.1.proposed + output.extent.1.proposed) - 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1))
assert((uint32)input.type == (uint32)67585, halide_error_bad_type("Input buffer input", (uint32)input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert((uint32)output.type == (uint32)67585, halide_error_bad_type("Output buffer output", (uint32)output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1, input.min.0, (input.min.0 + input.extent.0) - 1))
assert(input.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1, input.min.1, (input.min.1 + input.extent.1) - 1))
assert(input.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1, output.min.0, (output.min.0 + output.extent.0) - 1))
assert(output.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1, output.min.1, (output.min.1 + output.extent.1) - 1))
assert(output.extent.1 >= 0, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == input.stride.0.constrained, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
assert(input.min.0 == input.min.0.constrained, halide_error_constraint_violated("input.min.0", input.min.0, "0", input.min.0.constrained))
assert(input.stride.1 == input.stride.1.constrained, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", input.stride.1.constrained))
assert(input.min.1 == input.min.1.constrained, halide_error_constraint_violated("input.min.1", input.min.1, "0", input.min.1.constrained))
assert(output.stride.0 == output.stride.0.constrained, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
assert(output.min.0 == output.min.0.constrained, halide_error_constraint_violated("output.min.0", output.min.0, "0", output.min.0.constrained))
assert(output.stride.1 == output.stride.1.constrained, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", output.stride.1.constrained))
assert(output.min.1 == output.min.1.constrained, halide_error_constraint_violated("output.min.1", output.min.1, "0", output.min.1.constrained))
let input.total_extent.0 = int64(input.extent.0)
let input.total_extent.1 = int64(input.extent.1)*input.total_extent.0
let output.total_extent.0 = int64(output.extent.0)
let output.total_extent.1 = int64(output.extent.1)*output.total_extent.0
assert((uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 let output.s0.y.loop_max = output.extent.1 + -1
 let output.s0.y.loop_min = 0
 let output.s0.y.loop_extent = output.extent.1
 let output.s0.x.loop_max = output.extent.0 + -1
 let output.s0.x.loop_min = 0
 let output.s0.x.loop_extent = output.extent.0
 let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
 let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 127
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
 let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 3
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   prefetch input()
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi) = uint8(((((((((int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))*(int16)2) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}


Performing storage folding optimization...
Lowering after storage folding:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
let input.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 128) + 1) - -1
let input.min.0.required = -1
let input.stride.0.required = 1
let input.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 4) + 1) - -1
let input.min.1.required = -1
let input.stride.1.required = input.stride.0.required*input.extent.0.required
let output.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 127) + 1) - ((0*128) + 0)
let output.min.0.required = (0*128) + 0
let output.stride.0.required = 1
let output.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 3) + 1) - ((0*4) + 0)
let output.min.1.required = (0*4) + 0
let output.stride.1.required = output.stride.0.required*output.extent.0.required
let input.stride.0.constrained = 1
let input.min.0.constrained = 0
let input.stride.1.constrained = (input.stride.1/128)*128
let input.min.1.constrained = 0
let output.stride.0.constrained = 1
let output.min.0.constrained = 0
let output.stride.1.constrained = (output.stride.1/128)*128
let output.min.1.constrained = 0
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = (input.stride.1.required/128)*128
let input.min.1.proposed = 0
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = (output.stride.1.required/128)*128
let output.min.1.proposed = 0
let output.extent.1.proposed = output.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, (input.min.0.proposed + input.extent.0.proposed) - 1, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, (input.min.1.proposed + input.extent.1.proposed) - 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, (output.min.0.proposed + output.extent.0.proposed) - 1, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, (output.min.1.proposed + output.extent.1.proposed) - 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1))
assert((uint32)input.type == (uint32)67585, halide_error_bad_type("Input buffer input", (uint32)input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert((uint32)output.type == (uint32)67585, halide_error_bad_type("Output buffer output", (uint32)output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1, input.min.0, (input.min.0 + input.extent.0) - 1))
assert(input.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1, input.min.1, (input.min.1 + input.extent.1) - 1))
assert(input.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1, output.min.0, (output.min.0 + output.extent.0) - 1))
assert(output.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1, output.min.1, (output.min.1 + output.extent.1) - 1))
assert(output.extent.1 >= 0, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == input.stride.0.constrained, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
assert(input.min.0 == input.min.0.constrained, halide_error_constraint_violated("input.min.0", input.min.0, "0", input.min.0.constrained))
assert(input.stride.1 == input.stride.1.constrained, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", input.stride.1.constrained))
assert(input.min.1 == input.min.1.constrained, halide_error_constraint_violated("input.min.1", input.min.1, "0", input.min.1.constrained))
assert(output.stride.0 == output.stride.0.constrained, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
assert(output.min.0 == output.min.0.constrained, halide_error_constraint_violated("output.min.0", output.min.0, "0", output.min.0.constrained))
assert(output.stride.1 == output.stride.1.constrained, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", output.stride.1.constrained))
assert(output.min.1 == output.min.1.constrained, halide_error_constraint_violated("output.min.1", output.min.1, "0", output.min.1.constrained))
let input.total_extent.0 = int64(input.extent.0)
let input.total_extent.1 = int64(input.extent.1)*input.total_extent.0
let output.total_extent.0 = int64(output.extent.0)
let output.total_extent.1 = int64(output.extent.1)*output.total_extent.0
assert((uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 let output.s0.y.loop_max = output.extent.1 + -1
 let output.s0.y.loop_min = 0
 let output.s0.y.loop_extent = output.extent.1
 let output.s0.x.loop_max = output.extent.0 + -1
 let output.s0.x.loop_min = 0
 let output.s0.x.loop_extent = output.extent.0
 let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
 let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 127
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
 let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 3
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   prefetch input()
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi) = uint8(((((((((int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))*(int16)2) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}

Injecting debug_to_file calls...
Lowering after injecting debug_to_file calls:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
let input.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 128) + 1) - -1
let input.min.0.required = -1
let input.stride.0.required = 1
let input.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 4) + 1) - -1
let input.min.1.required = -1
let input.stride.1.required = input.stride.0.required*input.extent.0.required
let output.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 127) + 1) - ((0*128) + 0)
let output.min.0.required = (0*128) + 0
let output.stride.0.required = 1
let output.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 3) + 1) - ((0*4) + 0)
let output.min.1.required = (0*4) + 0
let output.stride.1.required = output.stride.0.required*output.extent.0.required
let input.stride.0.constrained = 1
let input.min.0.constrained = 0
let input.stride.1.constrained = (input.stride.1/128)*128
let input.min.1.constrained = 0
let output.stride.0.constrained = 1
let output.min.0.constrained = 0
let output.stride.1.constrained = (output.stride.1/128)*128
let output.min.1.constrained = 0
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = (input.stride.1.required/128)*128
let input.min.1.proposed = 0
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = (output.stride.1.required/128)*128
let output.min.1.proposed = 0
let output.extent.1.proposed = output.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, (input.min.0.proposed + input.extent.0.proposed) - 1, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, (input.min.1.proposed + input.extent.1.proposed) - 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, (output.min.0.proposed + output.extent.0.proposed) - 1, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, (output.min.1.proposed + output.extent.1.proposed) - 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1))
assert((uint32)input.type == (uint32)67585, halide_error_bad_type("Input buffer input", (uint32)input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert((uint32)output.type == (uint32)67585, halide_error_bad_type("Output buffer output", (uint32)output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1, input.min.0, (input.min.0 + input.extent.0) - 1))
assert(input.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1, input.min.1, (input.min.1 + input.extent.1) - 1))
assert(input.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1, output.min.0, (output.min.0 + output.extent.0) - 1))
assert(output.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1, output.min.1, (output.min.1 + output.extent.1) - 1))
assert(output.extent.1 >= 0, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == input.stride.0.constrained, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
assert(input.min.0 == input.min.0.constrained, halide_error_constraint_violated("input.min.0", input.min.0, "0", input.min.0.constrained))
assert(input.stride.1 == input.stride.1.constrained, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", input.stride.1.constrained))
assert(input.min.1 == input.min.1.constrained, halide_error_constraint_violated("input.min.1", input.min.1, "0", input.min.1.constrained))
assert(output.stride.0 == output.stride.0.constrained, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
assert(output.min.0 == output.min.0.constrained, halide_error_constraint_violated("output.min.0", output.min.0, "0", output.min.0.constrained))
assert(output.stride.1 == output.stride.1.constrained, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", output.stride.1.constrained))
assert(output.min.1 == output.min.1.constrained, halide_error_constraint_violated("output.min.1", output.min.1, "0", output.min.1.constrained))
let input.total_extent.0 = int64(input.extent.0)
let input.total_extent.1 = int64(input.extent.1)*input.total_extent.0
let output.total_extent.0 = int64(output.extent.0)
let output.total_extent.1 = int64(output.extent.1)*output.total_extent.0
assert((uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 let output.s0.y.loop_max = output.extent.1 + -1
 let output.s0.y.loop_min = 0
 let output.s0.y.loop_extent = output.extent.1
 let output.s0.x.loop_max = output.extent.0 + -1
 let output.s0.x.loop_min = 0
 let output.s0.x.loop_extent = output.extent.0
 let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
 let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 127
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
 let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 3
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   prefetch input()
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi) = uint8(((((((((int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))*(int16)2) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}

Injecting prefetches...
Lowering after injecting prefetches:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
let input.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 128) + 1) - -1
let input.min.0.required = -1
let input.stride.0.required = 1
let input.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 4) + 1) - -1
let input.min.1.required = -1
let input.stride.1.required = input.stride.0.required*input.extent.0.required
let output.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 127) + 1) - ((0*128) + 0)
let output.min.0.required = (0*128) + 0
let output.stride.0.required = 1
let output.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 3) + 1) - ((0*4) + 0)
let output.min.1.required = (0*4) + 0
let output.stride.1.required = output.stride.0.required*output.extent.0.required
let input.stride.0.constrained = 1
let input.min.0.constrained = 0
let input.stride.1.constrained = (input.stride.1/128)*128
let input.min.1.constrained = 0
let output.stride.0.constrained = 1
let output.min.0.constrained = 0
let output.stride.1.constrained = (output.stride.1/128)*128
let output.min.1.constrained = 0
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = (input.stride.1.required/128)*128
let input.min.1.proposed = 0
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = (output.stride.1.required/128)*128
let output.min.1.proposed = 0
let output.extent.1.proposed = output.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, (input.min.0.proposed + input.extent.0.proposed) - 1, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, (input.min.1.proposed + input.extent.1.proposed) - 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, (output.min.0.proposed + output.extent.0.proposed) - 1, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, (output.min.1.proposed + output.extent.1.proposed) - 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1))
assert((uint32)input.type == (uint32)67585, halide_error_bad_type("Input buffer input", (uint32)input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert((uint32)output.type == (uint32)67585, halide_error_bad_type("Output buffer output", (uint32)output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1, input.min.0, (input.min.0 + input.extent.0) - 1))
assert(input.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1, input.min.1, (input.min.1 + input.extent.1) - 1))
assert(input.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1, output.min.0, (output.min.0 + output.extent.0) - 1))
assert(output.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1, output.min.1, (output.min.1 + output.extent.1) - 1))
assert(output.extent.1 >= 0, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == input.stride.0.constrained, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
assert(input.min.0 == input.min.0.constrained, halide_error_constraint_violated("input.min.0", input.min.0, "0", input.min.0.constrained))
assert(input.stride.1 == input.stride.1.constrained, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", input.stride.1.constrained))
assert(input.min.1 == input.min.1.constrained, halide_error_constraint_violated("input.min.1", input.min.1, "0", input.min.1.constrained))
assert(output.stride.0 == output.stride.0.constrained, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
assert(output.min.0 == output.min.0.constrained, halide_error_constraint_violated("output.min.0", output.min.0, "0", output.min.0.constrained))
assert(output.stride.1 == output.stride.1.constrained, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", output.stride.1.constrained))
assert(output.min.1 == output.min.1.constrained, halide_error_constraint_violated("output.min.1", output.min.1, "0", output.min.1.constrained))
let input.total_extent.0 = int64(input.extent.0)
let input.total_extent.1 = int64(input.extent.1)*input.total_extent.0
let output.total_extent.0 = int64(output.extent.0)
let output.total_extent.1 = int64(output.extent.1)*output.total_extent.0
assert((uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 let output.s0.y.loop_max = output.extent.1 + -1
 let output.s0.y.loop_min = 0
 let output.s0.y.loop_extent = output.extent.1
 let output.s0.x.loop_max = output.extent.0 + -1
 let output.s0.x.loop_min = 0
 let output.s0.x.loop_extent = output.extent.0
 let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
 let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 127
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
 let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 3
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   prefetch input([-1, (((output.extent.0 + -1)/128)*128) + 130], [(output.s0.y.y*4) + 3, 6])
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi) = uint8(((((((((int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))*(int16)2) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}


Discarding safe promises...
Lowering after discarding safe promises:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
let input.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 128) + 1) - -1
let input.min.0.required = -1
let input.stride.0.required = 1
let input.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 4) + 1) - -1
let input.min.1.required = -1
let input.stride.1.required = input.stride.0.required*input.extent.0.required
let output.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 127) + 1) - ((0*128) + 0)
let output.min.0.required = (0*128) + 0
let output.stride.0.required = 1
let output.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 3) + 1) - ((0*4) + 0)
let output.min.1.required = (0*4) + 0
let output.stride.1.required = output.stride.0.required*output.extent.0.required
let input.stride.0.constrained = 1
let input.min.0.constrained = 0
let input.stride.1.constrained = (input.stride.1/128)*128
let input.min.1.constrained = 0
let output.stride.0.constrained = 1
let output.min.0.constrained = 0
let output.stride.1.constrained = (output.stride.1/128)*128
let output.min.1.constrained = 0
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = (input.stride.1.required/128)*128
let input.min.1.proposed = 0
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = (output.stride.1.required/128)*128
let output.min.1.proposed = 0
let output.extent.1.proposed = output.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, (input.min.0.proposed + input.extent.0.proposed) - 1, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, (input.min.1.proposed + input.extent.1.proposed) - 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, (output.min.0.proposed + output.extent.0.proposed) - 1, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, (output.min.1.proposed + output.extent.1.proposed) - 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1))
assert((uint32)input.type == (uint32)67585, halide_error_bad_type("Input buffer input", (uint32)input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert((uint32)output.type == (uint32)67585, halide_error_bad_type("Output buffer output", (uint32)output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1, input.min.0, (input.min.0 + input.extent.0) - 1))
assert(input.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1, input.min.1, (input.min.1 + input.extent.1) - 1))
assert(input.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1, output.min.0, (output.min.0 + output.extent.0) - 1))
assert(output.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1, output.min.1, (output.min.1 + output.extent.1) - 1))
assert(output.extent.1 >= 0, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == input.stride.0.constrained, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
assert(input.min.0 == input.min.0.constrained, halide_error_constraint_violated("input.min.0", input.min.0, "0", input.min.0.constrained))
assert(input.stride.1 == input.stride.1.constrained, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", input.stride.1.constrained))
assert(input.min.1 == input.min.1.constrained, halide_error_constraint_violated("input.min.1", input.min.1, "0", input.min.1.constrained))
assert(output.stride.0 == output.stride.0.constrained, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
assert(output.min.0 == output.min.0.constrained, halide_error_constraint_violated("output.min.0", output.min.0, "0", output.min.0.constrained))
assert(output.stride.1 == output.stride.1.constrained, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", output.stride.1.constrained))
assert(output.min.1 == output.min.1.constrained, halide_error_constraint_violated("output.min.1", output.min.1, "0", output.min.1.constrained))
let input.total_extent.0 = int64(input.extent.0)
let input.total_extent.1 = int64(input.extent.1)*input.total_extent.0
let output.total_extent.0 = int64(output.extent.0)
let output.total_extent.1 = int64(output.extent.1)*output.total_extent.0
assert((uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 let output.s0.y.loop_max = output.extent.1 + -1
 let output.s0.y.loop_min = 0
 let output.s0.y.loop_extent = output.extent.1
 let output.s0.x.loop_max = output.extent.0 + -1
 let output.s0.x.loop_min = 0
 let output.s0.x.loop_extent = output.extent.0
 let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
 let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 127
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
 let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 3
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   prefetch input([-1, (((output.extent.0 + -1)/128)*128) + 130], [(output.s0.y.y*4) + 3, 6])
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi) = uint8(((((((((int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))*(int16)2) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}


Dynamically skipping stages...
skip_stages checking cols
skip_stages checking rows
skip_stages checking input_16
skip_stages checking input_im
Lowering after dynamically skipping stages:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
let input.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 128) + 1) - -1
let input.min.0.required = -1
let input.stride.0.required = 1
let input.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 4) + 1) - -1
let input.min.1.required = -1
let input.stride.1.required = input.stride.0.required*input.extent.0.required
let output.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 127) + 1) - ((0*128) + 0)
let output.min.0.required = (0*128) + 0
let output.stride.0.required = 1
let output.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 3) + 1) - ((0*4) + 0)
let output.min.1.required = (0*4) + 0
let output.stride.1.required = output.stride.0.required*output.extent.0.required
let input.stride.0.constrained = 1
let input.min.0.constrained = 0
let input.stride.1.constrained = (input.stride.1/128)*128
let input.min.1.constrained = 0
let output.stride.0.constrained = 1
let output.min.0.constrained = 0
let output.stride.1.constrained = (output.stride.1/128)*128
let output.min.1.constrained = 0
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = (input.stride.1.required/128)*128
let input.min.1.proposed = 0
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = (output.stride.1.required/128)*128
let output.min.1.proposed = 0
let output.extent.1.proposed = output.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, (input.min.0.proposed + input.extent.0.proposed) - 1, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, (input.min.1.proposed + input.extent.1.proposed) - 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, (output.min.0.proposed + output.extent.0.proposed) - 1, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, (output.min.1.proposed + output.extent.1.proposed) - 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1))
assert((uint32)input.type == (uint32)67585, halide_error_bad_type("Input buffer input", (uint32)input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert((uint32)output.type == (uint32)67585, halide_error_bad_type("Output buffer output", (uint32)output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1, input.min.0, (input.min.0 + input.extent.0) - 1))
assert(input.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1, input.min.1, (input.min.1 + input.extent.1) - 1))
assert(input.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1, output.min.0, (output.min.0 + output.extent.0) - 1))
assert(output.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1, output.min.1, (output.min.1 + output.extent.1) - 1))
assert(output.extent.1 >= 0, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == input.stride.0.constrained, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
assert(input.min.0 == input.min.0.constrained, halide_error_constraint_violated("input.min.0", input.min.0, "0", input.min.0.constrained))
assert(input.stride.1 == input.stride.1.constrained, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", input.stride.1.constrained))
assert(input.min.1 == input.min.1.constrained, halide_error_constraint_violated("input.min.1", input.min.1, "0", input.min.1.constrained))
assert(output.stride.0 == output.stride.0.constrained, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
assert(output.min.0 == output.min.0.constrained, halide_error_constraint_violated("output.min.0", output.min.0, "0", output.min.0.constrained))
assert(output.stride.1 == output.stride.1.constrained, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", output.stride.1.constrained))
assert(output.min.1 == output.min.1.constrained, halide_error_constraint_violated("output.min.1", output.min.1, "0", output.min.1.constrained))
let input.total_extent.0 = int64(input.extent.0)
let input.total_extent.1 = int64(input.extent.1)*input.total_extent.0
let output.total_extent.0 = int64(output.extent.0)
let output.total_extent.1 = int64(output.extent.1)*output.total_extent.0
assert((uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 let output.s0.y.loop_max = output.extent.1 + -1
 let output.s0.y.loop_min = 0
 let output.s0.y.loop_extent = output.extent.1
 let output.s0.x.loop_max = output.extent.0 + -1
 let output.s0.x.loop_min = 0
 let output.s0.x.loop_extent = output.extent.0
 let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
 let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
 let output.s0.x.x.loop_min = 0
 let output.s0.x.xi.loop_extent = 128
 let output.s0.x.xi.loop_max = 127
 let output.s0.x.xi.loop_min = 0
 let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
 let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
 let output.s0.y.y.loop_min = 0
 let output.s0.y.yi.loop_extent = 4
 let output.s0.y.yi.loop_max = 3
 let output.s0.y.yi.loop_min = 0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   prefetch input([-1, (((output.extent.0 + -1)/128)*128) + 130], [(output.s0.y.y*4) + 3, 6])
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi) = uint8(((((((((int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))*(int16)2) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}


Forking asynchronous producers...
Lowering after forking asynchronous producers:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
let input.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 128) + 1) - -1
let input.min.0.required = -1
let input.stride.0.required = 1
let input.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 4) + 1) - -1
let input.min.1.required = -1
let input.stride.1.required = input.stride.0.required*input.extent.0.required
let output.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 127) + 1) - ((0*128) + 0)
let output.min.0.required = (0*128) + 0
let output.stride.0.required = 1
let output.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 3) + 1) - ((0*4) + 0)
let output.min.1.required = (0*4) + 0
let output.stride.1.required = output.stride.0.required*output.extent.0.required
let input.stride.0.constrained = 1
let input.min.0.constrained = 0
let input.stride.1.constrained = (input.stride.1/128)*128
let input.min.1.constrained = 0
let output.stride.0.constrained = 1
let output.min.0.constrained = 0
let output.stride.1.constrained = (output.stride.1/128)*128
let output.min.1.constrained = 0
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = (input.stride.1.required/128)*128
let input.min.1.proposed = 0
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = (output.stride.1.required/128)*128
let output.min.1.proposed = 0
let output.extent.1.proposed = output.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, (input.min.0.proposed + input.extent.0.proposed) - 1, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, (input.min.1.proposed + input.extent.1.proposed) - 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, (output.min.0.proposed + output.extent.0.proposed) - 1, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, (output.min.1.proposed + output.extent.1.proposed) - 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1))
assert((uint32)input.type == (uint32)67585, halide_error_bad_type("Input buffer input", (uint32)input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert((uint32)output.type == (uint32)67585, halide_error_bad_type("Output buffer output", (uint32)output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1, input.min.0, (input.min.0 + input.extent.0) - 1))
assert(input.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1, input.min.1, (input.min.1 + input.extent.1) - 1))
assert(input.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1, output.min.0, (output.min.0 + output.extent.0) - 1))
assert(output.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1, output.min.1, (output.min.1 + output.extent.1) - 1))
assert(output.extent.1 >= 0, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == input.stride.0.constrained, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
assert(input.min.0 == input.min.0.constrained, halide_error_constraint_violated("input.min.0", input.min.0, "0", input.min.0.constrained))
assert(input.stride.1 == input.stride.1.constrained, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", input.stride.1.constrained))
assert(input.min.1 == input.min.1.constrained, halide_error_constraint_violated("input.min.1", input.min.1, "0", input.min.1.constrained))
assert(output.stride.0 == output.stride.0.constrained, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
assert(output.min.0 == output.min.0.constrained, halide_error_constraint_violated("output.min.0", output.min.0, "0", output.min.0.constrained))
assert(output.stride.1 == output.stride.1.constrained, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", output.stride.1.constrained))
assert(output.min.1 == output.min.1.constrained, halide_error_constraint_violated("output.min.1", output.min.1, "0", output.min.1.constrained))
let input.total_extent.0 = int64(input.extent.0)
let input.total_extent.1 = int64(input.extent.1)*input.total_extent.0
let output.total_extent.0 = int64(output.extent.0)
let output.total_extent.1 = int64(output.extent.1)*output.total_extent.0
assert((uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
let output.s0.y.loop_max = output.extent.1 + -1
let output.s0.y.loop_min = 0
let output.s0.y.loop_extent = output.extent.1
let output.s0.x.loop_max = output.extent.0 + -1
let output.s0.x.loop_min = 0
let output.s0.x.loop_extent = output.extent.0
let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
let output.s0.x.x.loop_min = 0
let output.s0.x.xi.loop_extent = 128
let output.s0.x.xi.loop_max = 127
let output.s0.x.xi.loop_min = 0
let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
let output.s0.y.y.loop_min = 0
let output.s0.y.yi.loop_extent = 4
let output.s0.y.yi.loop_max = 3
let output.s0.y.yi.loop_min = 0
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   prefetch input([-1, (((output.extent.0 + -1)/128)*128) + 130], [(output.s0.y.y*4) + 3, 6])
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi) = uint8(((((((((int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))*(int16)2) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}

Destructuring tuple-valued realizations...
Lowering after destructuring tuple-valued realizations:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
let input.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 128) + 1) - -1
let input.min.0.required = -1
let input.stride.0.required = 1
let input.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 4) + 1) - -1
let input.min.1.required = -1
let input.stride.1.required = input.stride.0.required*input.extent.0.required
let output.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 127) + 1) - ((0*128) + 0)
let output.min.0.required = (0*128) + 0
let output.stride.0.required = 1
let output.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 3) + 1) - ((0*4) + 0)
let output.min.1.required = (0*4) + 0
let output.stride.1.required = output.stride.0.required*output.extent.0.required
let input.stride.0.constrained = 1
let input.min.0.constrained = 0
let input.stride.1.constrained = (input.stride.1/128)*128
let input.min.1.constrained = 0
let output.stride.0.constrained = 1
let output.min.0.constrained = 0
let output.stride.1.constrained = (output.stride.1/128)*128
let output.min.1.constrained = 0
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = (input.stride.1.required/128)*128
let input.min.1.proposed = 0
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = (output.stride.1.required/128)*128
let output.min.1.proposed = 0
let output.extent.1.proposed = output.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, (input.min.0.proposed + input.extent.0.proposed) - 1, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, (input.min.1.proposed + input.extent.1.proposed) - 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, (output.min.0.proposed + output.extent.0.proposed) - 1, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, (output.min.1.proposed + output.extent.1.proposed) - 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1))
assert((uint32)input.type == (uint32)67585, halide_error_bad_type("Input buffer input", (uint32)input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert((uint32)output.type == (uint32)67585, halide_error_bad_type("Output buffer output", (uint32)output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1, input.min.0, (input.min.0 + input.extent.0) - 1))
assert(input.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1, input.min.1, (input.min.1 + input.extent.1) - 1))
assert(input.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1, output.min.0, (output.min.0 + output.extent.0) - 1))
assert(output.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1, output.min.1, (output.min.1 + output.extent.1) - 1))
assert(output.extent.1 >= 0, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == input.stride.0.constrained, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
assert(input.min.0 == input.min.0.constrained, halide_error_constraint_violated("input.min.0", input.min.0, "0", input.min.0.constrained))
assert(input.stride.1 == input.stride.1.constrained, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", input.stride.1.constrained))
assert(input.min.1 == input.min.1.constrained, halide_error_constraint_violated("input.min.1", input.min.1, "0", input.min.1.constrained))
assert(output.stride.0 == output.stride.0.constrained, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
assert(output.min.0 == output.min.0.constrained, halide_error_constraint_violated("output.min.0", output.min.0, "0", output.min.0.constrained))
assert(output.stride.1 == output.stride.1.constrained, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", output.stride.1.constrained))
assert(output.min.1 == output.min.1.constrained, halide_error_constraint_violated("output.min.1", output.min.1, "0", output.min.1.constrained))
let input.total_extent.0 = int64(input.extent.0)
let input.total_extent.1 = int64(input.extent.1)*input.total_extent.0
let output.total_extent.0 = int64(output.extent.0)
let output.total_extent.1 = int64(output.extent.1)*output.total_extent.0
assert((uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
let output.s0.y.loop_max = output.extent.1 + -1
let output.s0.y.loop_min = 0
let output.s0.y.loop_extent = output.extent.1
let output.s0.x.loop_max = output.extent.0 + -1
let output.s0.x.loop_min = 0
let output.s0.x.loop_extent = output.extent.0
let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
let output.s0.x.x.loop_min = 0
let output.s0.x.xi.loop_extent = 128
let output.s0.x.xi.loop_max = 127
let output.s0.x.xi.loop_min = 0
let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
let output.s0.y.y.loop_min = 0
let output.s0.y.yi.loop_extent = 4
let output.s0.y.yi.loop_max = 3
let output.s0.y.yi.loop_min = 0
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   prefetch input([-1, (((output.extent.0 + -1)/128)*128) + 130], [(output.s0.y.y*4) + 3, 6])
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi) = uint8(((((((((int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))*(int16)2) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}


Bounding small realizations...
Lowering after bounding small realizations:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
let input.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 128) + 1) - -1
let input.min.0.required = -1
let input.stride.0.required = 1
let input.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 4) + 1) - -1
let input.min.1.required = -1
let input.stride.1.required = input.stride.0.required*input.extent.0.required
let output.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 127) + 1) - ((0*128) + 0)
let output.min.0.required = (0*128) + 0
let output.stride.0.required = 1
let output.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 3) + 1) - ((0*4) + 0)
let output.min.1.required = (0*4) + 0
let output.stride.1.required = output.stride.0.required*output.extent.0.required
let input.stride.0.constrained = 1
let input.min.0.constrained = 0
let input.stride.1.constrained = (input.stride.1/128)*128
let input.min.1.constrained = 0
let output.stride.0.constrained = 1
let output.min.0.constrained = 0
let output.stride.1.constrained = (output.stride.1/128)*128
let output.min.1.constrained = 0
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = (input.stride.1.required/128)*128
let input.min.1.proposed = 0
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = (output.stride.1.required/128)*128
let output.min.1.proposed = 0
let output.extent.1.proposed = output.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, (input.min.0.proposed + input.extent.0.proposed) - 1, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, (input.min.1.proposed + input.extent.1.proposed) - 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, (output.min.0.proposed + output.extent.0.proposed) - 1, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, (output.min.1.proposed + output.extent.1.proposed) - 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1))
assert((uint32)input.type == (uint32)67585, halide_error_bad_type("Input buffer input", (uint32)input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert((uint32)output.type == (uint32)67585, halide_error_bad_type("Output buffer output", (uint32)output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1, input.min.0, (input.min.0 + input.extent.0) - 1))
assert(input.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1, input.min.1, (input.min.1 + input.extent.1) - 1))
assert(input.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1, output.min.0, (output.min.0 + output.extent.0) - 1))
assert(output.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1, output.min.1, (output.min.1 + output.extent.1) - 1))
assert(output.extent.1 >= 0, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == input.stride.0.constrained, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
assert(input.min.0 == input.min.0.constrained, halide_error_constraint_violated("input.min.0", input.min.0, "0", input.min.0.constrained))
assert(input.stride.1 == input.stride.1.constrained, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", input.stride.1.constrained))
assert(input.min.1 == input.min.1.constrained, halide_error_constraint_violated("input.min.1", input.min.1, "0", input.min.1.constrained))
assert(output.stride.0 == output.stride.0.constrained, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
assert(output.min.0 == output.min.0.constrained, halide_error_constraint_violated("output.min.0", output.min.0, "0", output.min.0.constrained))
assert(output.stride.1 == output.stride.1.constrained, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", output.stride.1.constrained))
assert(output.min.1 == output.min.1.constrained, halide_error_constraint_violated("output.min.1", output.min.1, "0", output.min.1.constrained))
let input.total_extent.0 = int64(input.extent.0)
let input.total_extent.1 = int64(input.extent.1)*input.total_extent.0
let output.total_extent.0 = int64(output.extent.0)
let output.total_extent.1 = int64(output.extent.1)*output.total_extent.0
assert((uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
let output.s0.y.loop_max = output.extent.1 + -1
let output.s0.y.loop_min = 0
let output.s0.y.loop_extent = output.extent.1
let output.s0.x.loop_max = output.extent.0 + -1
let output.s0.x.loop_min = 0
let output.s0.x.loop_extent = output.extent.0
let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
let output.s0.x.x.loop_min = 0
let output.s0.x.xi.loop_extent = 128
let output.s0.x.xi.loop_max = 127
let output.s0.x.xi.loop_min = 0
let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
let output.s0.y.y.loop_min = 0
let output.s0.y.yi.loop_extent = 4
let output.s0.y.yi.loop_max = 3
let output.s0.y.yi.loop_min = 0
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   prefetch input([-1, (((output.extent.0 + -1)/128)*128) + 130], [(output.s0.y.y*4) + 3, 6])
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi) = uint8(((((((((int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input((output.s0.x.x*128) + output.s0.x.xi, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))*(int16)2) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + -1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (((int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, (output.s0.y.y*4) + output.s0.y.yi))*(int16)2) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + -1))) + int16((uint8)input(((output.s0.x.x*128) + output.s0.x.xi) + 1, ((output.s0.y.y*4) + output.s0.y.yi) + 1)))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}


Performing storage flattening...
Lowering after storage flattening:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
let input.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 128) + 1) - -1
let input.min.0.required = -1
let input.stride.0.required = 1
let input.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 4) + 1) - -1
let input.min.1.required = -1
let input.stride.1.required = input.stride.0.required*input.extent.0.required
let output.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 127) + 1) - ((0*128) + 0)
let output.min.0.required = (0*128) + 0
let output.stride.0.required = 1
let output.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 3) + 1) - ((0*4) + 0)
let output.min.1.required = (0*4) + 0
let output.stride.1.required = output.stride.0.required*output.extent.0.required
let input.stride.0.constrained = 1
let input.min.0.constrained = 0
let input.stride.1.constrained = (input.stride.1/128)*128
let input.min.1.constrained = 0
let output.stride.0.constrained = 1
let output.min.0.constrained = 0
let output.stride.1.constrained = (output.stride.1/128)*128
let output.min.1.constrained = 0
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = (input.stride.1.required/128)*128
let input.min.1.proposed = 0
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = (output.stride.1.required/128)*128
let output.min.1.proposed = 0
let output.extent.1.proposed = output.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, (input.min.0.proposed + input.extent.0.proposed) - 1, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, (input.min.1.proposed + input.extent.1.proposed) - 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, (output.min.0.proposed + output.extent.0.proposed) - 1, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, (output.min.1.proposed + output.extent.1.proposed) - 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1))
assert((uint32)input.type == (uint32)67585, halide_error_bad_type("Input buffer input", (uint32)input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert((uint32)output.type == (uint32)67585, halide_error_bad_type("Output buffer output", (uint32)output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1, input.min.0, (input.min.0 + input.extent.0) - 1))
assert(input.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1, input.min.1, (input.min.1 + input.extent.1) - 1))
assert(input.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1, output.min.0, (output.min.0 + output.extent.0) - 1))
assert(output.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1, output.min.1, (output.min.1 + output.extent.1) - 1))
assert(output.extent.1 >= 0, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == input.stride.0.constrained, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
assert(input.min.0 == input.min.0.constrained, halide_error_constraint_violated("input.min.0", input.min.0, "0", input.min.0.constrained))
assert(input.stride.1 == input.stride.1.constrained, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", input.stride.1.constrained))
assert(input.min.1 == input.min.1.constrained, halide_error_constraint_violated("input.min.1", input.min.1, "0", input.min.1.constrained))
assert(output.stride.0 == output.stride.0.constrained, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
assert(output.min.0 == output.min.0.constrained, halide_error_constraint_violated("output.min.0", output.min.0, "0", output.min.0.constrained))
assert(output.stride.1 == output.stride.1.constrained, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", output.stride.1.constrained))
assert(output.min.1 == output.min.1.constrained, halide_error_constraint_violated("output.min.1", output.min.1, "0", output.min.1.constrained))
let input.total_extent.0 = int64(input.extent.0)
let input.total_extent.1 = int64(input.extent.1)*input.total_extent.0
let output.total_extent.0 = int64(output.extent.0)
let output.total_extent.1 = int64(output.extent.1)*output.total_extent.0
assert((uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
let output.s0.y.loop_max = output.extent.1 + -1
let output.s0.y.loop_min = 0
let output.s0.y.loop_extent = output.extent.1
let output.s0.x.loop_max = output.extent.0 + -1
let output.s0.x.loop_min = 0
let output.s0.x.loop_extent = output.extent.0
let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
let output.s0.x.x.loop_min = 0
let output.s0.x.xi.loop_extent = 128
let output.s0.x.xi.loop_max = 127
let output.s0.x.xi.loop_min = 0
let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
let output.s0.y.y.loop_min = 0
let output.s0.y.yi.loop_extent = 4
let output.s0.y.yi.loop_max = 3
let output.s0.y.yi.loop_min = 0
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch((void *)input, (((0 + (-1*input.stride.0)) + ((output.s0.y.y*4)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.1*3)), (((output.extent.0 + -1)/128)*128) + 130, input.stride.0, 6, input.stride.1)
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output[((0 + (((output.s0.x.x*128) + output.s0.x.xi)*output.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*output.stride.1)) - ((0 + (output.min.0*output.stride.0)) + (output.min.1*output.stride.1))] = uint8(((((((((int16((uint8)input[((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))])*(int16)2) + int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.1*-1))])) + int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.1*1))]))*(int16)2) + (((int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.0*-1))])*(int16)2) + int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + ((0 + (input.stride.0*-1)) + (input.stride.1*-1))])) + int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + ((0 + (input.stride.0*-1)) + (input.stride.1*1))]))) + (((int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.0*1))])*(int16)2) + int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + ((0 + (input.stride.0*1)) + (input.stride.1*-1))])) + int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + ((0 + (input.stride.0*1)) + (input.stride.1*1))]))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}


Adding atomic mutex allocation...
Lowering after adding atomic mutex allocation:
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
let input.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 128) + 1) - -1
let input.min.0.required = -1
let input.stride.0.required = 1
let input.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 4) + 1) - -1
let input.min.1.required = -1
let input.stride.1.required = input.stride.0.required*input.extent.0.required
let output.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 127) + 1) - ((0*128) + 0)
let output.min.0.required = (0*128) + 0
let output.stride.0.required = 1
let output.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 3) + 1) - ((0*4) + 0)
let output.min.1.required = (0*4) + 0
let output.stride.1.required = output.stride.0.required*output.extent.0.required
let input.stride.0.constrained = 1
let input.min.0.constrained = 0
let input.stride.1.constrained = (input.stride.1/128)*128
let input.min.1.constrained = 0
let output.stride.0.constrained = 1
let output.min.0.constrained = 0
let output.stride.1.constrained = (output.stride.1/128)*128
let output.min.1.constrained = 0
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = (input.stride.1.required/128)*128
let input.min.1.proposed = 0
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = (output.stride.1.required/128)*128
let output.min.1.proposed = 0
let output.extent.1.proposed = output.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, (input.min.0.proposed + input.extent.0.proposed) - 1, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, (input.min.1.proposed + input.extent.1.proposed) - 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, (output.min.0.proposed + output.extent.0.proposed) - 1, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, (output.min.1.proposed + output.extent.1.proposed) - 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1))
assert((uint32)input.type == (uint32)67585, halide_error_bad_type("Input buffer input", (uint32)input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert((uint32)output.type == (uint32)67585, halide_error_bad_type("Output buffer output", (uint32)output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1, input.min.0, (input.min.0 + input.extent.0) - 1))
assert(input.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1, input.min.1, (input.min.1 + input.extent.1) - 1))
assert(input.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1, output.min.0, (output.min.0 + output.extent.0) - 1))
assert(output.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1, output.min.1, (output.min.1 + output.extent.1) - 1))
assert(output.extent.1 >= 0, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == input.stride.0.constrained, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
assert(input.min.0 == input.min.0.constrained, halide_error_constraint_violated("input.min.0", input.min.0, "0", input.min.0.constrained))
assert(input.stride.1 == input.stride.1.constrained, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", input.stride.1.constrained))
assert(input.min.1 == input.min.1.constrained, halide_error_constraint_violated("input.min.1", input.min.1, "0", input.min.1.constrained))
assert(output.stride.0 == output.stride.0.constrained, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
assert(output.min.0 == output.min.0.constrained, halide_error_constraint_violated("output.min.0", output.min.0, "0", output.min.0.constrained))
assert(output.stride.1 == output.stride.1.constrained, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", output.stride.1.constrained))
assert(output.min.1 == output.min.1.constrained, halide_error_constraint_violated("output.min.1", output.min.1, "0", output.min.1.constrained))
let input.total_extent.0 = int64(input.extent.0)
let input.total_extent.1 = int64(input.extent.1)*input.total_extent.0
let output.total_extent.0 = int64(output.extent.0)
let output.total_extent.1 = int64(output.extent.1)*output.total_extent.0
assert((uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
let output.s0.y.loop_max = output.extent.1 + -1
let output.s0.y.loop_min = 0
let output.s0.y.loop_extent = output.extent.1
let output.s0.x.loop_max = output.extent.0 + -1
let output.s0.x.loop_min = 0
let output.s0.x.loop_extent = output.extent.0
let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
let output.s0.x.x.loop_min = 0
let output.s0.x.xi.loop_extent = 128
let output.s0.x.xi.loop_max = 127
let output.s0.x.xi.loop_min = 0
let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
let output.s0.y.y.loop_min = 0
let output.s0.y.yi.loop_extent = 4
let output.s0.y.yi.loop_max = 3
let output.s0.y.yi.loop_min = 0
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch((void *)input, (((0 + (-1*input.stride.0)) + ((output.s0.y.y*4)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.1*3)), (((output.extent.0 + -1)/128)*128) + 130, input.stride.0, 6, input.stride.1)
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output[((0 + (((output.s0.x.x*128) + output.s0.x.xi)*output.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*output.stride.1)) - ((0 + (output.min.0*output.stride.0)) + (output.min.1*output.stride.1))] = uint8(((((((((int16((uint8)input[((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))])*(int16)2) + int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.1*-1))])) + int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.1*1))]))*(int16)2) + (((int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.0*-1))])*(int16)2) + int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + ((0 + (input.stride.0*-1)) + (input.stride.1*-1))])) + int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + ((0 + (input.stride.0*-1)) + (input.stride.1*1))]))) + (((int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.0*1))])*(int16)2) + int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + ((0 + (input.stride.0*1)) + (input.stride.1*-1))])) + int16((uint8)input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + ((0 + (input.stride.0*1)) + (input.stride.1*1))]))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}


Unpacking buffer arguments...
Lowering after unpacking buffer arguments...
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
let output.s0.y.max = output.extent.1 + -1
let output.s0.y.min = 0
let output.s0.x.max = output.extent.0 + -1
let output.s0.x.min = 0
let input.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 128) + 1) - -1
let input.min.0.required = -1
let input.stride.0.required = 1
let input.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 4) + 1) - -1
let input.min.1.required = -1
let input.stride.1.required = input.stride.0.required*input.extent.0.required
let output.extent.0.required = (((((output.extent.0 + -1)/128)*128) + 127) + 1) - ((0*128) + 0)
let output.min.0.required = (0*128) + 0
let output.stride.0.required = 1
let output.extent.1.required = (((((output.extent.1 + -1)/4)*4) + 3) + 1) - ((0*4) + 0)
let output.min.1.required = (0*4) + 0
let output.stride.1.required = output.stride.0.required*output.extent.0.required
let input.stride.0.constrained = 1
let input.min.0.constrained = 0
let input.stride.1.constrained = (input.stride.1/128)*128
let input.min.1.constrained = 0
let output.stride.0.constrained = 1
let output.min.0.constrained = 0
let output.stride.1.constrained = (output.stride.1/128)*128
let output.min.1.constrained = 0
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = (input.stride.1.required/128)*128
let input.min.1.proposed = 0
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = (output.stride.1.required/128)*128
let output.min.1.proposed = 0
let output.extent.1.proposed = output.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, (input.min.0.proposed + input.extent.0.proposed) - 1, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, (input.min.1.proposed + input.extent.1.proposed) - 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, (output.min.0.proposed + output.extent.0.proposed) - 1, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, (output.min.1.proposed + output.extent.1.proposed) - 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, (input.min.0.required + input.extent.0.required) - 1, input.min.0, (input.min.0 + input.extent.0) - 1))
assert(input.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, (input.min.1.required + input.extent.1.required) - 1, input.min.1, (input.min.1 + input.extent.1) - 1))
assert(input.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, (output.min.0.required + output.extent.0.required) - 1, output.min.0, (output.min.0 + output.extent.0) - 1))
assert(output.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, (output.min.1.required + output.extent.1.required) - 1, output.min.1, (output.min.1 + output.extent.1) - 1))
assert(output.extent.1 >= 0, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == input.stride.0.constrained, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
assert(input.min.0 == input.min.0.constrained, halide_error_constraint_violated("input.min.0", input.min.0, "0", input.min.0.constrained))
assert(input.stride.1 == input.stride.1.constrained, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", input.stride.1.constrained))
assert(input.min.1 == input.min.1.constrained, halide_error_constraint_violated("input.min.1", input.min.1, "0", input.min.1.constrained))
assert(output.stride.0 == output.stride.0.constrained, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
assert(output.min.0 == output.min.0.constrained, halide_error_constraint_violated("output.min.0", output.min.0, "0", output.min.0.constrained))
assert(output.stride.1 == output.stride.1.constrained, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", output.stride.1.constrained))
assert(output.min.1 == output.min.1.constrained, halide_error_constraint_violated("output.min.1", output.min.1, "0", output.min.1.constrained))
let input.total_extent.0 = int64(input.extent.0)
let input.total_extent.1 = int64(input.extent.1)*input.total_extent.0
let output.total_extent.0 = int64(output.extent.0)
let output.total_extent.1 = int64(output.extent.1)*output.total_extent.0
assert((uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)*int64(input.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1.constrained)), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)*int64(output.stride.0.constrained)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(output.stride.1.constrained)), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
let output.s0.y.loop_max = output.extent.1 + -1
let output.s0.y.loop_min = 0
let output.s0.y.loop_extent = output.extent.1
let output.s0.x.loop_max = output.extent.0 + -1
let output.s0.x.loop_min = 0
let output.s0.x.loop_extent = output.extent.0
let output.s0.x.x.loop_extent = (output.extent.0 + 127)/128
let output.s0.x.x.loop_max = (output.extent.0 + -1)/128
let output.s0.x.x.loop_min = 0
let output.s0.x.xi.loop_extent = 128
let output.s0.x.xi.loop_max = 127
let output.s0.x.xi.loop_min = 0
let output.s0.y.y.loop_extent = (output.extent.1 + 3)/4
let output.s0.y.y.loop_max = (output.extent.1 + -1)/4
let output.s0.y.y.loop_min = 0
let output.s0.y.yi.loop_extent = 4
let output.s0.y.yi.loop_max = 3
let output.s0.y.yi.loop_min = 0
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, (((0 + (-1*input.stride.0)) + ((output.s0.y.y*4)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.1*3)), (((output.extent.0 + -1)/128)*128) + 130, input.stride.0, 6, input.stride.1)
   let output.s0.y.yi.base = output.s0.y.y*4
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let output.s0.x.xi.base = output.s0.x.x*128
    unrolled (output.s0.y.yi, 0, 4) {
     let output.s0.y = (output.s0.y.y*4) + output.s0.y.yi
     vectorized (output.s0.x.xi, 0, 128) {
      let output.s0.x = (output.s0.x.x*128) + output.s0.x.xi
      output[((0 + (((output.s0.x.x*128) + output.s0.x.xi)*output.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*output.stride.1)) - ((0 + (output.min.0*output.stride.0)) + (output.min.1*output.stride.1))] = uint8(((((((((int16(input[((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))])*(int16)2) + int16(input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.1*-1))])) + int16(input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.1*1))]))*(int16)2) + (((int16(input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.0*-1))])*(int16)2) + int16(input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + ((0 + (input.stride.0*-1)) + (input.stride.1*-1))])) + int16(input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + ((0 + (input.stride.0*-1)) + (input.stride.1*1))]))) + (((int16(input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + (0 + (input.stride.0*1))])*(int16)2) + int16(input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + ((0 + (input.stride.0*1)) + (input.stride.1*-1))])) + int16(input[(((0 + (((output.s0.x.x*128) + output.s0.x.xi)*input.stride.0)) + (((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1)) - ((0 + (input.min.0*input.stride.0)) + (input.min.1*input.stride.1))) + ((0 + (input.stride.0*1)) + (input.stride.1*1))]))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}


Skipping rewriting memoized allocations...
Simplifying...
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.0", input.min.0, "0", 0)
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.1", input.min.1, "0", 0)
Lowering after second simplifcation:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
0
0
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, ((input.stride.1*3) + (((input.stride.1*output.s0.y.y)*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    unrolled (output.s0.y.yi, 0, 4) {
     vectorized (output.s0.x.xi, 0, 128) {
      output[(((output.s0.y.y*4) + output.s0.y.yi)*output.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)] = uint8(((((((((int16(input[((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)])*(int16)2) + int16(input[(input.stride.1*-1) + (((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))])) + int16(input[(((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1]))*(int16)2) + (((int16(input[(((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + -1])*(int16)2) + int16(input[((input.stride.1*-1) + (((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + -1])) + int16(input[((((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1]))) + (((int16(input[(((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + 1])*(int16)2) + int16(input[((input.stride.1*-1) + (((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + 1])) + int16(input[((((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1]))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}


Reduce prefetch dimension...
Lowering after reduce prefetch dimension:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
0
0
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, ((input.stride.1*3) + (((input.stride.1*output.s0.y.y)*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    unrolled (output.s0.y.yi, 0, 4) {
     vectorized (output.s0.x.xi, 0, 128) {
      output[(((output.s0.y.y*4) + output.s0.y.yi)*output.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)] = uint8(((((((((int16(input[((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)])*(int16)2) + int16(input[(input.stride.1*-1) + (((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))])) + int16(input[(((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1]))*(int16)2) + (((int16(input[(((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + -1])*(int16)2) + int16(input[((input.stride.1*-1) + (((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + -1])) + int16(input[((((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1]))) + (((int16(input[(((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + 1])*(int16)2) + int16(input[((input.stride.1*-1) + (((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + 1])) + int16(input[((((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1]))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}

Simplifying correlated differences...
Lowering after simplifying correlated differences:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
0
0
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, ((input.stride.1*3) + (((input.stride.1*output.s0.y.y)*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    unrolled (output.s0.y.yi, 0, 4) {
     vectorized (output.s0.x.xi, 0, 128) {
      output[(((output.s0.y.y*4) + output.s0.y.yi)*output.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)] = uint8(((((((((int16(input[((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)])*(int16)2) + int16(input[(input.stride.1*-1) + (((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))])) + int16(input[(((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1]))*(int16)2) + (((int16(input[(((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + -1])*(int16)2) + int16(input[((input.stride.1*-1) + (((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + -1])) + int16(input[((((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1]))) + (((int16(input[(((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + 1])*(int16)2) + int16(input[((input.stride.1*-1) + (((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + 1])) + int16(input[((((((output.s0.y.y*4) + output.s0.y.yi)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1]))) + (int16)8)/(int16)16))
     }
    }
   }
  }
 }
}

Unrolling...
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.0", input.min.0, "0", 0)
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.1", input.min.1, "0", 0)
Lowering after unrolling:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, ((input.stride.1*3) + (((input.stride.1*output.s0.y.y)*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    vectorized (output.s0.x.xi, 0, 128) {
     output[((output.s0.y.y*output.stride.1)*4) + ((output.s0.x.x*128) + output.s0.x.xi)] = uint8(((((((((int16(input[(((input.stride.1*output.s0.y.y)*4) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)])*(int16)2) + int16(input[(input.stride.1*-1) + ((((input.stride.1*output.s0.y.y)*4) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))])) + int16(input[((((input.stride.1*output.s0.y.y)*4) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1]))*(int16)2) + (((int16(input[((((input.stride.1*output.s0.y.y)*4) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + -1])*(int16)2) + int16(input[((input.stride.1*-1) + ((((input.stride.1*output.s0.y.y)*4) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + -1])) + int16(input[(((((input.stride.1*output.s0.y.y)*4) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1]))) + (((int16(input[((((input.stride.1*output.s0.y.y)*4) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + 1])*(int16)2) + int16(input[((input.stride.1*-1) + ((((input.stride.1*output.s0.y.y)*4) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + 1])) + int16(input[(((((input.stride.1*output.s0.y.y)*4) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1]))) + (int16)8)/(int16)16))
    }
    vectorized (output.s0.x.xi, 0, 128) {
     output[(((output.s0.y.y*4) + 1)*output.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)] = uint8(((((((((int16(input[((((output.s0.y.y*4) + 1)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)])*(int16)2) + int16(input[(input.stride.1*-1) + (((((output.s0.y.y*4) + 1)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))])) + int16(input[(((((output.s0.y.y*4) + 1)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1]))*(int16)2) + (((int16(input[(((((output.s0.y.y*4) + 1)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + -1])*(int16)2) + int16(input[((input.stride.1*-1) + (((((output.s0.y.y*4) + 1)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + -1])) + int16(input[((((((output.s0.y.y*4) + 1)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1]))) + (((int16(input[(((((output.s0.y.y*4) + 1)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + 1])*(int16)2) + int16(input[((input.stride.1*-1) + (((((output.s0.y.y*4) + 1)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + 1])) + int16(input[((((((output.s0.y.y*4) + 1)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1]))) + (int16)8)/(int16)16))
    }
    vectorized (output.s0.x.xi, 0, 128) {
     output[(((output.s0.y.y*4) + 2)*output.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)] = uint8(((((((((int16(input[((((output.s0.y.y*4) + 2)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)])*(int16)2) + int16(input[(input.stride.1*-1) + (((((output.s0.y.y*4) + 2)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))])) + int16(input[(((((output.s0.y.y*4) + 2)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1]))*(int16)2) + (((int16(input[(((((output.s0.y.y*4) + 2)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + -1])*(int16)2) + int16(input[((input.stride.1*-1) + (((((output.s0.y.y*4) + 2)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + -1])) + int16(input[((((((output.s0.y.y*4) + 2)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1]))) + (((int16(input[(((((output.s0.y.y*4) + 2)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + 1])*(int16)2) + int16(input[((input.stride.1*-1) + (((((output.s0.y.y*4) + 2)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + 1])) + int16(input[((((((output.s0.y.y*4) + 2)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1]))) + (int16)8)/(int16)16))
    }
    vectorized (output.s0.x.xi, 0, 128) {
     output[(((output.s0.y.y*4) + 3)*output.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)] = uint8(((((((((int16(input[((((output.s0.y.y*4) + 3)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)])*(int16)2) + int16(input[(input.stride.1*-1) + (((((output.s0.y.y*4) + 3)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))])) + int16(input[(((((output.s0.y.y*4) + 3)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1]))*(int16)2) + (((int16(input[(((((output.s0.y.y*4) + 3)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + -1])*(int16)2) + int16(input[((input.stride.1*-1) + (((((output.s0.y.y*4) + 3)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + -1])) + int16(input[((((((output.s0.y.y*4) + 3)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1]))) + (((int16(input[(((((output.s0.y.y*4) + 3)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + 1])*(int16)2) + int16(input[((input.stride.1*-1) + (((((output.s0.y.y*4) + 3)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0))) + 1])) + int16(input[((((((output.s0.y.y*4) + 3)*input.stride.1) + ((output.s0.x.x*128) + output.s0.x.xi)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1]))) + (int16)8)/(int16)16))
    }
   }
  }
 }
}


Vectorizing...
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.0", input.min.0, "0", 0)
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.1", input.min.1, "0", 0)
Lowering after vectorizing:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, ((input.stride.1*3) + (((input.stride.1*output.s0.y.y)*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    output[ramp(((output.s0.x.x*32) + (output.s0.y.y*output.stride.1))*4, 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}


Detecting vector interleavings...
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.0", input.min.0, "0", 0)
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.1", input.min.1, "0", 0)
Lowering after rewriting vector interleavings:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, ((input.stride.1*3) + (((input.stride.1*output.s0.y.y)*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    output[ramp(((output.s0.x.x*32) + (output.s0.y.y*output.stride.1))*4, 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}


Partitioning loops to simplify boundary conditions...
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.0", input.min.0, "0", 0)
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.1", input.min.1, "0", 0)
Lowering after partitioning loops:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, ((input.stride.1*3) + (((input.stride.1*output.s0.y.y)*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    output[ramp(((output.s0.x.x*32) + (output.s0.y.y*output.stride.1))*4, 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}


Trimming loops to the region over which they do something...
Lowering after loop trimming:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, ((input.stride.1*3) + (((input.stride.1*output.s0.y.y)*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    output[ramp(((output.s0.x.x*32) + (output.s0.y.y*output.stride.1))*4, 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}


Hoisting loop invariant if statements...
Lowering after hoisting loop invariant if statements:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, ((input.stride.1*3) + (((input.stride.1*output.s0.y.y)*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    output[ramp(((output.s0.x.x*32) + (output.s0.y.y*output.stride.1))*4, 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}


Injecting early frees...
Lowering after injecting early frees:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, ((input.stride.1*3) + (((input.stride.1*output.s0.y.y)*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    output[ramp(((output.s0.x.x*32) + (output.s0.y.y*output.stride.1))*4, 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}


Simplifying correlated differences...
Lowering after simplifying correlated differences:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, ((input.stride.1*3) + (((input.stride.1*output.s0.y.y)*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    output[ramp(((output.s0.x.x*32) + (output.s0.y.y*output.stride.1))*4, 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}

Bounding small allocations...
Lowering after bounding small allocations:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, ((input.stride.1*3) + (((input.stride.1*output.s0.y.y)*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    output[ramp(((output.s0.x.x*32) + (output.s0.y.y*output.stride.1))*4, 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp(((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + ((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp((((((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0), 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)), 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + -1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + -1, 1, 128)]))) + (((int16x128(input[ramp((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + (((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0))) + 1, 1, 128)])) + int16x128(input[ramp(((((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)) + input.stride.1) + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}


Simplifying...
Lowering unsafe promises...
Lowering after lowering unsafe promises:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, ((input.stride.1*3) + (((input.stride.1*output.s0.y.y)*4) - ((input.min.1*input.stride.1) + input.min.0))) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let t6 = (((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)
    let t7 = (input.stride.1*-1) + t6
    let t8 = t6 + input.stride.1
    output[ramp(((output.s0.x.x*32) + (output.s0.y.y*output.stride.1))*4, 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(t6, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t7, 1, 128)])) + int16x128(input[ramp(t8, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp(t6 + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t7 + -1, 1, 128)])) + int16x128(input[ramp(t8 + -1, 1, 128)]))) + (((int16x128(input[ramp(t6 + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t7 + 1, 1, 128)])) + int16x128(input[ramp(t8 + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    let t9 = ((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)
    let t10 = (input.stride.1*-1) + t9
    let t11 = t9 + input.stride.1
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(t9, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t10, 1, 128)])) + int16x128(input[ramp(t11, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp(t9 + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t10 + -1, 1, 128)])) + int16x128(input[ramp(t11 + -1, 1, 128)]))) + (((int16x128(input[ramp(t9 + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t10 + 1, 1, 128)])) + int16x128(input[ramp(t11 + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    let t12 = ((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)
    let t13 = (input.stride.1*-1) + t12
    let t14 = t12 + input.stride.1
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(t12, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t13, 1, 128)])) + int16x128(input[ramp(t14, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp(t12 + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t13 + -1, 1, 128)])) + int16x128(input[ramp(t14 + -1, 1, 128)]))) + (((int16x128(input[ramp(t12 + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t13 + 1, 1, 128)])) + int16x128(input[ramp(t14 + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
    let t15 = ((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*input.stride.1)) - ((input.min.1*input.stride.1) + input.min.0)
    let t16 = (input.stride.1*-1) + t15
    let t17 = t15 + input.stride.1
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((((int16x128(input[ramp(t15, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t16, 1, 128)])) + int16x128(input[ramp(t17, 1, 128)]))*x128((int16)2)) + (((int16x128(input[ramp(t15 + -1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t16 + -1, 1, 128)])) + int16x128(input[ramp(t17 + -1, 1, 128)]))) + (((int16x128(input[ramp(t15 + 1, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t16 + 1, 1, 128)])) + int16x128(input[ramp(t17 + 1, 1, 128)]))) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}


User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.0", input.min.0, "0", 0)
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.1", input.min.1, "0", 0)
Lowering after final simplification:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 let t26 = (output.extent.1 + 3)/4
 let t29 = (output.extent.0 + 127)/128
 let t28 = ((output.extent.0 + -1)/128)*128
 let t27 = ((3 - input.min.1)*input.stride.1) - input.min.0
 let t30 = (input.min.1*input.stride.1) + input.min.0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, t26) {
   (uint8)prefetch(input, (((input.stride.1*output.s0.y.y)*4) + t27) + -1, t28 + 130, 1, 6, input.stride.1)
   let t42 = output.s0.y.y*4
   let t43 = t42 + 1
   let t44 = t42 + 2
   let t45 = t42 + 3
   let t41 = output.stride.1*t45
   let t39 = output.stride.1*t44
   let t37 = output.stride.1*t43
   let t35 = output.s0.y.y*output.stride.1
   let t33 = input.stride.1*output.s0.y.y
   let t40 = (input.stride.1*t45) - t30
   let t38 = (input.stride.1*t44) - t30
   let t36 = (input.stride.1*t43) - t30
   for (output.s0.x.x, 0, t29) {
    let t6 = (((output.s0.x.x*32) + t33)*4) - t30
    let t18 = (input.stride.1*-1) + t6
    let t19 = input.stride.1 + t6
    output[ramp(((output.s0.x.x*32) + t35)*4, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t6 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t6, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t18, 1, 128)])) + int16x128(input[ramp(t19, 1, 128)])) + int16x128(input[ramp(t6 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t18 + -1, 1, 128)])) + int16x128(input[ramp(t19 + -1, 1, 128)]))) + int16x128(input[ramp(t18 + 1, 1, 128)])) + int16x128(input[ramp(t19 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t9 = (output.s0.x.x*128) + t36
    let t20 = (input.stride.1*-1) + t9
    let t21 = input.stride.1 + t9
    output[ramp((output.s0.x.x*128) + t37, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t9 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t9, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t20, 1, 128)])) + int16x128(input[ramp(t21, 1, 128)])) + int16x128(input[ramp(t9 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t20 + -1, 1, 128)])) + int16x128(input[ramp(t21 + -1, 1, 128)]))) + int16x128(input[ramp(t20 + 1, 1, 128)])) + int16x128(input[ramp(t21 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t12 = (output.s0.x.x*128) + t38
    let t22 = (input.stride.1*-1) + t12
    let t23 = input.stride.1 + t12
    output[ramp((output.s0.x.x*128) + t39, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t12 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t12, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t22, 1, 128)])) + int16x128(input[ramp(t23, 1, 128)])) + int16x128(input[ramp(t12 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t22 + -1, 1, 128)])) + int16x128(input[ramp(t23 + -1, 1, 128)]))) + int16x128(input[ramp(t22 + 1, 1, 128)])) + int16x128(input[ramp(t23 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t15 = (output.s0.x.x*128) + t40
    let t24 = (input.stride.1*-1) + t15
    let t25 = input.stride.1 + t15
    output[ramp((output.s0.x.x*128) + t41, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t15 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t15, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t24, 1, 128)])) + int16x128(input[ramp(t25, 1, 128)])) + int16x128(input[ramp(t15 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t24 + -1, 1, 128)])) + int16x128(input[ramp(t25 + -1, 1, 128)]))) + int16x128(input[ramp(t24 + 1, 1, 128)])) + int16x128(input[ramp(t25 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}


Skipping Hexagon offload...
Target triple of initial module: hexagon-unknown--elf
Generating llvm bitcode...
Generating llvm bitcode prolog for function gaussian3x3_hvx128...
Unpredicating loads and stores...
Lowering after unpredicating loads/stores:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 let t26 = (output.extent.1 + 3)/4
 let t29 = (output.extent.0 + 127)/128
 let t28 = ((output.extent.0 + -1)/128)*128
 let t27 = ((3 - input.min.1)*input.stride.1) - input.min.0
 let t30 = (input.min.1*input.stride.1) + input.min.0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, t26) {
   (uint8)prefetch(input, (((input.stride.1*output.s0.y.y)*4) + t27) + -1, t28 + 130, 1, 6, input.stride.1)
   let t42 = output.s0.y.y*4
   let t43 = t42 + 1
   let t44 = t42 + 2
   let t45 = t42 + 3
   let t41 = output.stride.1*t45
   let t39 = output.stride.1*t44
   let t37 = output.stride.1*t43
   let t35 = output.s0.y.y*output.stride.1
   let t33 = input.stride.1*output.s0.y.y
   let t40 = (input.stride.1*t45) - t30
   let t38 = (input.stride.1*t44) - t30
   let t36 = (input.stride.1*t43) - t30
   for (output.s0.x.x, 0, t29) {
    let t6 = (((output.s0.x.x*32) + t33)*4) - t30
    let t18 = (input.stride.1*-1) + t6
    let t19 = input.stride.1 + t6
    output[ramp(((output.s0.x.x*32) + t35)*4, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t6 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t6, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t18, 1, 128)])) + int16x128(input[ramp(t19, 1, 128)])) + int16x128(input[ramp(t6 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t18 + -1, 1, 128)])) + int16x128(input[ramp(t19 + -1, 1, 128)]))) + int16x128(input[ramp(t18 + 1, 1, 128)])) + int16x128(input[ramp(t19 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t9 = (output.s0.x.x*128) + t36
    let t20 = (input.stride.1*-1) + t9
    let t21 = input.stride.1 + t9
    output[ramp((output.s0.x.x*128) + t37, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t9 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t9, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t20, 1, 128)])) + int16x128(input[ramp(t21, 1, 128)])) + int16x128(input[ramp(t9 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t20 + -1, 1, 128)])) + int16x128(input[ramp(t21 + -1, 1, 128)]))) + int16x128(input[ramp(t20 + 1, 1, 128)])) + int16x128(input[ramp(t21 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t12 = (output.s0.x.x*128) + t38
    let t22 = (input.stride.1*-1) + t12
    let t23 = input.stride.1 + t12
    output[ramp((output.s0.x.x*128) + t39, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t12 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t12, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t22, 1, 128)])) + int16x128(input[ramp(t23, 1, 128)])) + int16x128(input[ramp(t12 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t22 + -1, 1, 128)])) + int16x128(input[ramp(t23 + -1, 1, 128)]))) + int16x128(input[ramp(t22 + 1, 1, 128)])) + int16x128(input[ramp(t23 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t15 = (output.s0.x.x*128) + t40
    let t24 = (input.stride.1*-1) + t15
    let t25 = input.stride.1 + t15
    output[ramp((output.s0.x.x*128) + t41, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t15 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t15, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t24, 1, 128)])) + int16x128(input[ramp(t25, 1, 128)])) + int16x128(input[ramp(t15 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t24 + -1, 1, 128)])) + int16x128(input[ramp(t25 + -1, 1, 128)]))) + int16x128(input[ramp(t24 + 1, 1, 128)])) + int16x128(input[ramp(t25 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}


Optimizing shuffles...
Lowering after optimizing shuffles:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 let t26 = (output.extent.1 + 3)/4
 let t29 = (output.extent.0 + 127)/128
 let t28 = ((output.extent.0 + -1)/128)*128
 let t27 = ((3 - input.min.1)*input.stride.1) - input.min.0
 let t30 = (input.min.1*input.stride.1) + input.min.0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, t26) {
   (uint8)prefetch(input, (((input.stride.1*output.s0.y.y)*4) + t27) + -1, t28 + 130, 1, 6, input.stride.1)
   let t42 = output.s0.y.y*4
   let t43 = t42 + 1
   let t44 = t42 + 2
   let t45 = t42 + 3
   let t41 = output.stride.1*t45
   let t39 = output.stride.1*t44
   let t37 = output.stride.1*t43
   let t35 = output.s0.y.y*output.stride.1
   let t33 = input.stride.1*output.s0.y.y
   let t40 = (input.stride.1*t45) - t30
   let t38 = (input.stride.1*t44) - t30
   let t36 = (input.stride.1*t43) - t30
   for (output.s0.x.x, 0, t29) {
    let t6 = (((output.s0.x.x*32) + t33)*4) - t30
    let t18 = (input.stride.1*-1) + t6
    let t19 = input.stride.1 + t6
    output[ramp(((output.s0.x.x*32) + t35)*4, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t6 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t6, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t18, 1, 128)])) + int16x128(input[ramp(t19, 1, 128)])) + int16x128(input[ramp(t6 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t18 + -1, 1, 128)])) + int16x128(input[ramp(t19 + -1, 1, 128)]))) + int16x128(input[ramp(t18 + 1, 1, 128)])) + int16x128(input[ramp(t19 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t9 = (output.s0.x.x*128) + t36
    let t20 = (input.stride.1*-1) + t9
    let t21 = input.stride.1 + t9
    output[ramp((output.s0.x.x*128) + t37, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t9 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t9, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t20, 1, 128)])) + int16x128(input[ramp(t21, 1, 128)])) + int16x128(input[ramp(t9 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t20 + -1, 1, 128)])) + int16x128(input[ramp(t21 + -1, 1, 128)]))) + int16x128(input[ramp(t20 + 1, 1, 128)])) + int16x128(input[ramp(t21 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t12 = (output.s0.x.x*128) + t38
    let t22 = (input.stride.1*-1) + t12
    let t23 = input.stride.1 + t12
    output[ramp((output.s0.x.x*128) + t39, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t12 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t12, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t22, 1, 128)])) + int16x128(input[ramp(t23, 1, 128)])) + int16x128(input[ramp(t12 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t22 + -1, 1, 128)])) + int16x128(input[ramp(t23 + -1, 1, 128)]))) + int16x128(input[ramp(t22 + 1, 1, 128)])) + int16x128(input[ramp(t23 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t15 = (output.s0.x.x*128) + t40
    let t24 = (input.stride.1*-1) + t15
    let t25 = input.stride.1 + t15
    output[ramp((output.s0.x.x*128) + t41, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t15 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t15, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t24, 1, 128)])) + int16x128(input[ramp(t25, 1, 128)])) + int16x128(input[ramp(t15 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t24 + -1, 1, 128)])) + int16x128(input[ramp(t25 + -1, 1, 128)]))) + int16x128(input[ramp(t24 + 1, 1, 128)])) + int16x128(input[ramp(t25 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}


Aligning loads for HVX....
Lowering after aligning loads:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 let t26 = (output.extent.1 + 3)/4
 let t29 = (output.extent.0 + 127)/128
 let t28 = ((output.extent.0 + -1)/128)*128
 let t27 = ((3 - input.min.1)*input.stride.1) - input.min.0
 let t30 = (input.min.1*input.stride.1) + input.min.0
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, t26) {
   (uint8)prefetch(input, (((input.stride.1*output.s0.y.y)*4) + t27) + -1, t28 + 130, 1, 6, input.stride.1)
   let t42 = output.s0.y.y*4
   let t43 = t42 + 1
   let t44 = t42 + 2
   let t45 = t42 + 3
   let t41 = output.stride.1*t45
   let t39 = output.stride.1*t44
   let t37 = output.stride.1*t43
   let t35 = output.s0.y.y*output.stride.1
   let t33 = input.stride.1*output.s0.y.y
   let t40 = (input.stride.1*t45) - t30
   let t38 = (input.stride.1*t44) - t30
   let t36 = (input.stride.1*t43) - t30
   for (output.s0.x.x, 0, t29) {
    let t6 = (((output.s0.x.x*32) + t33)*4) - t30
    let t18 = (input.stride.1*-1) + t6
    let t19 = input.stride.1 + t6
    output[ramp(((output.s0.x.x*32) + t35)*4, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t6 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t6, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t18, 1, 128)])) + int16x128(input[ramp(t19, 1, 128)])) + int16x128(input[ramp(t6 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t18 + -1, 1, 128)])) + int16x128(input[ramp(t19 + -1, 1, 128)]))) + int16x128(input[ramp(t18 + 1, 1, 128)])) + int16x128(input[ramp(t19 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t9 = (output.s0.x.x*128) + t36
    let t20 = (input.stride.1*-1) + t9
    let t21 = input.stride.1 + t9
    output[ramp((output.s0.x.x*128) + t37, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t9 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t9, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t20, 1, 128)])) + int16x128(input[ramp(t21, 1, 128)])) + int16x128(input[ramp(t9 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t20 + -1, 1, 128)])) + int16x128(input[ramp(t21 + -1, 1, 128)]))) + int16x128(input[ramp(t20 + 1, 1, 128)])) + int16x128(input[ramp(t21 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t12 = (output.s0.x.x*128) + t38
    let t22 = (input.stride.1*-1) + t12
    let t23 = input.stride.1 + t12
    output[ramp((output.s0.x.x*128) + t39, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t12 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t12, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t22, 1, 128)])) + int16x128(input[ramp(t23, 1, 128)])) + int16x128(input[ramp(t12 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t22 + -1, 1, 128)])) + int16x128(input[ramp(t23 + -1, 1, 128)]))) + int16x128(input[ramp(t22 + 1, 1, 128)])) + int16x128(input[ramp(t23 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t15 = (output.s0.x.x*128) + t40
    let t24 = (input.stride.1*-1) + t15
    let t25 = input.stride.1 + t15
    output[ramp((output.s0.x.x*128) + t41, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t15 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t15, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t24, 1, 128)])) + int16x128(input[ramp(t25, 1, 128)])) + int16x128(input[ramp(t15 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t24 + -1, 1, 128)])) + int16x128(input[ramp(t25 + -1, 1, 128)]))) + int16x128(input[ramp(t24 + 1, 1, 128)])) + int16x128(input[ramp(t25 + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}


Carrying values across loop iterations...
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.0", input.min.0, "0", 0)
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.1", input.min.1, "0", 0)
Lowering after forwarding stores:
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, (((input.stride.1*output.s0.y.y)*4) + (((3 - input.min.1)*input.stride.1) - input.min.0)) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   let t40 = (((output.s0.y.y*4) + 3)*input.stride.1) - ((input.min.1*input.stride.1) + input.min.0)
   let t38 = (((output.s0.y.y*4) + 2)*input.stride.1) - ((input.min.1*input.stride.1) + input.min.0)
   let t36 = (((output.s0.y.y*4) + 1)*input.stride.1) - ((input.min.1*input.stride.1) + input.min.0)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let t6 = (((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)
    output[ramp(((output.s0.x.x*32) + (output.s0.y.y*output.stride.1))*4, 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(t6 + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp(t6, 1, 128)])*x128((int16)2)) + int16x128(input[ramp((input.stride.1*-1) + t6, 1, 128)])) + int16x128(input[ramp(input.stride.1 + t6, 1, 128)])) + int16x128(input[ramp(t6 + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(((input.stride.1*-1) + t6) + -1, 1, 128)])) + int16x128(input[ramp((input.stride.1 + t6) + -1, 1, 128)]))) + int16x128(input[ramp(((input.stride.1*-1) + t6) + 1, 1, 128)])) + int16x128(input[ramp((input.stride.1 + t6) + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t20 = (input.stride.1*-1) + ((output.s0.x.x*128) + t36)
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(((output.s0.x.x*128) + t36) + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp((output.s0.x.x*128) + t36, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t20, 1, 128)])) + int16x128(input[ramp(((output.s0.x.x*128) + t36) + input.stride.1, 1, 128)])) + int16x128(input[ramp(((output.s0.x.x*128) + t36) + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t20 + -1, 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + t36) + input.stride.1) + -1, 1, 128)]))) + int16x128(input[ramp(t20 + 1, 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + t36) + input.stride.1) + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t22 = (input.stride.1*-1) + ((output.s0.x.x*128) + t38)
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(((output.s0.x.x*128) + t38) + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp((output.s0.x.x*128) + t38, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t22, 1, 128)])) + int16x128(input[ramp(((output.s0.x.x*128) + t38) + input.stride.1, 1, 128)])) + int16x128(input[ramp(((output.s0.x.x*128) + t38) + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t22 + -1, 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + t38) + input.stride.1) + -1, 1, 128)]))) + int16x128(input[ramp(t22 + 1, 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + t38) + input.stride.1) + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
    let t24 = (input.stride.1*-1) + ((output.s0.x.x*128) + t40)
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*output.stride.1), 1, 128) aligned(128, 0)] = uint8x128(((((((int16x128(input[ramp(((output.s0.x.x*128) + t40) + 1, 1, 128)])*x128((int16)2)) + (((((((int16x128(input[ramp((output.s0.x.x*128) + t40, 1, 128)])*x128((int16)2)) + int16x128(input[ramp(t24, 1, 128)])) + int16x128(input[ramp(((output.s0.x.x*128) + t40) + input.stride.1, 1, 128)])) + int16x128(input[ramp(((output.s0.x.x*128) + t40) + -1, 1, 128)]))*x128((int16)2)) + int16x128(input[ramp(t24 + -1, 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + t40) + input.stride.1) + -1, 1, 128)]))) + int16x128(input[ramp(t24 + 1, 1, 128)])) + int16x128(input[ramp((((output.s0.x.x*128) + t40) + input.stride.1) + 1, 1, 128)])) + x128((int16)8))/x128((int16)16)))
   }
  }
 }
}


Optimizing Hexagon instructions...
Adding calls to qurt_hvx_lock, if necessary...
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.0", input.min.0, "0", 0)
User error triggered at /home/maaz/Software/Halide-10.0.0/src/Simplify_Stmts.cpp:135
Warning: This pipeline is guaranteed to fail an assertion at runtime: 
halide_error_constraint_violated("input.min.1", input.min.1, "0", 0)
Simplifier: unhandled PureExtern: halide.hexagon.trunc.vhSimplifier: unhandled PureExtern: halide.hexagon.acc_add_2mpy.vh.vub.vub.b.bSimplifier: unhandled PureExtern: halide.hexagon.acc_add_2mpy.vh.vub.vub.b.bSimplifier: unhandled PureExtern: halide.hexagon.add_2mpy.vub.vub.b.bSimplifier: unhandled PureExtern: halide.hexagon.zxt.vubSimplifier: unhandled PureExtern: halide.hexagon.zxt.vubSimplifier: unhandled PureExtern: halide.hexagon.zxt.vubSimplifier: unhandled PureExtern: halide.hexagon.trunc.vhSimplifier: unhandled PureExtern: halide.hexagon.acc_add_2mpy.vh.vub.vub.b.bSimplifier: unhandled PureExtern: halide.hexagon.acc_add_2mpy.vh.vub.vub.b.bSimplifier: unhandled PureExtern: halide.hexagon.add_2mpy.vub.vub.b.bSimplifier: unhandled PureExtern: halide.hexagon.zxt.vubSimplifier: unhandled PureExtern: halide.hexagon.zxt.vubSimplifier: unhandled PureExtern: halide.hexagon.zxt.vubSimplifier: unhandled PureExtern: halide.hexagon.trunc.vhSimplifier: unhandled PureExtern: halide.hexagon.acc_add_2mpy.vh.vub.vub.b.bSimplifier: unhandled PureExtern: halide.hexagon.acc_add_2mpy.vh.vub.vub.b.bSimplifier: unhandled PureExtern: halide.hexagon.add_2mpy.vub.vub.b.bSimplifier: unhandled PureExtern: halide.hexagon.zxt.vubSimplifier: unhandled PureExtern: halide.hexagon.zxt.vubSimplifier: unhandled PureExtern: halide.hexagon.zxt.vubSimplifier: unhandled PureExtern: halide.hexagon.trunc.vhSimplifier: unhandled PureExtern: halide.hexagon.acc_add_2mpy.vh.vub.vub.b.bSimplifier: unhandled PureExtern: halide.hexagon.acc_add_2mpy.vh.vub.vub.b.bSimplifier: unhandled PureExtern: halide.hexagon.add_2mpy.vub.vub.b.bSimplifier: unhandled PureExtern: halide.hexagon.zxt.vubSimplifier: unhandled PureExtern: halide.hexagon.zxt.vubSimplifier: unhandled PureExtern: halide.hexagon.zxt.vubHexagon function body:
let hvx_lock_result = halide_qurt_hvx_lock(128)
assert(hvx_lock_result == 0, hvx_lock_result)
(void *)register_destructor("halide_qurt_hvx_unlock_as_destructor", (void *)reinterpret((uint64)1))
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.type = (uint32)_halide_buffer_get_type((halide_buffer_t *)output.buffer)
let output.dimensions = _halide_buffer_get_dimensions((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, 0, (((output.extent.0 + -1)/128)*128) + 129, -1, (((output.extent.0 + -1)/128)*128) + 128))
assert(!(uint1)_halide_buffer_is_bounds_query((halide_buffer_t *)input.buffer), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, 0, (((output.extent.1 + -1)/4)*4) + 5, -1, (((output.extent.1 + -1)/4)*4) + 4))
assert(input.type == (uint32)67585, halide_error_bad_type("Input buffer input", input.type, (uint32)67585))
assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
assert(output.type == (uint32)67585, halide_error_bad_type("Output buffer output", output.type, (uint32)67585))
assert(output.dimensions == 2, halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
assert((input.min.0 <= -1) && (((((output.extent.0 + -1)/128)*128) + 129) <= (input.extent.0 + input.min.0)), halide_error_access_out_of_bounds("Input buffer input", 0, -1, (((output.extent.0 + -1)/128)*128) + 128, input.min.0, (input.extent.0 + input.min.0) + -1))
assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
assert((input.min.1 <= -1) && (((((output.extent.1 + -1)/4)*4) + 5) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, -1, (((output.extent.1 + -1)/4)*4) + 4, input.min.1, (input.extent.1 + input.min.1) + -1))
assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
assert((output.min.0 <= 0) && (127 <= (((output.extent.0 + 127) % 128) + output.min.0)), halide_error_access_out_of_bounds("Output buffer output", 0, 0, (((output.extent.0 + -1)/128)*128) + 127, output.min.0, (output.extent.0 + output.min.0) + -1))
assert(0 <= output.extent.0, halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
assert((output.min.1 <= 0) && (3 <= (((output.extent.1 + 3) % 4) + output.min.1)), halide_error_access_out_of_bounds("Output buffer output", 1, 0, (((output.extent.1 + -1)/4)*4) + 3, output.min.1, (output.extent.1 + output.min.1) + -1))
assert(0 <= output.extent.1, halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
assert((uint1)0, halide_error_constraint_violated("input.min.0", input.min.0, "0", 0))
assert((input.stride.1 % 128) == 0, halide_error_constraint_violated("input.stride.1", input.stride.1, "((input.stride.1/128)*128)", (input.stride.1/128)*128))
assert((uint1)0, halide_error_constraint_violated("input.min.1", input.min.1, "0", 0))
assert(output.stride.0 == 1, halide_error_constraint_violated("output.stride.0", output.stride.0, "1", 1))
assert(output.min.0 == 0, halide_error_constraint_violated("output.min.0", output.min.0, "0", 0))
assert((output.stride.1 % 128) == 0, halide_error_constraint_violated("output.stride.1", output.stride.1, "((output.stride.1/128)*128)", (output.stride.1/128)*128))
assert(output.min.1 == 0, halide_error_constraint_violated("output.min.1", output.min.1, "0", 0))
let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
let output.total_extent.1 = int64(output.extent.1)*int64(output.extent.0)
assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(((input.stride.1/128)*128))), (uint64)2147483647))
assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
assert((uint64)abs(int64(output.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.0)), (uint64)2147483647))
assert((uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("output", (uint64)abs(int64(output.extent.1)*int64(((output.stride.1/128)*128))), (uint64)2147483647))
assert(output.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
produce output {
 for<Hexagon> (output.s0.__outermost, 0, 1) {
  for (output.s0.y.y, 0, (output.extent.1 + 3)/4) {
   (uint8)prefetch(input, (((input.stride.1*output.s0.y.y)*4) + (((3 - input.min.1)*input.stride.1) - input.min.0)) + -1, (((output.extent.0 + -1)/128)*128) + 130, 1, 6, input.stride.1)
   let t40 = (((output.s0.y.y*4) + 3)*input.stride.1) - ((input.min.1*input.stride.1) + input.min.0)
   let t38 = (((output.s0.y.y*4) + 2)*input.stride.1) - ((input.min.1*input.stride.1) + input.min.0)
   let t36 = (((output.s0.y.y*4) + 1)*input.stride.1) - ((input.min.1*input.stride.1) + input.min.0)
   for (output.s0.x.x, 0, (output.extent.0 + 127)/128) {
    let t6 = (((output.s0.x.x*32) + (input.stride.1*output.s0.y.y))*4) - ((input.min.1*input.stride.1) + input.min.0)
    output[ramp(((output.s0.x.x*32) + (output.s0.y.y*output.stride.1))*4, 1, 128) aligned(128, 0)] = (uint8x128)halide.hexagon.trunc.vh((int16x128)halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(((int16x128)halide.hexagon.zxt.vub(input[ramp((input.stride.1 + t6) + 1, 1, 128)]) + ((int16x128)halide.hexagon.zxt.vub(input[ramp(((input.stride.1*-1) + t6) + 1, 1, 128)]) + ((int16x128)halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b((int16x128)halide.hexagon.add_2mpy.vub.vub.b.b(input[ramp((input.stride.1*-1) + t6, 1, 128)], input[ramp(input.stride.1 + t6, 1, 128)], (int8)2, (int8)2), input[ramp(t6, 1, 128)], input[ramp(t6 + 1, 1, 128)], (int8)4, (int8)2) + (int16x128)halide.hexagon.zxt.vub(input[ramp((input.stride.1 + t6) + -1, 1, 128)])))) + x128((int16)8), input[ramp(t6 + -1, 1, 128)], input[ramp(((input.stride.1*-1) + t6) + -1, 1, 128)], (int8)2, (int8)1)/x128((int16)16))
    let t20 = (input.stride.1*-1) + ((output.s0.x.x*128) + t36)
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 1)*output.stride.1), 1, 128) aligned(128, 0)] = (uint8x128)halide.hexagon.trunc.vh((int16x128)halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(((int16x128)halide.hexagon.zxt.vub(input[ramp((((output.s0.x.x*128) + t36) + input.stride.1) + 1, 1, 128)]) + ((int16x128)halide.hexagon.zxt.vub(input[ramp(t20 + 1, 1, 128)]) + ((int16x128)halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b((int16x128)halide.hexagon.add_2mpy.vub.vub.b.b(input[ramp(t20, 1, 128)], input[ramp(((output.s0.x.x*128) + t36) + input.stride.1, 1, 128)], (int8)2, (int8)2), input[ramp((output.s0.x.x*128) + t36, 1, 128)], input[ramp(((output.s0.x.x*128) + t36) + 1, 1, 128)], (int8)4, (int8)2) + (int16x128)halide.hexagon.zxt.vub(input[ramp((((output.s0.x.x*128) + t36) + input.stride.1) + -1, 1, 128)])))) + x128((int16)8), input[ramp(((output.s0.x.x*128) + t36) + -1, 1, 128)], input[ramp(t20 + -1, 1, 128)], (int8)2, (int8)1)/x128((int16)16))
    let t22 = (input.stride.1*-1) + ((output.s0.x.x*128) + t38)
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 2)*output.stride.1), 1, 128) aligned(128, 0)] = (uint8x128)halide.hexagon.trunc.vh((int16x128)halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(((int16x128)halide.hexagon.zxt.vub(input[ramp((((output.s0.x.x*128) + t38) + input.stride.1) + 1, 1, 128)]) + ((int16x128)halide.hexagon.zxt.vub(input[ramp(t22 + 1, 1, 128)]) + ((int16x128)halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b((int16x128)halide.hexagon.add_2mpy.vub.vub.b.b(input[ramp(t22, 1, 128)], input[ramp(((output.s0.x.x*128) + t38) + input.stride.1, 1, 128)], (int8)2, (int8)2), input[ramp((output.s0.x.x*128) + t38, 1, 128)], input[ramp(((output.s0.x.x*128) + t38) + 1, 1, 128)], (int8)4, (int8)2) + (int16x128)halide.hexagon.zxt.vub(input[ramp((((output.s0.x.x*128) + t38) + input.stride.1) + -1, 1, 128)])))) + x128((int16)8), input[ramp(((output.s0.x.x*128) + t38) + -1, 1, 128)], input[ramp(t22 + -1, 1, 128)], (int8)2, (int8)1)/x128((int16)16))
    let t24 = (input.stride.1*-1) + ((output.s0.x.x*128) + t40)
    output[ramp((output.s0.x.x*128) + (((output.s0.y.y*4) + 3)*output.stride.1), 1, 128) aligned(128, 0)] = (uint8x128)halide.hexagon.trunc.vh((int16x128)halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b(((int16x128)halide.hexagon.zxt.vub(input[ramp((((output.s0.x.x*128) + t40) + input.stride.1) + 1, 1, 128)]) + ((int16x128)halide.hexagon.zxt.vub(input[ramp(t24 + 1, 1, 128)]) + ((int16x128)halide.hexagon.acc_add_2mpy.vh.vub.vub.b.b((int16x128)halide.hexagon.add_2mpy.vub.vub.b.b(input[ramp(t24, 1, 128)], input[ramp(((output.s0.x.x*128) + t40) + input.stride.1, 1, 128)], (int8)2, (int8)2), input[ramp((output.s0.x.x*128) + t40, 1, 128)], input[ramp(((output.s0.x.x*128) + t40) + 1, 1, 128)], (int8)4, (int8)2) + (int16x128)halide.hexagon.zxt.vub(input[ramp((((output.s0.x.x*128) + t40) + input.stride.1) + -1, 1, 128)])))) + x128((int16)8), input[ramp(((output.s0.x.x*128) + t40) + -1, 1, 128)], input[ramp(t24 + -1, 1, 128)], (int8)2, (int8)1)/x128((int16)16))
   }
  }
 }
}

0x5588c1889820
Done generating llvm bitcode
; ModuleID = 'gaussian3x3_hvx128'
source_filename = "/home/maaz/Software/Halide-10.0.0/src/runtime/posix_abort.cpp"
target datalayout = "e-m:e-p:32:32:32-a:0-n16:32-i64:64:64-i32:32:32-i16:16:16-i1:8:8-f32:32:32-f64:64:64-v32:32:32-v64:64:64-v512:512:512-v1024:1024:1024-v2048:2048:2048"
target triple = "hexagon-unknown--elf"

%struct.halide_parallel_task_t = type { i32 (i8*, i32, i32, i8*, i8*)*, i8*, i8*, %struct.halide_semaphore_acquire_t*, i32, i32, i32, i32, i8 }
%struct.halide_semaphore_acquire_t = type { %struct.halide_semaphore_t*, i32 }
%struct.halide_semaphore_t = type { [2 x i64] }
%struct.halide_mutex = type { [1 x i32] }
%struct.halide_device_allocation_pool = type { i32 (i8*)*, %struct.halide_device_allocation_pool* }
%struct.halide_filter_argument_t = type { i8*, i32, i32, %struct.halide_type_t, %struct.halide_scalar_value_t*, %struct.halide_scalar_value_t*, %struct.halide_scalar_value_t*, %struct.halide_scalar_value_t*, i64** }
%struct.halide_type_t = type { i8, i8, i16 }
%struct.halide_scalar_value_t = type { %union.anon }
%union.anon = type { i64 }
%struct.halide_filter_metadata_t = type { i32, i32, %struct.halide_filter_argument_t*, i8*, i8* }
%struct.halide_thread = type opaque
%struct.halide_mutex_array = type { %struct.halide_mutex* }
%struct.halide_buffer_t = type { i64, %struct.halide_device_interface_t*, i8*, i64, %struct.halide_type_t, i32, %struct.halide_dimension_t*, i8* }
%struct.halide_device_interface_t = type { i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, void (i8*, %struct.halide_device_interface_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, i32, i32, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, i64, %struct.halide_device_interface_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, i32*, i32*)*, %struct.halide_device_interface_impl_t* }
%struct.halide_device_interface_impl_t = type { void ()*, void ()*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, i32, i32, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, i64)*, i32 (i8*, %struct.halide_buffer_t*)* }
%struct.halide_dimension_t = type { i32, i32, i32, i32 }
%"struct.Halide::Runtime::Internal::device_copy" = type { i64, i64, i64, [16 x i64], [16 x i64], [16 x i64], i64 }
%"struct.Halide::Runtime::Internal::CpuFeatures" = type { [2 x i64], [2 x i64] }

@_ZN6Halide7Runtime8Internal11buf_is_usedE = linkonce global [10 x i32] zeroinitializer, align 4
@_ZN6Halide7Runtime8Internal7mem_bufE = linkonce local_unnamed_addr global [10 x i8*] zeroinitializer, align 4
@_ZN6Halide7Runtime8Internal13custom_mallocE = linkonce local_unnamed_addr global i8* (i8*, i32)* @halide_default_malloc, align 4
@_ZN6Halide7Runtime8Internal11custom_freeE = linkonce local_unnamed_addr global void (i8*, i8*)* @halide_default_free, align 4
@llvm.global_dtors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 65535, void ()* @_ZN6Halide7Runtime8Internal24halide_allocator_cleanupEv, i8* null }]
@.str = private unnamed_addr constant [45 x i8] c"custom allocators not supported on Hexagon.\0A\00", align 1
@_ZN6Halide7Runtime8Internal14custom_do_taskE = linkonce local_unnamed_addr global i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)* @halide_default_do_task, align 4
@_ZN6Halide7Runtime8Internal19custom_do_loop_taskE = linkonce local_unnamed_addr global i32 (i8*, i32 (i8*, i32, i32, i8*, i8*)*, i32, i32, i8*, i8*)* @halide_default_do_loop_task, align 4
@_ZN6Halide7Runtime8Internal17custom_do_par_forE = linkonce local_unnamed_addr global i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)* @halide_default_do_par_for, align 4
@_ZN6Halide7Runtime8Internal24custom_do_parallel_tasksE = linkonce local_unnamed_addr global i32 (i8*, i32, %struct.halide_parallel_task_t*, i8*)* @halide_default_do_parallel_tasks, align 4
@.str.1 = private unnamed_addr constant [67 x i8] c"halide_default_do_parallel_tasks not implemented on this platform.\00", align 1
@_ZN6Halide7Runtime8Internal21custom_semaphore_initE = linkonce local_unnamed_addr global i32 (%struct.halide_semaphore_t*, i32)* @halide_default_semaphore_init, align 4
@.str.1.2 = private unnamed_addr constant [64 x i8] c"halide_default_semaphore_init not implemented on this platform.\00", align 1
@_ZN6Halide7Runtime8Internal28custom_semaphore_try_acquireE = linkonce local_unnamed_addr global i1 (%struct.halide_semaphore_t*, i32)* @halide_default_semaphore_try_acquire, align 4
@.str.3 = private unnamed_addr constant [71 x i8] c"halide_default_semaphore_try_acquire not implemented on this platform.\00", align 1
@_ZN6Halide7Runtime8Internal24custom_semaphore_releaseE = linkonce local_unnamed_addr global i32 (%struct.halide_semaphore_t*, i32)* @halide_default_semaphore_release, align 4
@.str.2 = private unnamed_addr constant [67 x i8] c"halide_default_semaphore_release not implemented on this platform.\00", align 1
@.str.4 = private unnamed_addr constant [54 x i8] c"halide_spawn_thread not implemented on this platform.\00", align 1
@.str.5 = private unnamed_addr constant [53 x i8] c"halide_join_thread not implemented on this platform.\00", align 1
@.str.6 = private unnamed_addr constant [69 x i8] c"halide_set_num_threads: only supports a value of 1 on this platform.\00", align 1
@_ZN6Halide7Runtime8Internal17halide_gpu_deviceE = linkonce local_unnamed_addr global i32 0, align 4
@_ZN6Halide7Runtime8Internal22halide_gpu_device_lockE = linkonce global i8 0, align 1
@_ZN6Halide7Runtime8Internal29halide_gpu_device_initializedE = linkonce local_unnamed_addr global i8 0, align 1
@.str.7 = private unnamed_addr constant [14 x i8] c"HL_GPU_DEVICE\00", align 1
@.str.8 = private unnamed_addr constant [5 x i8] c"-nan\00", align 1
@.str.1.9 = private unnamed_addr constant [4 x i8] c"nan\00", align 1
@.str.2.10 = private unnamed_addr constant [5 x i8] c"-inf\00", align 1
@.str.3.11 = private unnamed_addr constant [4 x i8] c"inf\00", align 1
@.str.4.12 = private unnamed_addr constant [14 x i8] c"-0.000000e+00\00", align 1
@.str.5.13 = private unnamed_addr constant [13 x i8] c"0.000000e+00\00", align 1
@.str.6.14 = private unnamed_addr constant [10 x i8] c"-0.000000\00", align 1
@.str.7.15 = private unnamed_addr constant [9 x i8] c"0.000000\00", align 1
@.str.8.16 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.10 = private unnamed_addr constant [3 x i8] c"e+\00", align 1
@.str.11 = private unnamed_addr constant [3 x i8] c"e-\00", align 1
@.str.12 = private unnamed_addr constant [17 x i8] c"0123456789abcdef\00", align 1
@.str.17 = private unnamed_addr constant [14 x i8] c"bad_type_code\00", align 1
@.str.16 = private unnamed_addr constant [7 x i8] c"handle\00", align 1
@.str.15 = private unnamed_addr constant [6 x i8] c"float\00", align 1
@.str.14 = private unnamed_addr constant [5 x i8] c"uint\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"int\00", align 1
@.str.18 = private unnamed_addr constant [2 x i8] c"x\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"NULL\00", align 1
@.str.20 = private unnamed_addr constant [8 x i8] c"buffer(\00", align 1
@.str.22 = private unnamed_addr constant [4 x i8] c", {\00", align 1
@.str.23 = private unnamed_addr constant [2 x i8] c"}\00", align 1
@_ZN6Halide7Runtime8Internal36halide_reuse_device_allocations_flagE = linkonce local_unnamed_addr global i8 1, align 1
@_ZN6Halide7Runtime8Internal21allocation_pools_lockE = linkonce global %struct.halide_mutex zeroinitializer, align 4
@_ZN6Halide7Runtime8Internal23device_allocation_poolsE = linkonce local_unnamed_addr global %struct.halide_device_allocation_pool* null, align 4
@_ZN6Halide7Runtime8Internal17device_copy_mutexE = linkonce global %struct.halide_mutex zeroinitializer, align 4
@.str.6.17 = private unnamed_addr constant [20 x i8] c"halide_copy_to_host\00", align 1
@.str.7.18 = private unnamed_addr constant [22 x i8] c"halide_copy_to_device\00", align 1
@.str.9.19 = private unnamed_addr constant [61 x i8] c"halide_copy_to_device does not support switching interfaces\0A\00", align 1
@.str.17.20 = private unnamed_addr constant [21 x i8] c"halide_device_malloc\00", align 1
@.str.20.21 = private unnamed_addr constant [59 x i8] c"halide_device_malloc doesn't support switching interfaces\0A\00", align 1
@.str.16.22 = private unnamed_addr constant [19 x i8] c"halide_device_sync\00", align 1
@.str.21.23 = private unnamed_addr constant [19 x i8] c"halide_device_free\00", align 1
@.str.22.24 = private unnamed_addr constant [104 x i8] c"/home/maaz/Software/Halide-10.0.0/src/runtime/device_interface.cpp:252 Assert failed: buf->device == 0\0A\00", align 1
@.str.23.25 = private unnamed_addr constant [30 x i8] c"halide_device_and_host_malloc\00", align 1
@.str.25 = private unnamed_addr constant [68 x i8] c"halide_device_and_host_malloc doesn't support switching interfaces\0A\00", align 1
@.str.26 = private unnamed_addr constant [42 x i8] c"allocating host and device memory failed\0A\00", align 1
@.str.27 = private unnamed_addr constant [28 x i8] c"halide_device_and_host_free\00", align 1
@.str.28 = private unnamed_addr constant [104 x i8] c"/home/maaz/Software/Halide-10.0.0/src/runtime/device_interface.cpp:317 Assert failed: buf->device == 0\0A\00", align 1
@.str.29 = private unnamed_addr constant [38 x i8] c"halide_default_device_and_host_malloc\00", align 1
@.str.30 = private unnamed_addr constant [36 x i8] c"halide_default_device_and_host_free\00", align 1
@.str.31 = private unnamed_addr constant [26 x i8] c"halide_device_wrap_native\00", align 1
@.str.32 = private unnamed_addr constant [64 x i8] c"halide_device_wrap_native doesn't support switching interfaces\0A\00", align 1
@.str.33 = private unnamed_addr constant [28 x i8] c"halide_device_detach_native\00", align 1
@.str.34 = private unnamed_addr constant [104 x i8] c"/home/maaz/Software/Halide-10.0.0/src/runtime/device_interface.cpp:403 Assert failed: buf->device == 0\0A\00", align 1
@.str.35 = private unnamed_addr constant [34 x i8] c"halide_default_device_wrap_native\00", align 1
@.str.36 = private unnamed_addr constant [36 x i8] c"halide_default_device_detach_native\00", align 1
@.str.42 = private unnamed_addr constant [64 x i8] c"halide_buffer_copy does not support switching device interfaces\00", align 1
@.str.58 = private unnamed_addr constant [44 x i8] c"device_interface does not support cropping\0A\00", align 1
@.str.59 = private unnamed_addr constant [43 x i8] c"device_interface does not support slicing\0A\00", align 1
@.str.60 = private unnamed_addr constant [52 x i8] c"destination buffer already has a device allocation\0A\00", align 1
@.str.61 = private unnamed_addr constant [48 x i8] c"src and dst must have identical dimensionality\0A\00", align 1
@.str.64 = private unnamed_addr constant [52 x i8] c"dst must have exactly one fewer dimension than src\0A\00", align 1
@.str.37 = private unnamed_addr constant [41 x i8] c"Bounds inference call to external stage \00", align 1
@.str.74 = private unnamed_addr constant [7 x i8] c"<NULL>\00", align 1
@.str.1.38 = private unnamed_addr constant [27 x i8] c" returned non-zero value: \00", align 1
@.str.2.39 = private unnamed_addr constant [24 x i8] c"Call to external stage \00", align 1
@.str.3.40 = private unnamed_addr constant [18 x i8] c"Bounds given for \00", align 1
@.str.4.41 = private unnamed_addr constant [5 x i8] c" in \00", align 1
@.str.5.42 = private unnamed_addr constant [8 x i8] c" (from \00", align 1
@.str.6.43 = private unnamed_addr constant [5 x i8] c" to \00", align 1
@.str.7.44 = private unnamed_addr constant [38 x i8] c") do not cover required region (from \00", align 1
@.str.8.45 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.9.46 = private unnamed_addr constant [11 x i8] c" has type \00", align 1
@.str.10.47 = private unnamed_addr constant [38 x i8] c" but type of the buffer passed in is \00", align 1
@.str.11.48 = private unnamed_addr constant [31 x i8] c" requires a buffer of exactly \00", align 1
@.str.12.49 = private unnamed_addr constant [43 x i8] c" dimensions, but the buffer passed in has \00", align 1
@.str.13.50 = private unnamed_addr constant [12 x i8] c" dimensions\00", align 1
@.str.14.51 = private unnamed_addr constant [17 x i8] c" is accessed at \00", align 1
@.str.15.52 = private unnamed_addr constant [28 x i8] c", which is before the min (\00", align 1
@.str.16.53 = private unnamed_addr constant [16 x i8] c") in dimension \00", align 1
@.str.17.54 = private unnamed_addr constant [28 x i8] c", which is beyond the max (\00", align 1
@.str.18.55 = private unnamed_addr constant [29 x i8] c"Total allocation for buffer \00", align 1
@.str.19.56 = private unnamed_addr constant [5 x i8] c" is \00", align 1
@.str.20.57 = private unnamed_addr constant [37 x i8] c", which exceeds the maximum size of \00", align 1
@.str.21.58 = private unnamed_addr constant [24 x i8] c"The extents for buffer \00", align 1
@.str.22.59 = private unnamed_addr constant [12 x i8] c" dimension \00", align 1
@.str.23.60 = private unnamed_addr constant [15 x i8] c" is negative (\00", align 1
@.str.24.61 = private unnamed_addr constant [31 x i8] c"Product of extents for buffer \00", align 1
@.str.25.62 = private unnamed_addr constant [29 x i8] c"Applying the constraints on \00", align 1
@.str.26.63 = private unnamed_addr constant [54 x i8] c" to the required region made it smaller in dimension \00", align 1
@.str.27.64 = private unnamed_addr constant [3 x i8] c". \00", align 1
@.str.28.65 = private unnamed_addr constant [16 x i8] c"Required size: \00", align 1
@.str.29.66 = private unnamed_addr constant [19 x i8] c"Constrained size: \00", align 1
@.str.30.67 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str.31.68 = private unnamed_addr constant [22 x i8] c"Constraint violated: \00", align 1
@.str.32.69 = private unnamed_addr constant [3 x i8] c" (\00", align 1
@.str.33.70 = private unnamed_addr constant [6 x i8] c") == \00", align 1
@.str.34.71 = private unnamed_addr constant [11 x i8] c"Parameter \00", align 1
@.str.35.72 = private unnamed_addr constant [23 x i8] c" but must be at least \00", align 1
@.str.36.73 = private unnamed_addr constant [22 x i8] c" but must be at most \00", align 1
@.str.37.74 = private unnamed_addr constant [44 x i8] c"Out of memory (halide_malloc returned NULL)\00", align 1
@.str.38 = private unnamed_addr constant [17 x i8] c"Buffer argument \00", align 1
@.str.39 = private unnamed_addr constant [9 x i8] c" is NULL\00", align 1
@.str.40 = private unnamed_addr constant [25 x i8] c"Failed to dump function \00", align 1
@.str.41 = private unnamed_addr constant [10 x i8] c" to file \00", align 1
@.str.42.75 = private unnamed_addr constant [13 x i8] c" with error \00", align 1
@.str.43 = private unnamed_addr constant [21 x i8] c"The host pointer of \00", align 1
@.str.44 = private unnamed_addr constant [22 x i8] c" is not aligned to a \00", align 1
@.str.45 = private unnamed_addr constant [17 x i8] c" bytes boundary.\00", align 1
@.str.46 = private unnamed_addr constant [12 x i8] c"The buffer \00", align 1
@.str.47 = private unnamed_addr constant [53 x i8] c" is dirty on device, but this pipeline was compiled \00", align 1
@.str.48 = private unnamed_addr constant [43 x i8] c"with no support for device to host copies.\00", align 1
@.str.49 = private unnamed_addr constant [55 x i8] c" is null, but the pipeline will access it on the host.\00", align 1
@.str.50 = private unnamed_addr constant [30 x i8] c"The folded storage dimension \00", align 1
@.str.51 = private unnamed_addr constant [5 x i8] c" of \00", align 1
@.str.52 = private unnamed_addr constant [36 x i8] c" was accessed out of order by loop \00", align 1
@.str.53 = private unnamed_addr constant [23 x i8] c"Cannot fold dimension \00", align 1
@.str.54 = private unnamed_addr constant [36 x i8] c" because an extern stage accesses [\00", align 1
@.str.55 = private unnamed_addr constant [3 x i8] c", \00", align 1
@.str.56 = private unnamed_addr constant [3 x i8] c"],\00", align 1
@.str.57 = private unnamed_addr constant [47 x i8] c" which is outside the range currently valid: [\00", align 1
@.str.58.76 = private unnamed_addr constant [3 x i8] c"].\00", align 1
@.str.59.77 = private unnamed_addr constant [47 x i8] c" which wraps around the boundary of the fold, \00", align 1
@.str.60.78 = private unnamed_addr constant [30 x i8] c"which occurs at multiples of \00", align 1
@.str.61.79 = private unnamed_addr constant [18 x i8] c"The fold factor (\00", align 1
@.str.62 = private unnamed_addr constant [16 x i8] c") of dimension \00", align 1
@.str.63 = private unnamed_addr constant [61 x i8] c" is too small to store the required region accessed by loop \00", align 1
@.str.64.80 = private unnamed_addr constant [3 x i8] c").\00", align 1
@.str.65 = private unnamed_addr constant [22 x i8] c"Requirement Failed: (\00", align 1
@.str.66 = private unnamed_addr constant [3 x i8] c") \00", align 1
@.str.67 = private unnamed_addr constant [59 x i8] c"A schedule specialized with specialize_fail() was chosen: \00", align 1
@.str.68 = private unnamed_addr constant [55 x i8] c"Buffer has a non-zero device but no device interface.\0A\00", align 1
@.str.69 = private unnamed_addr constant [57 x i8] c"Buffer has a non-null device_interface but device is 0.\0A\00", align 1
@.str.70 = private unnamed_addr constant [49 x i8] c"Buffer has both host and device dirty bits set.\0A\00", align 1
@.str.71 = private unnamed_addr constant [26 x i8] c"Buffer pointer passed to \00", align 1
@.str.72 = private unnamed_addr constant [11 x i8] c" is null.\0A\00", align 1
@.str.93 = private unnamed_addr constant [34 x i8] c"HVX lock size must be 64 or 128.\0A\00", align 1
@.str.8.94 = private unnamed_addr constant [35 x i8] c"Printer buffer allocation failed.\0A\00", align 1
@.str.5.95 = private unnamed_addr constant [22 x i8] c"qurt_hvx_lock failed\0A\00", align 1
@.str.7.96 = private unnamed_addr constant [24 x i8] c"qurt_hvx_unlock failed\0A\00", align 1
@_ZN6Halide7Runtime8Internal30custom_can_use_target_featuresE = linkonce local_unnamed_addr global i32 (i32, i64*)* @halide_default_can_use_target_features, align 4
@_ZN6Halide7Runtime8Internal36halide_cpu_features_initialized_lockE = linkonce global %struct.halide_mutex zeroinitializer, align 4
@_ZN6Halide7Runtime8Internal31halide_cpu_features_initializedE = linkonce local_unnamed_addr global i8 0, align 1
@_ZN6Halide7Runtime8Internal27halide_cpu_features_storageE = linkonce global [4 x i64] zeroinitializer, align 8
@.str.97 = private unnamed_addr constant [81 x i8] c"Internal error: wrong structure size passed to halide_can_use_target_features()\0A\00", align 1
@str = private constant [7 x i8] c"output\00", align 32
@str.101 = private constant [6 x i8] c"input\00", align 32
@str.102 = private constant [19 x i8] c"Input buffer input\00", align 32
@str.103 = private constant [21 x i8] c"Output buffer output\00", align 32
@str.104 = private constant [15 x i8] c"input.stride.0\00", align 32
@str.105 = private constant [2 x i8] c"1\00", align 32
@str.106 = private constant [12 x i8] c"input.min.0\00", align 32
@str.107 = private constant [2 x i8] c"0\00", align 32
@str.108 = private constant [15 x i8] c"input.stride.1\00", align 32
@str.109 = private constant [27 x i8] c"((input.stride.1/128)*128)\00", align 32
@str.110 = private constant [12 x i8] c"input.min.1\00", align 32
@0 = private constant i64 0
@1 = private constant i64 0
@2 = private constant [4 x i64*] [i64* @0, i64* null, i64* @1, i64* null]
@3 = private constant i64 0
@4 = private constant i64 0
@5 = private constant [4 x i64*] [i64* @3, i64* null, i64* @4, i64* null]
@6 = private constant [2 x %struct.halide_filter_argument_t] [%struct.halide_filter_argument_t { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str.101, i32 0, i32 0), i32 1, i32 2, %struct.halide_type_t { i8 1, i8 8, i16 1 }, %struct.halide_scalar_value_t* null, %struct.halide_scalar_value_t* null, %struct.halide_scalar_value_t* null, %struct.halide_scalar_value_t* null, i64** getelementptr inbounds ([4 x i64*], [4 x i64*]* @2, i32 0, i32 0) }, %struct.halide_filter_argument_t { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str, i32 0, i32 0), i32 2, i32 2, %struct.halide_type_t { i8 1, i8 8, i16 1 }, %struct.halide_scalar_value_t* null, %struct.halide_scalar_value_t* null, %struct.halide_scalar_value_t* null, %struct.halide_scalar_value_t* null, i64** getelementptr inbounds ([4 x i64*], [4 x i64*]* @5, i32 0, i32 0) }]
@str.116 = private constant [40 x i8] c"hexagon-32-noos-hvx_128-no_bounds_query\00", align 128
@str.117 = private constant [19 x i8] c"gaussian3x3_hvx128\00", align 32
@gaussian3x3_hvx128_metadata_storage = private constant %struct.halide_filter_metadata_t { i32 1, i32 2, %struct.halide_filter_argument_t* getelementptr inbounds ([2 x %struct.halide_filter_argument_t], [2 x %struct.halide_filter_argument_t]* @6, i32 0, i32 0), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @str.116, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str.117, i32 0, i32 0) }
@switch.table.halide_type_to_string = private unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.16, i32 0, i32 0)], align 4

; Function Attrs: alwaysinline nounwind
define weak void @halide_abort() local_unnamed_addr #0 {
  tail call void @abort() #8
  ret void
}

declare void @abort() local_unnamed_addr #1

; Function Attrs: nounwind
define weak i8* @halide_default_malloc(i8* %0, i32 %1) #2 {
  %3 = icmp ult i32 %1, 65537
  br i1 %3, label %4, label %15

4:                                                ; preds = %2
  %5 = cmpxchg i32* getelementptr inbounds ([10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 0), i32 0, i32 1 seq_cst seq_cst
  %6 = extractvalue { i32, i1 } %5, 1
  br i1 %6, label %._crit_edge, label %12

._crit_edge:                                      ; preds = %4
  %.0 = getelementptr inbounds [10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 0
  br label %7

7:                                                ; preds = %._crit_edge9, %._crit_edge8, %._crit_edge7, %._crit_edge6, %._crit_edge5, %._crit_edge4, %._crit_edge3, %._crit_edge2, %._crit_edge1, %._crit_edge
  %.phi = phi i8** [ %.0, %._crit_edge ], [ %.1, %._crit_edge1 ], [ %.2, %._crit_edge2 ], [ %.3, %._crit_edge3 ], [ %.4, %._crit_edge4 ], [ %.5, %._crit_edge5 ], [ %.6, %._crit_edge6 ], [ %.7, %._crit_edge7 ], [ %.8, %._crit_edge8 ], [ %.9, %._crit_edge9 ]
  %8 = load i8*, i8** %.phi, align 4, !tbaa !8
  %9 = icmp eq i8* %8, null
  br i1 %9, label %10, label %17

10:                                               ; preds = %7
  %11 = tail call i8* @_ZN6Halide7Runtime8Internal14aligned_mallocEjj(i32 128, i32 65536) #9
  store i8* %11, i8** %.phi, align 4, !tbaa !8
  br label %17

12:                                               ; preds = %4
  %13 = cmpxchg i32* getelementptr inbounds ([10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 1), i32 0, i32 1 seq_cst seq_cst
  %14 = extractvalue { i32, i1 } %13, 1
  br i1 %14, label %._crit_edge1, label %19

._crit_edge1:                                     ; preds = %12
  %.1 = getelementptr inbounds [10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 1
  br label %7

15:                                               ; preds = %40, %2
  %16 = tail call i8* @_ZN6Halide7Runtime8Internal14aligned_mallocEjj(i32 128, i32 %1) #9
  br label %17

17:                                               ; preds = %15, %10, %7
  %18 = phi i8* [ %16, %15 ], [ %8, %7 ], [ %11, %10 ]
  ret i8* %18

19:                                               ; preds = %12
  %20 = cmpxchg i32* getelementptr inbounds ([10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 2), i32 0, i32 1 seq_cst seq_cst
  %21 = extractvalue { i32, i1 } %20, 1
  br i1 %21, label %._crit_edge2, label %22

._crit_edge2:                                     ; preds = %19
  %.2 = getelementptr inbounds [10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 2
  br label %7

22:                                               ; preds = %19
  %23 = cmpxchg i32* getelementptr inbounds ([10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 3), i32 0, i32 1 seq_cst seq_cst
  %24 = extractvalue { i32, i1 } %23, 1
  br i1 %24, label %._crit_edge3, label %25

._crit_edge3:                                     ; preds = %22
  %.3 = getelementptr inbounds [10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 3
  br label %7

25:                                               ; preds = %22
  %26 = cmpxchg i32* getelementptr inbounds ([10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 4), i32 0, i32 1 seq_cst seq_cst
  %27 = extractvalue { i32, i1 } %26, 1
  br i1 %27, label %._crit_edge4, label %28

._crit_edge4:                                     ; preds = %25
  %.4 = getelementptr inbounds [10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 4
  br label %7

28:                                               ; preds = %25
  %29 = cmpxchg i32* getelementptr inbounds ([10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 5), i32 0, i32 1 seq_cst seq_cst
  %30 = extractvalue { i32, i1 } %29, 1
  br i1 %30, label %._crit_edge5, label %31

._crit_edge5:                                     ; preds = %28
  %.5 = getelementptr inbounds [10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 5
  br label %7

31:                                               ; preds = %28
  %32 = cmpxchg i32* getelementptr inbounds ([10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 6), i32 0, i32 1 seq_cst seq_cst
  %33 = extractvalue { i32, i1 } %32, 1
  br i1 %33, label %._crit_edge6, label %34

._crit_edge6:                                     ; preds = %31
  %.6 = getelementptr inbounds [10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 6
  br label %7

34:                                               ; preds = %31
  %35 = cmpxchg i32* getelementptr inbounds ([10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 7), i32 0, i32 1 seq_cst seq_cst
  %36 = extractvalue { i32, i1 } %35, 1
  br i1 %36, label %._crit_edge7, label %37

._crit_edge7:                                     ; preds = %34
  %.7 = getelementptr inbounds [10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 7
  br label %7

37:                                               ; preds = %34
  %38 = cmpxchg i32* getelementptr inbounds ([10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 8), i32 0, i32 1 seq_cst seq_cst
  %39 = extractvalue { i32, i1 } %38, 1
  br i1 %39, label %._crit_edge8, label %40

._crit_edge8:                                     ; preds = %37
  %.8 = getelementptr inbounds [10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 8
  br label %7

40:                                               ; preds = %37
  %41 = cmpxchg i32* getelementptr inbounds ([10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 9), i32 0, i32 1 seq_cst seq_cst
  %42 = extractvalue { i32, i1 } %41, 1
  br i1 %42, label %._crit_edge9, label %15

._crit_edge9:                                     ; preds = %40
  %.9 = getelementptr inbounds [10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 9
  br label %7
}

; Function Attrs: nounwind
define linkonce i8* @_ZN6Halide7Runtime8Internal14aligned_mallocEjj(i32 %0, i32 %1) local_unnamed_addr #2 {
  %3 = add i32 %0, -1
  %4 = add i32 %3, %1
  %5 = sub i32 0, %0
  %6 = and i32 %4, %5
  %7 = add i32 %6, %0
  %8 = tail call i8* @malloc(i32 %7) #8
  %9 = icmp eq i8* %8, null
  %10 = ptrtoint i8* %8 to i32
  %11 = add i32 %0, 3
  %12 = add i32 %11, %10
  %13 = and i32 %12, %5
  br i1 %9, label %18, label %14

14:                                               ; preds = %2
  %15 = inttoptr i32 %13 to i8**
  %16 = getelementptr inbounds i8*, i8** %15, i32 -1
  %17 = inttoptr i32 %13 to i8*
  store i8* %8, i8** %16, align 4, !tbaa !8
  br label %18

18:                                               ; preds = %14, %2
  %19 = phi i8* [ %17, %14 ], [ null, %2 ]
  ret i8* %19
}

declare i8* @malloc(i32 %0) local_unnamed_addr #1

; Function Attrs: nounwind
define weak void @halide_default_free(i8* %0, i8* %1) #2 {
  %3 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 0), align 4, !tbaa !8
  %4 = icmp eq i8* %3, %1
  br i1 %4, label %._crit_edge, label %6

._crit_edge:                                      ; preds = %2
  %.0 = getelementptr inbounds [10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 0
  br label %5

5:                                                ; preds = %._crit_edge9, %._crit_edge8, %._crit_edge7, %._crit_edge6, %._crit_edge5, %._crit_edge4, %._crit_edge3, %._crit_edge2, %._crit_edge1, %._crit_edge
  %.phi = phi i32* [ %.0, %._crit_edge ], [ %.1, %._crit_edge1 ], [ %.2, %._crit_edge2 ], [ %.3, %._crit_edge3 ], [ %.4, %._crit_edge4 ], [ %.5, %._crit_edge5 ], [ %.6, %._crit_edge6 ], [ %.7, %._crit_edge7 ], [ %.8, %._crit_edge8 ], [ %.9, %._crit_edge9 ]
  store i32 0, i32* %.phi, align 4, !tbaa !12
  br label %9

6:                                                ; preds = %2
  %7 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 1), align 4, !tbaa !8
  %8 = icmp eq i8* %7, %1
  br i1 %8, label %._crit_edge1, label %10

._crit_edge1:                                     ; preds = %6
  %.1 = getelementptr inbounds [10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 1
  br label %5

9:                                                ; preds = %34, %5
  ret void

10:                                               ; preds = %6
  %11 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 2), align 4, !tbaa !8
  %12 = icmp eq i8* %11, %1
  br i1 %12, label %._crit_edge2, label %13

._crit_edge2:                                     ; preds = %10
  %.2 = getelementptr inbounds [10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 2
  br label %5

13:                                               ; preds = %10
  %14 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 3), align 4, !tbaa !8
  %15 = icmp eq i8* %14, %1
  br i1 %15, label %._crit_edge3, label %16

._crit_edge3:                                     ; preds = %13
  %.3 = getelementptr inbounds [10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 3
  br label %5

16:                                               ; preds = %13
  %17 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 4), align 4, !tbaa !8
  %18 = icmp eq i8* %17, %1
  br i1 %18, label %._crit_edge4, label %19

._crit_edge4:                                     ; preds = %16
  %.4 = getelementptr inbounds [10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 4
  br label %5

19:                                               ; preds = %16
  %20 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 5), align 4, !tbaa !8
  %21 = icmp eq i8* %20, %1
  br i1 %21, label %._crit_edge5, label %22

._crit_edge5:                                     ; preds = %19
  %.5 = getelementptr inbounds [10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 5
  br label %5

22:                                               ; preds = %19
  %23 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 6), align 4, !tbaa !8
  %24 = icmp eq i8* %23, %1
  br i1 %24, label %._crit_edge6, label %25

._crit_edge6:                                     ; preds = %22
  %.6 = getelementptr inbounds [10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 6
  br label %5

25:                                               ; preds = %22
  %26 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 7), align 4, !tbaa !8
  %27 = icmp eq i8* %26, %1
  br i1 %27, label %._crit_edge7, label %28

._crit_edge7:                                     ; preds = %25
  %.7 = getelementptr inbounds [10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 7
  br label %5

28:                                               ; preds = %25
  %29 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 8), align 4, !tbaa !8
  %30 = icmp eq i8* %29, %1
  br i1 %30, label %._crit_edge8, label %31

._crit_edge8:                                     ; preds = %28
  %.8 = getelementptr inbounds [10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 8
  br label %5

31:                                               ; preds = %28
  %32 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 9), align 4, !tbaa !8
  %33 = icmp eq i8* %32, %1
  br i1 %33, label %._crit_edge9, label %34

._crit_edge9:                                     ; preds = %31
  %.9 = getelementptr inbounds [10 x i32], [10 x i32]* @_ZN6Halide7Runtime8Internal11buf_is_usedE, i32 0, i32 9
  br label %5

34:                                               ; preds = %31
  tail call void @_ZN6Halide7Runtime8Internal12aligned_freeEPv(i8* %1) #9
  br label %9
}

; Function Attrs: nounwind
define linkonce void @_ZN6Halide7Runtime8Internal12aligned_freeEPv(i8* %0) local_unnamed_addr #2 {
  %2 = icmp eq i8* %0, null
  br i1 %2, label %7, label %3

3:                                                ; preds = %1
  %4 = getelementptr inbounds i8, i8* %0, i32 -4
  %5 = bitcast i8* %4 to i8**
  %6 = load i8*, i8** %5, align 4, !tbaa !8
  tail call void @free(i8* %6) #8
  br label %7

7:                                                ; preds = %3, %1
  ret void
}

declare void @free(i8* %0) local_unnamed_addr #1

; Function Attrs: nounwind
define linkonce void @_ZN6Halide7Runtime8Internal24halide_allocator_cleanupEv() #2 {
  %1 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 0), align 4, !tbaa !8
  tail call void @_ZN6Halide7Runtime8Internal12aligned_freeEPv(i8* %1) #9
  %2 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 1), align 4, !tbaa !8
  tail call void @_ZN6Halide7Runtime8Internal12aligned_freeEPv(i8* %2) #9
  %3 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 2), align 4, !tbaa !8
  tail call void @_ZN6Halide7Runtime8Internal12aligned_freeEPv(i8* %3) #9
  %4 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 3), align 4, !tbaa !8
  tail call void @_ZN6Halide7Runtime8Internal12aligned_freeEPv(i8* %4) #9
  %5 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 4), align 4, !tbaa !8
  tail call void @_ZN6Halide7Runtime8Internal12aligned_freeEPv(i8* %5) #9
  %6 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 5), align 4, !tbaa !8
  tail call void @_ZN6Halide7Runtime8Internal12aligned_freeEPv(i8* %6) #9
  %7 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 6), align 4, !tbaa !8
  tail call void @_ZN6Halide7Runtime8Internal12aligned_freeEPv(i8* %7) #9
  %8 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 7), align 4, !tbaa !8
  tail call void @_ZN6Halide7Runtime8Internal12aligned_freeEPv(i8* %8) #9
  %9 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 8), align 4, !tbaa !8
  tail call void @_ZN6Halide7Runtime8Internal12aligned_freeEPv(i8* %9) #9
  %10 = load i8*, i8** getelementptr inbounds ([10 x i8*], [10 x i8*]* @_ZN6Halide7Runtime8Internal7mem_bufE, i32 0, i32 9), align 4, !tbaa !8
  tail call void @_ZN6Halide7Runtime8Internal12aligned_freeEPv(i8* %10) #9
  ret void
}

; Function Attrs: nounwind
define weak i8* (i8*, i32)* @halide_set_custom_malloc(i8* (i8*, i32)* %0) local_unnamed_addr #2 {
  tail call void @halide_print(i8* null, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str, i32 0, i32 0)) #8
  %2 = load i8* (i8*, i32)*, i8* (i8*, i32)** @_ZN6Halide7Runtime8Internal13custom_mallocE, align 4, !tbaa !8
  store i8* (i8*, i32)* %0, i8* (i8*, i32)** @_ZN6Halide7Runtime8Internal13custom_mallocE, align 4, !tbaa !8
  ret i8* (i8*, i32)* %2
}

declare void @halide_print(i8* %0, i8* %1) local_unnamed_addr #1

; Function Attrs: nounwind
define weak void (i8*, i8*)* @halide_set_custom_free(void (i8*, i8*)* %0) local_unnamed_addr #2 {
  tail call void @halide_print(i8* null, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str, i32 0, i32 0)) #8
  %2 = load void (i8*, i8*)*, void (i8*, i8*)** @_ZN6Halide7Runtime8Internal11custom_freeE, align 4, !tbaa !8
  store void (i8*, i8*)* %0, void (i8*, i8*)** @_ZN6Halide7Runtime8Internal11custom_freeE, align 4, !tbaa !8
  ret void (i8*, i8*)* %2
}

; Function Attrs: nounwind
define weak i8* @halide_malloc(i8* %0, i32 %1) local_unnamed_addr #2 {
  %3 = tail call i8* @halide_default_malloc(i8* %0, i32 %1) #9
  ret i8* %3
}

; Function Attrs: nounwind
define weak void @halide_free(i8* %0, i8* %1) local_unnamed_addr #2 {
  tail call void @halide_default_free(i8* %0, i8* %1) #9
  ret void
}

; Function Attrs: nounwind
define weak i32 @halide_default_do_task(i8* %0, i32 (i8*, i32, i8*)* %1, i32 %2, i8* %3) #2 {
  %5 = tail call i32 %1(i8* %0, i32 %2, i8* %3) #10
  ret i32 %5
}

; Function Attrs: nounwind
define weak i32 @halide_default_do_loop_task(i8* %0, i32 (i8*, i32, i32, i8*, i8*)* %1, i32 %2, i32 %3, i8* %4, i8* %5) #2 {
  %7 = tail call i32 %1(i8* %0, i32 %2, i32 %3, i8* %4, i8* %5) #10
  ret i32 %7
}

; Function Attrs: nounwind
define weak i32 @halide_default_do_par_for(i8* %0, i32 (i8*, i32, i8*)* %1, i32 %2, i32 %3, i8* %4) #2 {
  %6 = add nsw i32 %3, %2
  %7 = icmp sgt i32 %3, 0
  br i1 %7, label %.preheader, label %.loopexit

8:                                                ; preds = %.preheader
  %9 = icmp slt i32 %13, %6
  br i1 %9, label %.preheader, label %.loopexit

.preheader:                                       ; preds = %5, %8
  %10 = phi i32 [ %13, %8 ], [ %2, %5 ]
  %11 = tail call i32 @halide_do_task(i8* %0, i32 (i8*, i32, i8*)* %1, i32 %10, i8* %4) #9
  %12 = icmp eq i32 %11, 0
  %13 = add nsw i32 %10, 1
  br i1 %12, label %8, label %.loopexit

.loopexit:                                        ; preds = %.preheader, %8, %5
  %14 = phi i32 [ 0, %5 ], [ %11, %.preheader ], [ 0, %8 ]
  ret i32 %14
}

; Function Attrs: nounwind
define weak i32 @halide_do_task(i8* %0, i32 (i8*, i32, i8*)* %1, i32 %2, i8* %3) local_unnamed_addr #2 {
  %5 = load i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)*, i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)** @_ZN6Halide7Runtime8Internal14custom_do_taskE, align 4, !tbaa !8
  %6 = tail call i32 %5(i8* %0, i32 (i8*, i32, i8*)* %1, i32 %2, i8* %3) #10
  ret i32 %6
}

; Function Attrs: nounwind
define weak i32 @halide_default_do_parallel_tasks(i8* %0, i32 %1, %struct.halide_parallel_task_t* %2, i8* %3) #2 {
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.1, i32 0, i32 0)) #8
  ret i32 -1
}

declare void @halide_error(i8* %0, i8* %1) local_unnamed_addr #1

; Function Attrs: nounwind
define weak i32 @halide_default_semaphore_init(%struct.halide_semaphore_t* %0, i32 %1) #2 {
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([64 x i8], [64 x i8]* @.str.1.2, i32 0, i32 0)) #8
  ret i32 0
}

; Function Attrs: nounwind
define weak zeroext i1 @halide_default_semaphore_try_acquire(%struct.halide_semaphore_t* %0, i32 %1) #2 {
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([71 x i8], [71 x i8]* @.str.3, i32 0, i32 0)) #8
  ret i1 false
}

; Function Attrs: nounwind
define weak i32 @halide_default_semaphore_release(%struct.halide_semaphore_t* %0, i32 %1) #2 {
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.2, i32 0, i32 0)) #8
  ret i32 0
}

; Function Attrs: nounwind
define weak %struct.halide_thread* @halide_spawn_thread(void (i8*)* %0, i8* %1) local_unnamed_addr #2 {
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.4, i32 0, i32 0)) #8
  ret %struct.halide_thread* null
}

; Function Attrs: nounwind
define weak void @halide_join_thread(%struct.halide_thread* %0) local_unnamed_addr #2 {
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.5, i32 0, i32 0)) #8
  ret void
}

; Function Attrs: nounwind
define weak void @halide_mutex_lock(%struct.halide_mutex* %0) local_unnamed_addr #2 {
  ret void
}

; Function Attrs: nounwind
define weak void @halide_mutex_unlock(%struct.halide_mutex* %0) local_unnamed_addr #2 {
  ret void
}

; Function Attrs: nounwind
define weak %struct.halide_mutex_array* @halide_mutex_array_create(i32 %0) local_unnamed_addr #2 {
  ret %struct.halide_mutex_array* null
}

; Function Attrs: nounwind
define weak void @halide_mutex_array_destroy(i8* %0, i8* %1) local_unnamed_addr #2 {
  ret void
}

; Function Attrs: nounwind
define weak i32 @halide_mutex_array_lock(%struct.halide_mutex_array* %0, i32 %1) local_unnamed_addr #2 {
  ret i32 0
}

; Function Attrs: nounwind
define weak i32 @halide_mutex_array_unlock(%struct.halide_mutex_array* %0, i32 %1) local_unnamed_addr #2 {
  ret i32 0
}

; Function Attrs: nounwind
define weak void @halide_shutdown_thread_pool() local_unnamed_addr #2 {
  ret void
}

; Function Attrs: nounwind
define weak i32 @halide_set_num_threads(i32 %0) local_unnamed_addr #2 {
  %2 = icmp eq i32 %0, 1
  br i1 %2, label %4, label %3

3:                                                ; preds = %1
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.6, i32 0, i32 0)) #8
  br label %4

4:                                                ; preds = %3, %1
  ret i32 1
}

; Function Attrs: nounwind
define weak i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)* @halide_set_custom_do_task(i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)* %0) local_unnamed_addr #2 {
  %2 = load i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)*, i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)** @_ZN6Halide7Runtime8Internal14custom_do_taskE, align 4, !tbaa !8
  store i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)* %0, i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)** @_ZN6Halide7Runtime8Internal14custom_do_taskE, align 4, !tbaa !8
  ret i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)* %2
}

; Function Attrs: nounwind
define weak i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)* @halide_set_custom_do_par_for(i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)* %0) local_unnamed_addr #2 {
  %2 = load i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)*, i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)** @_ZN6Halide7Runtime8Internal17custom_do_par_forE, align 4, !tbaa !8
  store i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)* %0, i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)** @_ZN6Halide7Runtime8Internal17custom_do_par_forE, align 4, !tbaa !8
  ret i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)* %2
}

; Function Attrs: nounwind
define weak i32 @halide_do_par_for(i8* %0, i32 (i8*, i32, i8*)* %1, i32 %2, i32 %3, i8* %4) local_unnamed_addr #2 {
  %6 = load i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)*, i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)** @_ZN6Halide7Runtime8Internal17custom_do_par_forE, align 4, !tbaa !8
  %7 = tail call i32 %6(i8* %0, i32 (i8*, i32, i8*)* %1, i32 %2, i32 %3, i8* %4) #10
  ret i32 %7
}

; Function Attrs: nounwind
define weak i32 @halide_do_loop_task(i8* %0, i32 (i8*, i32, i32, i8*, i8*)* %1, i32 %2, i32 %3, i8* %4, i8* %5) local_unnamed_addr #2 {
  %7 = load i32 (i8*, i32 (i8*, i32, i32, i8*, i8*)*, i32, i32, i8*, i8*)*, i32 (i8*, i32 (i8*, i32, i32, i8*, i8*)*, i32, i32, i8*, i8*)** @_ZN6Halide7Runtime8Internal19custom_do_loop_taskE, align 4, !tbaa !8
  %8 = tail call i32 %7(i8* %0, i32 (i8*, i32, i32, i8*, i8*)* %1, i32 %2, i32 %3, i8* %4, i8* %5) #10
  ret i32 %8
}

; Function Attrs: nounwind
define weak i32 @halide_do_parallel_tasks(i8* %0, i32 %1, %struct.halide_parallel_task_t* %2, i8* %3) local_unnamed_addr #2 {
  %5 = load i32 (i8*, i32, %struct.halide_parallel_task_t*, i8*)*, i32 (i8*, i32, %struct.halide_parallel_task_t*, i8*)** @_ZN6Halide7Runtime8Internal24custom_do_parallel_tasksE, align 4, !tbaa !8
  %6 = tail call i32 %5(i8* %0, i32 %1, %struct.halide_parallel_task_t* %2, i8* %3) #10
  ret i32 %6
}

; Function Attrs: nounwind
define weak i32 @halide_semaphore_init(%struct.halide_semaphore_t* %0, i32 %1) local_unnamed_addr #2 {
  %3 = load i32 (%struct.halide_semaphore_t*, i32)*, i32 (%struct.halide_semaphore_t*, i32)** @_ZN6Halide7Runtime8Internal21custom_semaphore_initE, align 4, !tbaa !8
  %4 = tail call i32 %3(%struct.halide_semaphore_t* %0, i32 %1) #10
  ret i32 %4
}

; Function Attrs: nounwind
define weak i32 @halide_semaphore_release(%struct.halide_semaphore_t* %0, i32 %1) local_unnamed_addr #2 {
  %3 = load i32 (%struct.halide_semaphore_t*, i32)*, i32 (%struct.halide_semaphore_t*, i32)** @_ZN6Halide7Runtime8Internal24custom_semaphore_releaseE, align 4, !tbaa !8
  %4 = tail call i32 %3(%struct.halide_semaphore_t* %0, i32 %1) #10
  ret i32 %4
}

; Function Attrs: nounwind
define weak zeroext i1 @halide_semaphore_try_acquire(%struct.halide_semaphore_t* %0, i32 %1) local_unnamed_addr #2 {
  %3 = load i1 (%struct.halide_semaphore_t*, i32)*, i1 (%struct.halide_semaphore_t*, i32)** @_ZN6Halide7Runtime8Internal28custom_semaphore_try_acquireE, align 4, !tbaa !8
  %4 = tail call zeroext i1 %3(%struct.halide_semaphore_t* %0, i32 %1) #10
  ret i1 %4
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg %0, i8* nocapture %1) #3

declare i8* @memcpy(i8* %0, i8* %1, i32 %2) local_unnamed_addr #1

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg %0, i8* nocapture %1) #3

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind
define weak void @halide_set_gpu_device(i32 %0) local_unnamed_addr #2 {
  store i32 %0, i32* @_ZN6Halide7Runtime8Internal17halide_gpu_deviceE, align 4, !tbaa !12
  store i8 1, i8* @_ZN6Halide7Runtime8Internal29halide_gpu_device_initializedE, align 1, !tbaa !14
  ret void
}

; Function Attrs: nounwind
define weak i32 @halide_get_gpu_device(i8* %0) local_unnamed_addr #2 {
  br label %2

2:                                                ; preds = %2, %1
  %3 = atomicrmw volatile xchg i8* @_ZN6Halide7Runtime8Internal22halide_gpu_device_lockE, i8 1 acquire
  %4 = icmp eq i8 %3, 0
  br i1 %4, label %5, label %2

5:                                                ; preds = %2
  %6 = load i8, i8* @_ZN6Halide7Runtime8Internal29halide_gpu_device_initializedE, align 1, !tbaa !14, !range !16
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %10, label %8

8:                                                ; preds = %5
  %9 = load i32, i32* @_ZN6Halide7Runtime8Internal17halide_gpu_deviceE, align 4, !tbaa !12
  br label %17

10:                                               ; preds = %5
  %11 = tail call i8* @getenv(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.7, i32 0, i32 0)) #8
  %12 = icmp eq i8* %11, null
  br i1 %12, label %15, label %13

13:                                               ; preds = %10
  %14 = tail call i32 @atoi(i8* nonnull %11) #8
  br label %15

15:                                               ; preds = %13, %10
  %16 = phi i32 [ %14, %13 ], [ -1, %10 ]
  store i32 %16, i32* @_ZN6Halide7Runtime8Internal17halide_gpu_deviceE, align 4, !tbaa !12
  store i8 1, i8* @_ZN6Halide7Runtime8Internal29halide_gpu_device_initializedE, align 1, !tbaa !14
  br label %17

17:                                               ; preds = %15, %8
  %18 = phi i32 [ %9, %8 ], [ %16, %15 ]
  store atomic volatile i8 0, i8* @_ZN6Halide7Runtime8Internal22halide_gpu_device_lockE release, align 1
  ret i32 %18
}

declare i8* @getenv(i8* %0) local_unnamed_addr #1

declare i32 @atoi(i8* %0) local_unnamed_addr #1

; Function Attrs: nounwind
define weak i8* @halide_string_to_string(i8* %0, i8* %1, i8* %2) local_unnamed_addr #2 {
  %4 = icmp ult i8* %0, %1
  br i1 %4, label %.preheader, label %.loopexit

5:                                                ; preds = %10
  store i8 0, i8* %7, align 1, !tbaa !17
  br label %.loopexit

.preheader:                                       ; preds = %3, %10
  %6 = phi i8* [ %12, %10 ], [ %2, %3 ]
  %7 = phi i8* [ %11, %10 ], [ %0, %3 ]
  %8 = load i8, i8* %6, align 1, !tbaa !17
  store i8 %8, i8* %7, align 1, !tbaa !17
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %.loopexit, label %10

10:                                               ; preds = %.preheader
  %11 = getelementptr inbounds i8, i8* %7, i32 1
  %12 = getelementptr inbounds i8, i8* %6, i32 1
  %13 = icmp eq i8* %11, %1
  br i1 %13, label %5, label %.preheader

.loopexit:                                        ; preds = %.preheader, %5, %3
  %14 = phi i8* [ %1, %5 ], [ %0, %3 ], [ %7, %.preheader ]
  ret i8* %14
}

; Function Attrs: nounwind
define weak i8* @halide_uint64_to_string(i8* %0, i8* %1, i64 %2, i32 %3) local_unnamed_addr #2 {
  %5 = alloca [32 x i8], align 1
  %6 = getelementptr inbounds [32 x i8], [32 x i8]* %5, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %6) #6
  %7 = getelementptr inbounds [32 x i8], [32 x i8]* %5, i32 0, i32 31
  store i8 0, i8* %7, align 1, !tbaa !17
  %8 = getelementptr inbounds [32 x i8], [32 x i8]* %5, i32 0, i32 30
  %9 = icmp sgt i32 %3, 0
  %10 = icmp ne i64 %2, 0
  %11 = or i1 %10, %9
  br i1 %11, label %..preheader_crit_edge, label %.loopexit

..preheader_crit_edge:                            ; preds = %4
  %.1 = add nuw nsw i32 0, 1
  br label %.preheader

.loopexit:                                        ; preds = %.preheader, %4
  %12 = phi i8* [ %8, %4 ], [ %22, %.preheader ]
  %13 = getelementptr inbounds i8, i8* %12, i32 1
  %14 = call i8* @halide_string_to_string(i8* %0, i8* %1, i8* nonnull %13) #9
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %6) #6
  ret i8* %14

.preheader:                                       ; preds = %..preheader_crit_edge, %.preheader..preheader_crit_edge
  %15 = phi i64 [ %17, %.preheader..preheader_crit_edge ], [ %2, %..preheader_crit_edge ]
  %16 = phi i8* [ %22, %.preheader..preheader_crit_edge ], [ %8, %..preheader_crit_edge ]
  %.phi = phi i32 [ %.0, %.preheader..preheader_crit_edge ], [ %.1, %..preheader_crit_edge ]
  %17 = udiv i64 %15, 10
  %18 = mul i64 %17, -10
  %19 = add i64 %18, %15
  %20 = trunc i64 %19 to i8
  %21 = add i8 %20, 48
  store i8 %21, i8* %16, align 1, !tbaa !17
  %22 = getelementptr inbounds i8, i8* %16, i32 -1
  %23 = icmp slt i32 %.phi, %3
  %24 = icmp ugt i64 %15, 9
  %25 = or i1 %24, %23
  br i1 %25, label %.preheader..preheader_crit_edge, label %.loopexit

.preheader..preheader_crit_edge:                  ; preds = %.preheader
  %.0 = add nuw nsw i32 %.phi, 1
  br label %.preheader
}

; Function Attrs: nounwind
define weak i8* @halide_int64_to_string(i8* %0, i8* %1, i64 %2, i32 %3) local_unnamed_addr #2 {
  %5 = icmp slt i64 %2, 0
  %6 = icmp ult i8* %0, %1
  %7 = and i1 %6, %5
  br i1 %7, label %8, label %11

8:                                                ; preds = %4
  %9 = sub nsw i64 0, %2
  %10 = getelementptr inbounds i8, i8* %0, i32 1
  store i8 45, i8* %0, align 1, !tbaa !17
  br label %11

11:                                               ; preds = %8, %4
  %12 = phi i64 [ %9, %8 ], [ %2, %4 ]
  %13 = phi i8* [ %10, %8 ], [ %0, %4 ]
  %14 = tail call i8* @halide_uint64_to_string(i8* %13, i8* %1, i64 %12, i32 %3) #9
  ret i8* %14
}

; Function Attrs: nounwind
define weak i8* @halide_double_to_string(i8* %0, i8* %1, double %2, i32 %3) local_unnamed_addr #2 {
  %5 = alloca double, align 8
  %6 = alloca i64, align 8
  %7 = alloca [512 x i8], align 1
  store double %2, double* %5, align 8, !tbaa !18
  %8 = bitcast i64* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %8) #6
  store i64 0, i64* %6, align 8, !tbaa !20
  %9 = bitcast double* %5 to i8*
  %10 = call i8* @memcpy(i8* nonnull %8, i8* nonnull %9, i32 8) #8
  %11 = load i64, i64* %6, align 8, !tbaa !20
  %12 = and i64 %11, 4503599627370495
  %13 = lshr i64 %11, 52
  %14 = trunc i64 %13 to i32
  %15 = and i32 %14, 2047
  %16 = icmp eq i32 %15, 2047
  br i1 %16, label %17, label %30

17:                                               ; preds = %4
  %18 = icmp eq i64 %12, 0
  %19 = icmp slt i64 %11, 0
  br i1 %18, label %25, label %20

20:                                               ; preds = %17
  br i1 %19, label %21, label %23

21:                                               ; preds = %20
  %22 = call i8* @halide_string_to_string(i8* %0, i8* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.8, i32 0, i32 0)) #9
  br label %185

23:                                               ; preds = %20
  %24 = call i8* @halide_string_to_string(i8* %0, i8* %1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1.9, i32 0, i32 0)) #9
  br label %185

25:                                               ; preds = %17
  br i1 %19, label %26, label %28

26:                                               ; preds = %25
  %27 = call i8* @halide_string_to_string(i8* %0, i8* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2.10, i32 0, i32 0)) #9
  br label %185

28:                                               ; preds = %25
  %29 = call i8* @halide_string_to_string(i8* %0, i8* %1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3.11, i32 0, i32 0)) #9
  br label %185

30:                                               ; preds = %4
  %31 = icmp eq i32 %15, 0
  %32 = icmp eq i64 %12, 0
  %33 = and i1 %32, %31
  br i1 %33, label %34, label %47

34:                                               ; preds = %30
  %35 = icmp eq i32 %3, 0
  %36 = icmp slt i64 %11, 0
  br i1 %35, label %42, label %37

37:                                               ; preds = %34
  br i1 %36, label %38, label %40

38:                                               ; preds = %37
  %39 = call i8* @halide_string_to_string(i8* %0, i8* %1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.4.12, i32 0, i32 0)) #9
  br label %185

40:                                               ; preds = %37
  %41 = call i8* @halide_string_to_string(i8* %0, i8* %1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.5.13, i32 0, i32 0)) #9
  br label %185

42:                                               ; preds = %34
  br i1 %36, label %43, label %45

43:                                               ; preds = %42
  %44 = call i8* @halide_string_to_string(i8* %0, i8* %1, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.6.14, i32 0, i32 0)) #9
  br label %185

45:                                               ; preds = %42
  %46 = call i8* @halide_string_to_string(i8* %0, i8* %1, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.7.15, i32 0, i32 0)) #9
  br label %185

47:                                               ; preds = %30
  %48 = icmp slt i64 %11, 0
  br i1 %48, label %49, label %53

49:                                               ; preds = %47
  %50 = call i8* @halide_string_to_string(i8* %0, i8* %1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8.16, i32 0, i32 0)) #9
  %51 = load double, double* %5, align 8, !tbaa !18
  %52 = fneg double %51
  store double %52, double* %5, align 8, !tbaa !18
  br label %53

53:                                               ; preds = %49, %47
  %54 = phi i8* [ %50, %49 ], [ %0, %47 ]
  %55 = icmp eq i32 %3, 0
  br i1 %55, label %96, label %56

56:                                               ; preds = %53
  %57 = load double, double* %5, align 8, !tbaa !18
  %58 = fcmp olt double %57, 1.000000e+00
  br i1 %58, label %..preheader15_crit_edge, label %63

..preheader15_crit_edge:                          ; preds = %56
  %.1 = add nsw i32 0, -1
  br label %.preheader15

.preheader15:                                     ; preds = %..preheader15_crit_edge, %.preheader15..preheader15_crit_edge
  %.phi = phi i32 [ %.0, %.preheader15..preheader15_crit_edge ], [ %.1, %..preheader15_crit_edge ]
  %59 = phi double [ %60, %.preheader15..preheader15_crit_edge ], [ %57, %..preheader15_crit_edge ]
  %60 = fmul double %59, 1.000000e+01
  %61 = fcmp olt double %60, 1.000000e+00
  br i1 %61, label %.preheader15..preheader15_crit_edge, label %62

.preheader15..preheader15_crit_edge:              ; preds = %.preheader15
  %.0 = add nsw i32 %.phi, -1
  br label %.preheader15

62:                                               ; preds = %.preheader15
  store double %60, double* %5, align 8, !tbaa !18
  br label %63

63:                                               ; preds = %62, %56
  %64 = phi double [ %60, %62 ], [ %57, %56 ]
  %65 = phi i32 [ %.phi, %62 ], [ 0, %56 ]
  %66 = fcmp ult double %64, 1.000000e+01
  br i1 %66, label %73, label %.preheader14

.preheader14:                                     ; preds = %63, %.preheader14
  %67 = phi i32 [ %70, %.preheader14 ], [ %65, %63 ]
  %68 = phi double [ %69, %.preheader14 ], [ %64, %63 ]
  %69 = fdiv double %68, 1.000000e+01
  %70 = add nsw i32 %67, 1
  %71 = fcmp ult double %69, 1.000000e+01
  br i1 %71, label %72, label %.preheader14

72:                                               ; preds = %.preheader14
  store double %69, double* %5, align 8, !tbaa !18
  br label %73

73:                                               ; preds = %72, %63
  %74 = phi double [ %69, %72 ], [ %64, %63 ]
  %75 = phi i32 [ %70, %72 ], [ %65, %63 ]
  %76 = fmul double %74, 1.000000e+06
  %77 = fadd double %76, 5.000000e-01
  %78 = fptoui double %77 to i64
  %79 = udiv i64 %78, 1000000
  %80 = mul i64 %79, -1000000
  %81 = add i64 %80, %78
  %82 = call i8* @halide_int64_to_string(i8* %54, i8* %1, i64 %79, i32 1) #9
  %83 = call i8* @halide_string_to_string(i8* %82, i8* %1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.30.67, i32 0, i32 0)) #9
  %84 = call i8* @halide_int64_to_string(i8* %83, i8* %1, i64 %81, i32 6) #9
  %85 = icmp sgt i32 %75, -1
  br i1 %85, label %86, label %88

86:                                               ; preds = %73
  %87 = call i8* @halide_string_to_string(i8* %84, i8* %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.10, i32 0, i32 0)) #9
  br label %91

88:                                               ; preds = %73
  %89 = call i8* @halide_string_to_string(i8* %84, i8* %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.11, i32 0, i32 0)) #9
  %90 = sub nsw i32 0, %75
  br label %91

91:                                               ; preds = %88, %86
  %92 = phi i32 [ %75, %86 ], [ %90, %88 ]
  %93 = phi i8* [ %87, %86 ], [ %89, %88 ]
  %94 = zext i32 %92 to i64
  %95 = call i8* @halide_int64_to_string(i8* %93, i8* %1, i64 %94, i32 2) #9
  br label %185

96:                                               ; preds = %53
  br i1 %31, label %97, label %99

97:                                               ; preds = %96
  %98 = call i8* @halide_double_to_string(i8* %54, i8* %1, double 0.000000e+00, i32 0) #9
  br label %185

99:                                               ; preds = %96
  %100 = or i64 %12, 4503599627370496
  %101 = add nsw i32 %15, -1075
  %102 = icmp ult i32 %15, 1075
  br i1 %102, label %103, label %129

103:                                              ; preds = %99
  %104 = icmp ult i32 %15, 1023
  %105 = sub nuw nsw i32 1075, %15
  %106 = zext i32 %105 to i64
  %107 = lshr i64 %100, %106
  %108 = shl i64 %107, %106
  %spec.select = select i1 %104, i64 0, i64 %107
  %109 = select i1 %104, i64 0, i64 %108
  %spec.select12 = sub i64 %100, %109
  %110 = uitofp i64 %spec.select12 to double
  %111 = zext i32 %101 to i64
  %112 = shl i64 %111, 52
  %113 = add i64 %112, 4696837146684686336
  %114 = bitcast i64 %113 to double
  %115 = fmul double %114, %110
  %116 = fadd double %115, 5.000000e-01
  %117 = fptoui double %116 to i64
  %118 = uitofp i64 %117 to double
  %119 = fcmp oeq double %116, %118
  %120 = and i64 %117, 1
  %121 = icmp ne i64 %120, 0
  %122 = and i1 %121, %119
  %123 = sext i1 %122 to i64
  %124 = add i64 %123, %117
  %125 = icmp eq i64 %124, 1000000
  %126 = zext i1 %125 to i64
  %127 = add nuw i64 %spec.select, %126
  %128 = select i1 %125, i64 0, i64 %124
  br label %129

129:                                              ; preds = %103, %99
  %130 = phi i64 [ %127, %103 ], [ %100, %99 ]
  %131 = phi i32 [ 0, %103 ], [ %101, %99 ]
  %132 = phi i64 [ %128, %103 ], [ 0, %99 ]
  %133 = getelementptr inbounds [512 x i8], [512 x i8]* %7, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 512, i8* nonnull %133) #6
  %134 = getelementptr inbounds [512 x i8], [512 x i8]* %7, i32 0, i32 512
  %135 = getelementptr inbounds [512 x i8], [512 x i8]* %7, i32 0, i32 480
  %136 = call i8* @halide_int64_to_string(i8* nonnull %135, i8* nonnull %134, i64 %130, i32 1) #9
  %137 = icmp sgt i32 %131, 0
  br i1 %137, label %.preheader13.preheader, label %.loopexit

.preheader13.preheader:                           ; preds = %129
  %138 = add nsw i32 %131, -1
  %xtraiter = and i32 %131, 3
  %139 = icmp ult i32 %138, 3
  br i1 %139, label %.loopexit.loopexit.unr-lcssa, label %.preheader13.preheader.new

.preheader13.preheader.new:                       ; preds = %.preheader13.preheader
  %unroll_iter = sub nsw i32 %131, %xtraiter
  br label %.preheader13

.preheader13:                                     ; preds = %238, %.preheader13.preheader.new
  %140 = phi i8* [ %135, %.preheader13.preheader.new ], [ %239, %238 ]
  %niter = phi i32 [ %unroll_iter, %.preheader13.preheader.new ], [ %niter.nsub.3, %238 ]
  %141 = getelementptr inbounds i8, i8* %140, i32 -1
  %142 = icmp eq i8* %136, %140
  br i1 %142, label %.preheader13.1, label %.preheader

.loopexit.loopexit.unr-lcssa:                     ; preds = %238, %.preheader13.preheader
  %.lcssa36.ph = phi i8* [ undef, %.preheader13.preheader ], [ %239, %238 ]
  %.unr41 = phi i8* [ %135, %.preheader13.preheader ], [ %239, %238 ]
  %lcmp.mod = icmp eq i32 %xtraiter, 0
  br i1 %lcmp.mod, label %.loopexit, label %.preheader13.epil

.preheader13.epil:                                ; preds = %.loopexit.loopexit.unr-lcssa, %161
  %143 = phi i8* [ %162, %161 ], [ %.unr41, %.loopexit.loopexit.unr-lcssa ]
  %epil.iter = phi i32 [ %epil.iter.sub, %161 ], [ %xtraiter, %.loopexit.loopexit.unr-lcssa ]
  %144 = getelementptr inbounds i8, i8* %143, i32 -1
  %145 = icmp eq i8* %136, %143
  br i1 %145, label %161, label %.preheader.epil

.preheader.epil:                                  ; preds = %.preheader13.epil, %.preheader.epil
  %146 = phi i8* [ %148, %.preheader.epil ], [ %136, %.preheader13.epil ]
  %147 = phi i8 [ %155, %.preheader.epil ], [ 0, %.preheader13.epil ]
  %148 = getelementptr inbounds i8, i8* %146, i32 -1
  %149 = load i8, i8* %148, align 1, !tbaa !17
  %150 = shl i8 %149, 1
  %151 = add i8 %150, -96
  %152 = or i8 %151, %147
  %153 = icmp sgt i8 %152, 9
  %154 = add i8 %152, -10
  %155 = zext i1 %153 to i8
  %156 = select i1 %153, i8 %154, i8 %152
  %157 = add i8 %156, 48
  store i8 %157, i8* %148, align 1, !tbaa !17
  %158 = icmp eq i8* %148, %143
  br i1 %158, label %159, label %.preheader.epil

159:                                              ; preds = %.preheader.epil
  br i1 %153, label %160, label %161

160:                                              ; preds = %159
  store i8 49, i8* %144, align 1, !tbaa !17
  br label %161

161:                                              ; preds = %160, %159, %.preheader13.epil
  %162 = phi i8* [ %144, %160 ], [ %143, %159 ], [ %136, %.preheader13.epil ]
  %epil.iter.sub = add i32 %epil.iter, -1
  %epil.iter.cmp = icmp eq i32 %epil.iter.sub, 0
  br i1 %epil.iter.cmp, label %.loopexit, label %.preheader13.epil, !llvm.loop !22

.loopexit:                                        ; preds = %.loopexit.loopexit.unr-lcssa, %161, %129
  %163 = phi i8* [ %135, %129 ], [ %.lcssa36.ph, %.loopexit.loopexit.unr-lcssa ], [ %162, %161 ]
  %164 = call i8* @halide_string_to_string(i8* %54, i8* %1, i8* %163) #9
  %165 = call i8* @halide_string_to_string(i8* %164, i8* %1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.30.67, i32 0, i32 0)) #9
  %166 = call i8* @halide_int64_to_string(i8* %165, i8* %1, i64 %132, i32 6) #9
  call void @llvm.lifetime.end.p0i8(i64 512, i8* nonnull %133) #6
  br label %185

167:                                              ; preds = %.preheader
  br i1 %175, label %181, label %.preheader13.1

.preheader:                                       ; preds = %.preheader13, %.preheader
  %168 = phi i8* [ %170, %.preheader ], [ %136, %.preheader13 ]
  %169 = phi i8 [ %177, %.preheader ], [ 0, %.preheader13 ]
  %170 = getelementptr inbounds i8, i8* %168, i32 -1
  %171 = load i8, i8* %170, align 1, !tbaa !17
  %172 = shl i8 %171, 1
  %173 = add i8 %172, -96
  %174 = or i8 %173, %169
  %175 = icmp sgt i8 %174, 9
  %176 = add i8 %174, -10
  %177 = zext i1 %175 to i8
  %178 = select i1 %175, i8 %176, i8 %174
  %179 = add i8 %178, 48
  store i8 %179, i8* %170, align 1, !tbaa !17
  %180 = icmp eq i8* %170, %140
  br i1 %180, label %167, label %.preheader

181:                                              ; preds = %167
  store i8 49, i8* %141, align 1, !tbaa !17
  br label %.preheader13.1

.preheader13.1:                                   ; preds = %181, %167, %.preheader13
  %182 = phi i8* [ %141, %181 ], [ %140, %167 ], [ %136, %.preheader13 ]
  %183 = getelementptr inbounds i8, i8* %182, i32 -1
  %184 = icmp eq i8* %136, %182
  br i1 %184, label %.preheader13.2, label %.preheader.1

185:                                              ; preds = %.loopexit, %97, %91, %45, %43, %40, %38, %28, %26, %23, %21
  %186 = phi i8* [ %22, %21 ], [ %24, %23 ], [ %27, %26 ], [ %29, %28 ], [ %39, %38 ], [ %41, %40 ], [ %44, %43 ], [ %46, %45 ], [ %98, %97 ], [ %95, %91 ], [ %166, %.loopexit ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #6
  ret i8* %186

.preheader.1:                                     ; preds = %.preheader13.1, %.preheader.1
  %187 = phi i8* [ %189, %.preheader.1 ], [ %136, %.preheader13.1 ]
  %188 = phi i8 [ %196, %.preheader.1 ], [ 0, %.preheader13.1 ]
  %189 = getelementptr inbounds i8, i8* %187, i32 -1
  %190 = load i8, i8* %189, align 1, !tbaa !17
  %191 = shl i8 %190, 1
  %192 = add i8 %191, -96
  %193 = or i8 %192, %188
  %194 = icmp sgt i8 %193, 9
  %195 = add i8 %193, -10
  %196 = zext i1 %194 to i8
  %197 = select i1 %194, i8 %195, i8 %193
  %198 = add i8 %197, 48
  store i8 %198, i8* %189, align 1, !tbaa !17
  %199 = icmp eq i8* %189, %182
  br i1 %199, label %200, label %.preheader.1

200:                                              ; preds = %.preheader.1
  br i1 %194, label %201, label %.preheader13.2

201:                                              ; preds = %200
  store i8 49, i8* %183, align 1, !tbaa !17
  br label %.preheader13.2

.preheader13.2:                                   ; preds = %201, %200, %.preheader13.1
  %202 = phi i8* [ %183, %201 ], [ %182, %200 ], [ %136, %.preheader13.1 ]
  %203 = getelementptr inbounds i8, i8* %202, i32 -1
  %204 = icmp eq i8* %136, %202
  br i1 %204, label %.preheader13.3, label %.preheader.2

.preheader.2:                                     ; preds = %.preheader13.2, %.preheader.2
  %205 = phi i8* [ %207, %.preheader.2 ], [ %136, %.preheader13.2 ]
  %206 = phi i8 [ %214, %.preheader.2 ], [ 0, %.preheader13.2 ]
  %207 = getelementptr inbounds i8, i8* %205, i32 -1
  %208 = load i8, i8* %207, align 1, !tbaa !17
  %209 = shl i8 %208, 1
  %210 = add i8 %209, -96
  %211 = or i8 %210, %206
  %212 = icmp sgt i8 %211, 9
  %213 = add i8 %211, -10
  %214 = zext i1 %212 to i8
  %215 = select i1 %212, i8 %213, i8 %211
  %216 = add i8 %215, 48
  store i8 %216, i8* %207, align 1, !tbaa !17
  %217 = icmp eq i8* %207, %202
  br i1 %217, label %218, label %.preheader.2

218:                                              ; preds = %.preheader.2
  br i1 %212, label %219, label %.preheader13.3

219:                                              ; preds = %218
  store i8 49, i8* %203, align 1, !tbaa !17
  br label %.preheader13.3

.preheader13.3:                                   ; preds = %219, %218, %.preheader13.2
  %220 = phi i8* [ %203, %219 ], [ %202, %218 ], [ %136, %.preheader13.2 ]
  %221 = getelementptr inbounds i8, i8* %220, i32 -1
  %222 = icmp eq i8* %136, %220
  br i1 %222, label %238, label %.preheader.3

.preheader.3:                                     ; preds = %.preheader13.3, %.preheader.3
  %223 = phi i8* [ %225, %.preheader.3 ], [ %136, %.preheader13.3 ]
  %224 = phi i8 [ %232, %.preheader.3 ], [ 0, %.preheader13.3 ]
  %225 = getelementptr inbounds i8, i8* %223, i32 -1
  %226 = load i8, i8* %225, align 1, !tbaa !17
  %227 = shl i8 %226, 1
  %228 = add i8 %227, -96
  %229 = or i8 %228, %224
  %230 = icmp sgt i8 %229, 9
  %231 = add i8 %229, -10
  %232 = zext i1 %230 to i8
  %233 = select i1 %230, i8 %231, i8 %229
  %234 = add i8 %233, 48
  store i8 %234, i8* %225, align 1, !tbaa !17
  %235 = icmp eq i8* %225, %220
  br i1 %235, label %236, label %.preheader.3

236:                                              ; preds = %.preheader.3
  br i1 %230, label %237, label %238

237:                                              ; preds = %236
  store i8 49, i8* %221, align 1, !tbaa !17
  br label %238

238:                                              ; preds = %237, %236, %.preheader13.3
  %239 = phi i8* [ %221, %237 ], [ %220, %236 ], [ %136, %.preheader13.3 ]
  %niter.nsub.3 = add i32 %niter, -4
  %niter.ncmp.3 = icmp eq i32 %niter.nsub.3, 0
  br i1 %niter.ncmp.3, label %.loopexit.loopexit.unr-lcssa, label %.preheader13
}

; Function Attrs: nounwind
define weak i8* @halide_pointer_to_string(i8* %0, i8* %1, i8* %2) local_unnamed_addr #2 {
  %4 = alloca [20 x i8], align 1
  %5 = getelementptr inbounds [20 x i8], [20 x i8]* %4, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 20, i8* nonnull %5) #6
  call void @llvm.memset.p0i8.i32(i8* nonnull align 1 dereferenceable(20) %5, i8 0, i32 20, i1 false)
  %6 = getelementptr inbounds [20 x i8], [20 x i8]* %4, i32 0, i32 18
  %7 = ptrtoint i8* %2 to i32
  %8 = and i32 %7, 15
  %9 = getelementptr inbounds [17 x i8], [17 x i8]* @.str.12, i32 0, i32 %8
  %10 = load i8, i8* %9, align 1, !tbaa !17
  %11 = getelementptr inbounds [20 x i8], [20 x i8]* %4, i32 0, i32 17
  store i8 %10, i8* %6, align 1, !tbaa !17
  %12 = lshr i32 %7, 4
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %21, label %14

14:                                               ; preds = %3
  %15 = and i32 %12, 15
  %16 = getelementptr inbounds [17 x i8], [17 x i8]* @.str.12, i32 0, i32 %15
  %17 = load i8, i8* %16, align 1, !tbaa !17
  %18 = getelementptr inbounds [20 x i8], [20 x i8]* %4, i32 0, i32 16
  store i8 %17, i8* %11, align 1, !tbaa !17
  %19 = lshr i32 %7, 8
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %21, label %26

21:                                               ; preds = %61, %54, %47, %40, %33, %26, %14, %3
  %22 = phi i8* [ %6, %3 ], [ %11, %14 ], [ %18, %26 ], [ %30, %33 ], [ %37, %40 ], [ %44, %47 ], [ %51, %54 ], [ %58, %61 ]
  %23 = phi i8* [ %11, %3 ], [ %18, %14 ], [ %30, %26 ], [ %37, %33 ], [ %44, %40 ], [ %51, %47 ], [ %58, %54 ], [ %62, %61 ]
  %24 = getelementptr inbounds i8, i8* %22, i32 -2
  store i8 120, i8* %23, align 1, !tbaa !17
  store i8 48, i8* %24, align 1, !tbaa !17
  %25 = call i8* @halide_string_to_string(i8* %0, i8* %1, i8* nonnull %24) #9
  call void @llvm.lifetime.end.p0i8(i64 20, i8* nonnull %5) #6
  ret i8* %25

26:                                               ; preds = %14
  %27 = and i32 %19, 15
  %28 = getelementptr inbounds [17 x i8], [17 x i8]* @.str.12, i32 0, i32 %27
  %29 = load i8, i8* %28, align 1, !tbaa !17
  %30 = getelementptr inbounds [20 x i8], [20 x i8]* %4, i32 0, i32 15
  store i8 %29, i8* %18, align 1, !tbaa !17
  %31 = lshr i32 %7, 12
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %21, label %33

33:                                               ; preds = %26
  %34 = and i32 %31, 15
  %35 = getelementptr inbounds [17 x i8], [17 x i8]* @.str.12, i32 0, i32 %34
  %36 = load i8, i8* %35, align 1, !tbaa !17
  %37 = getelementptr inbounds [20 x i8], [20 x i8]* %4, i32 0, i32 14
  store i8 %36, i8* %30, align 1, !tbaa !17
  %38 = lshr i32 %7, 16
  %39 = icmp eq i32 %38, 0
  br i1 %39, label %21, label %40

40:                                               ; preds = %33
  %41 = and i32 %38, 15
  %42 = getelementptr inbounds [17 x i8], [17 x i8]* @.str.12, i32 0, i32 %41
  %43 = load i8, i8* %42, align 1, !tbaa !17
  %44 = getelementptr inbounds [20 x i8], [20 x i8]* %4, i32 0, i32 13
  store i8 %43, i8* %37, align 1, !tbaa !17
  %45 = lshr i32 %7, 20
  %46 = icmp eq i32 %45, 0
  br i1 %46, label %21, label %47

47:                                               ; preds = %40
  %48 = and i32 %45, 15
  %49 = getelementptr inbounds [17 x i8], [17 x i8]* @.str.12, i32 0, i32 %48
  %50 = load i8, i8* %49, align 1, !tbaa !17
  %51 = getelementptr inbounds [20 x i8], [20 x i8]* %4, i32 0, i32 12
  store i8 %50, i8* %44, align 1, !tbaa !17
  %52 = lshr i32 %7, 24
  %53 = icmp eq i32 %52, 0
  br i1 %53, label %21, label %54

54:                                               ; preds = %47
  %55 = and i32 %52, 15
  %56 = getelementptr inbounds [17 x i8], [17 x i8]* @.str.12, i32 0, i32 %55
  %57 = load i8, i8* %56, align 1, !tbaa !17
  %58 = getelementptr inbounds [20 x i8], [20 x i8]* %4, i32 0, i32 11
  store i8 %57, i8* %51, align 1, !tbaa !17
  %59 = lshr i32 %7, 28
  %60 = icmp eq i32 %59, 0
  br i1 %60, label %21, label %61

61:                                               ; preds = %54
  %62 = getelementptr inbounds [20 x i8], [20 x i8]* %4, i32 0, i32 10
  %63 = getelementptr inbounds [17 x i8], [17 x i8]* @.str.12, i32 0, i32 %59
  %64 = load i8, i8* %63, align 1, !tbaa !17
  store i8 %64, i8* %58, align 1, !tbaa !17
  br label %21
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly %0, i8 %1, i32 %2, i1 immarg %3) #3

; Function Attrs: nounwind
define weak i8* @halide_type_to_string(i8* %0, i8* %1, %struct.halide_type_t* %2) local_unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.halide_type_t, %struct.halide_type_t* %2, i32 0, i32 0
  %5 = load i8, i8* %4, align 2, !tbaa !24
  %6 = icmp ult i8 %5, 4
  br i1 %6, label %switch.lookup, label %8

switch.lookup:                                    ; preds = %3
  %7 = sext i8 %5 to i32
  %switch.gep = getelementptr inbounds [4 x i8*], [4 x i8*]* @switch.table.halide_type_to_string, i32 0, i32 %7
  %switch.load = load i8*, i8** %switch.gep, align 4
  br label %8

8:                                                ; preds = %3, %switch.lookup
  %9 = phi i8* [ %switch.load, %switch.lookup ], [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.17, i32 0, i32 0), %3 ]
  %10 = tail call i8* @halide_string_to_string(i8* %0, i8* %1, i8* nonnull %9) #9
  %11 = getelementptr inbounds %struct.halide_type_t, %struct.halide_type_t* %2, i32 0, i32 1
  %12 = load i8, i8* %11, align 1, !tbaa !27
  %13 = zext i8 %12 to i64
  %14 = tail call i8* @halide_uint64_to_string(i8* %10, i8* %1, i64 %13, i32 1) #9
  %15 = getelementptr inbounds %struct.halide_type_t, %struct.halide_type_t* %2, i32 0, i32 2
  %16 = load i16, i16* %15, align 2, !tbaa !28
  %17 = icmp eq i16 %16, 1
  br i1 %17, label %23, label %18

18:                                               ; preds = %8
  %19 = tail call i8* @halide_string_to_string(i8* %14, i8* %1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.18, i32 0, i32 0)) #9
  %20 = load i16, i16* %15, align 2, !tbaa !28
  %21 = zext i16 %20 to i64
  %22 = tail call i8* @halide_uint64_to_string(i8* %19, i8* %1, i64 %21, i32 1) #9
  br label %23

23:                                               ; preds = %18, %8
  %24 = phi i8* [ %22, %18 ], [ %14, %8 ]
  ret i8* %24
}

; Function Attrs: nounwind
define weak i8* @halide_buffer_to_string(i8* %0, i8* %1, %struct.halide_buffer_t* %2) local_unnamed_addr #2 {
  %4 = icmp eq %struct.halide_buffer_t* %2, null
  br i1 %4, label %5, label %7

5:                                                ; preds = %3
  %6 = tail call i8* @halide_string_to_string(i8* %0, i8* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0)) #9
  br label %60

7:                                                ; preds = %3
  %8 = tail call i8* @halide_string_to_string(i8* %0, i8* %1, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.20, i32 0, i32 0)) #9
  %9 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %2, i32 0, i32 0
  %10 = load i64, i64* %9, align 8, !tbaa !29
  %11 = tail call i8* @halide_uint64_to_string(i8* %8, i8* %1, i64 %10, i32 1) #9
  %12 = tail call i8* @halide_string_to_string(i8* %11, i8* %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.55, i32 0, i32 0)) #9
  %13 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %2, i32 0, i32 1
  %14 = bitcast %struct.halide_device_interface_t** %13 to i8**
  %15 = load i8*, i8** %14, align 8, !tbaa !31
  %16 = tail call i8* @halide_pointer_to_string(i8* %12, i8* %1, i8* %15) #9
  %17 = tail call i8* @halide_string_to_string(i8* %16, i8* %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.55, i32 0, i32 0)) #9
  %18 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %2, i32 0, i32 2
  %19 = load i8*, i8** %18, align 4, !tbaa !32
  %20 = tail call i8* @halide_pointer_to_string(i8* %17, i8* %1, i8* %19) #9
  %21 = tail call i8* @halide_string_to_string(i8* %20, i8* %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.55, i32 0, i32 0)) #9
  %22 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %2, i32 0, i32 3
  %23 = load i64, i64* %22, align 8, !tbaa !33
  %24 = tail call i8* @halide_uint64_to_string(i8* %21, i8* %1, i64 %23, i32 1) #9
  %25 = tail call i8* @halide_string_to_string(i8* %24, i8* %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.55, i32 0, i32 0)) #9
  %26 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %2, i32 0, i32 4
  %27 = tail call i8* @halide_type_to_string(i8* %25, i8* %1, %struct.halide_type_t* nonnull %26) #9
  %28 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %2, i32 0, i32 5
  %29 = load i32, i32* %28, align 4, !tbaa !34
  %30 = icmp sgt i32 %29, 0
  br i1 %30, label %31, label %.loopexit

31:                                               ; preds = %7
  %32 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %2, i32 0, i32 6
  br label %35

.loopexit:                                        ; preds = %35, %7
  %33 = phi i8* [ %27, %7 ], [ %56, %35 ]
  %34 = tail call i8* @halide_string_to_string(i8* %33, i8* %1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8.45, i32 0, i32 0)) #9
  br label %60

35:                                               ; preds = %35, %31
  %36 = phi i32 [ 0, %31 ], [ %57, %35 ]
  %37 = phi i8* [ %27, %31 ], [ %56, %35 ]
  %38 = tail call i8* @halide_string_to_string(i8* %37, i8* %1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.22, i32 0, i32 0)) #9
  %39 = load %struct.halide_dimension_t*, %struct.halide_dimension_t** %32, align 8, !tbaa !35
  %40 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %39, i32 %36, i32 0
  %41 = load i32, i32* %40, align 4, !tbaa !36
  %42 = sext i32 %41 to i64
  %43 = tail call i8* @halide_int64_to_string(i8* %38, i8* %1, i64 %42, i32 1) #9
  %44 = tail call i8* @halide_string_to_string(i8* %43, i8* %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.55, i32 0, i32 0)) #9
  %45 = load %struct.halide_dimension_t*, %struct.halide_dimension_t** %32, align 8, !tbaa !35
  %46 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %45, i32 %36, i32 1
  %47 = load i32, i32* %46, align 4, !tbaa !38
  %48 = sext i32 %47 to i64
  %49 = tail call i8* @halide_int64_to_string(i8* %44, i8* %1, i64 %48, i32 1) #9
  %50 = tail call i8* @halide_string_to_string(i8* %49, i8* %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.55, i32 0, i32 0)) #9
  %51 = load %struct.halide_dimension_t*, %struct.halide_dimension_t** %32, align 8, !tbaa !35
  %52 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %51, i32 %36, i32 2
  %53 = load i32, i32* %52, align 4, !tbaa !39
  %54 = sext i32 %53 to i64
  %55 = tail call i8* @halide_int64_to_string(i8* %50, i8* %1, i64 %54, i32 1) #9
  %56 = tail call i8* @halide_string_to_string(i8* %55, i8* %1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.23, i32 0, i32 0)) #9
  %57 = add nuw nsw i32 %36, 1
  %58 = load i32, i32* %28, align 4, !tbaa !34
  %59 = icmp slt i32 %57, %58
  br i1 %59, label %35, label %.loopexit

60:                                               ; preds = %.loopexit, %5
  %61 = phi i8* [ %6, %5 ], [ %34, %.loopexit ]
  ret i8* %61
}

; Function Attrs: alwaysinline nounwind
define weak i32 @halide_malloc_alignment() local_unnamed_addr #0 {
  ret i32 128
}

; Function Attrs: nounwind
define weak i32 @halide_reuse_device_allocations(i8* %0, i1 zeroext %1) local_unnamed_addr #2 {
  %3 = zext i1 %1 to i8
  store i8 %3, i8* @_ZN6Halide7Runtime8Internal36halide_reuse_device_allocations_flagE, align 1, !tbaa !14
  br i1 %1, label %18, label %4

4:                                                ; preds = %2
  tail call void @halide_mutex_lock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal21allocation_pools_lockE) #8
  %5 = load %struct.halide_device_allocation_pool*, %struct.halide_device_allocation_pool** @_ZN6Halide7Runtime8Internal23device_allocation_poolsE, align 4, !tbaa !8
  %6 = icmp eq %struct.halide_device_allocation_pool* %5, null
  br i1 %6, label %.loopexit, label %.preheader

.loopexit:                                        ; preds = %.preheader, %4
  %7 = phi i32 [ 0, %4 ], [ %14, %.preheader ]
  tail call void @halide_mutex_unlock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal21allocation_pools_lockE) #8
  br label %18

.preheader:                                       ; preds = %4, %.preheader
  %8 = phi %struct.halide_device_allocation_pool* [ %16, %.preheader ], [ %5, %4 ]
  %9 = phi i32 [ %14, %.preheader ], [ 0, %4 ]
  %10 = getelementptr inbounds %struct.halide_device_allocation_pool, %struct.halide_device_allocation_pool* %8, i32 0, i32 0
  %11 = load i32 (i8*)*, i32 (i8*)** %10, align 4, !tbaa !40
  %12 = tail call i32 %11(i8* %0) #10
  %13 = icmp eq i32 %12, 0
  %14 = select i1 %13, i32 %9, i32 %12
  %15 = getelementptr inbounds %struct.halide_device_allocation_pool, %struct.halide_device_allocation_pool* %8, i32 0, i32 1
  %16 = load %struct.halide_device_allocation_pool*, %struct.halide_device_allocation_pool** %15, align 4, !tbaa !8
  %17 = icmp eq %struct.halide_device_allocation_pool* %16, null
  br i1 %17, label %.loopexit, label %.preheader

18:                                               ; preds = %.loopexit, %2
  %19 = phi i32 [ 0, %2 ], [ %7, %.loopexit ]
  ret i32 %19
}

; Function Attrs: nounwind
define weak zeroext i1 @halide_can_reuse_device_allocations(i8* %0) local_unnamed_addr #2 {
  %2 = load i8, i8* @_ZN6Halide7Runtime8Internal36halide_reuse_device_allocations_flagE, align 1, !tbaa !14, !range !16
  %3 = icmp ne i8 %2, 0
  ret i1 %3
}

; Function Attrs: nounwind
define weak void @halide_register_device_allocation_pool(%struct.halide_device_allocation_pool* %0) local_unnamed_addr #2 {
  tail call void @halide_mutex_lock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal21allocation_pools_lockE) #8
  %2 = load i32, i32* bitcast (%struct.halide_device_allocation_pool** @_ZN6Halide7Runtime8Internal23device_allocation_poolsE to i32*), align 4, !tbaa !8
  %3 = getelementptr inbounds %struct.halide_device_allocation_pool, %struct.halide_device_allocation_pool* %0, i32 0, i32 1
  %4 = bitcast %struct.halide_device_allocation_pool** %3 to i32*
  store i32 %2, i32* %4, align 4, !tbaa !42
  store %struct.halide_device_allocation_pool* %0, %struct.halide_device_allocation_pool** @_ZN6Halide7Runtime8Internal23device_allocation_poolsE, align 4, !tbaa !8
  tail call void @halide_mutex_unlock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal21allocation_pools_lockE) #8
  ret void
}

; Function Attrs: nounwind
define linkonce void @_ZN6Halide7Runtime8Internal18copy_memory_helperERKNS1_11device_copyEixx(%"struct.Halide::Runtime::Internal::device_copy"* dereferenceable(416) %0, i32 %1, i64 %2, i64 %3) local_unnamed_addr #2 {
  %5 = icmp sgt i32 %1, -1
  br i1 %5, label %.preheader, label %.loopexit2

.preheader:                                       ; preds = %4, %10
  %6 = phi i32 [ %11, %10 ], [ %1, %4 ]
  %7 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %0, i32 0, i32 3, i32 %6
  %8 = load i64, i64* %7, align 8, !tbaa !20
  %9 = icmp eq i64 %8, 1
  br i1 %9, label %10, label %.loopexit2

10:                                               ; preds = %.preheader
  %11 = add nsw i32 %6, -1
  %12 = icmp sgt i32 %6, 0
  br i1 %12, label %.preheader, label %.loopexit2

.loopexit2:                                       ; preds = %10, %.preheader, %4
  %13 = phi i32 [ %1, %4 ], [ %6, %.preheader ], [ %11, %10 ]
  %14 = icmp eq i32 %13, -1
  br i1 %14, label %23, label %15

15:                                               ; preds = %.loopexit2
  %16 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %0, i32 0, i32 3, i32 %13
  %17 = load i64, i64* %16, align 8, !tbaa !20
  %18 = icmp eq i64 %17, 0
  br i1 %18, label %.loopexit, label %19

19:                                               ; preds = %15
  %20 = add nsw i32 %13, -1
  %21 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %0, i32 0, i32 4, i32 %13
  %22 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %0, i32 0, i32 5, i32 %13
  %.0 = add nuw i64 0, 1
  br label %38

23:                                               ; preds = %.loopexit2
  %24 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %0, i32 0, i32 0
  %25 = load i64, i64* %24, align 8, !tbaa !43
  %26 = add i64 %25, %2
  %27 = trunc i64 %26 to i32
  %28 = inttoptr i32 %27 to i8*
  %29 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %0, i32 0, i32 1
  %30 = load i64, i64* %29, align 8, !tbaa !45
  %31 = add i64 %30, %3
  %32 = trunc i64 %31 to i32
  %33 = inttoptr i32 %32 to i8*
  %34 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %0, i32 0, i32 6
  %35 = load i64, i64* %34, align 8, !tbaa !46
  %36 = trunc i64 %35 to i32
  %37 = tail call i8* @memcpy(i8* %33, i8* %28, i32 %36) #8
  br label %.loopexit

38:                                               ; preds = %._crit_edge, %19
  %.phi = phi i64 [ %.0, %19 ], [ %.1, %._crit_edge ]
  %39 = phi i64 [ %2, %19 ], [ %42, %._crit_edge ]
  %40 = phi i64 [ %3, %19 ], [ %44, %._crit_edge ]
  tail call void @_ZN6Halide7Runtime8Internal18copy_memory_helperERKNS1_11device_copyEixx(%"struct.Halide::Runtime::Internal::device_copy"* nonnull dereferenceable(416) %0, i32 %20, i64 %39, i64 %40) #9
  %41 = load i64, i64* %21, align 8, !tbaa !20
  %42 = add i64 %41, %39
  %43 = load i64, i64* %22, align 8, !tbaa !20
  %44 = add i64 %43, %40
  %45 = load i64, i64* %16, align 8, !tbaa !20
  %46 = icmp ult i64 %.phi, %45
  br i1 %46, label %._crit_edge, label %.loopexit

._crit_edge:                                      ; preds = %38
  %.1 = add nuw i64 %.phi, 1
  br label %38

.loopexit:                                        ; preds = %38, %23, %15
  ret void
}

; Function Attrs: nounwind
define linkonce void @_ZN6Halide7Runtime8Internal11copy_memoryERKNS1_11device_copyEPv(%"struct.Halide::Runtime::Internal::device_copy"* dereferenceable(416) %0, i8* %1) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %0, i32 0, i32 0
  %4 = load i64, i64* %3, align 8, !tbaa !43
  %5 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %0, i32 0, i32 1
  %6 = load i64, i64* %5, align 8, !tbaa !45
  %7 = icmp eq i64 %4, %6
  br i1 %7, label %11, label %8

8:                                                ; preds = %2
  %9 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %0, i32 0, i32 2
  %10 = load i64, i64* %9, align 8, !tbaa !47
  tail call void @_ZN6Halide7Runtime8Internal18copy_memory_helperERKNS1_11device_copyEixx(%"struct.Halide::Runtime::Internal::device_copy"* nonnull dereferenceable(416) %0, i32 15, i64 %10, i64 0) #9
  br label %11

11:                                               ; preds = %8, %2
  ret void
}

; Function Attrs: nounwind
define linkonce void @_ZN6Halide7Runtime8Internal16make_buffer_copyEPK15halide_buffer_tbS4_b(%"struct.Halide::Runtime::Internal::device_copy"* noalias sret %0, %struct.halide_buffer_t* %1, i1 zeroext %2, %struct.halide_buffer_t* %3, i1 zeroext %4) local_unnamed_addr #2 {
  %6 = alloca %"struct.Halide::Runtime::Internal::device_copy", align 8
  %7 = bitcast %"struct.Halide::Runtime::Internal::device_copy"* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 416, i8* nonnull %7) #6
  br i1 %2, label %8, label %13

8:                                                ; preds = %5
  %9 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 2
  %10 = bitcast i8** %9 to i32*
  %11 = load i32, i32* %10, align 4, !tbaa !32
  %12 = zext i32 %11 to i64
  br label %16

13:                                               ; preds = %5
  %14 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %15 = load i64, i64* %14, align 8, !tbaa !29
  br label %16

16:                                               ; preds = %13, %8
  %17 = phi i64 [ %12, %8 ], [ %15, %13 ]
  %18 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 0
  store i64 %17, i64* %18, align 8, !tbaa !43
  br i1 %4, label %19, label %24

19:                                               ; preds = %16
  %20 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %3, i32 0, i32 2
  %21 = bitcast i8** %20 to i32*
  %22 = load i32, i32* %21, align 4, !tbaa !32
  %23 = zext i32 %22 to i64
  br label %27

24:                                               ; preds = %16
  %25 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %3, i32 0, i32 0
  %26 = load i64, i64* %25, align 8, !tbaa !29
  br label %27

27:                                               ; preds = %24, %19
  %28 = phi i64 [ %23, %19 ], [ %26, %24 ]
  %29 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 1
  store i64 %28, i64* %29, align 8, !tbaa !45
  %30 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 4, i32 1
  %31 = load i8, i8* %30, align 1, !tbaa !27
  %32 = zext i8 %31 to i32
  %33 = add nuw nsw i32 %32, 7
  %34 = lshr i32 %33, 3
  %35 = zext i32 %34 to i64
  %36 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 6
  store i64 %35, i64* %36, align 8, !tbaa !46
  %37 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 0
  store i64 1, i64* %37, align 8, !tbaa !20
  %38 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 0
  store i64 0, i64* %38, align 8, !tbaa !20
  %39 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 0
  store i64 0, i64* %39, align 8, !tbaa !20
  %40 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 1
  store i64 1, i64* %40, align 8, !tbaa !20
  %41 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 1
  store i64 0, i64* %41, align 8, !tbaa !20
  %42 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 1
  store i64 0, i64* %42, align 8, !tbaa !20
  %43 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 2
  store i64 1, i64* %43, align 8, !tbaa !20
  %44 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 2
  store i64 0, i64* %44, align 8, !tbaa !20
  %45 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 2
  store i64 0, i64* %45, align 8, !tbaa !20
  %46 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 3
  store i64 1, i64* %46, align 8, !tbaa !20
  %47 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 3
  store i64 0, i64* %47, align 8, !tbaa !20
  %48 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 3
  store i64 0, i64* %48, align 8, !tbaa !20
  %49 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 4
  store i64 1, i64* %49, align 8, !tbaa !20
  %50 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 4
  store i64 0, i64* %50, align 8, !tbaa !20
  %51 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 4
  store i64 0, i64* %51, align 8, !tbaa !20
  %52 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 5
  store i64 1, i64* %52, align 8, !tbaa !20
  %53 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 5
  store i64 0, i64* %53, align 8, !tbaa !20
  %54 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 5
  store i64 0, i64* %54, align 8, !tbaa !20
  %55 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 6
  store i64 1, i64* %55, align 8, !tbaa !20
  %56 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 6
  store i64 0, i64* %56, align 8, !tbaa !20
  %57 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 6
  store i64 0, i64* %57, align 8, !tbaa !20
  %58 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 7
  store i64 1, i64* %58, align 8, !tbaa !20
  %59 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 7
  store i64 0, i64* %59, align 8, !tbaa !20
  %60 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 7
  store i64 0, i64* %60, align 8, !tbaa !20
  %61 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 8
  store i64 1, i64* %61, align 8, !tbaa !20
  %62 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 8
  store i64 0, i64* %62, align 8, !tbaa !20
  %63 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 8
  store i64 0, i64* %63, align 8, !tbaa !20
  %64 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 9
  store i64 1, i64* %64, align 8, !tbaa !20
  %65 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 9
  store i64 0, i64* %65, align 8, !tbaa !20
  %66 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 9
  store i64 0, i64* %66, align 8, !tbaa !20
  %67 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 10
  store i64 1, i64* %67, align 8, !tbaa !20
  %68 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 10
  store i64 0, i64* %68, align 8, !tbaa !20
  %69 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 10
  store i64 0, i64* %69, align 8, !tbaa !20
  %70 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 11
  store i64 1, i64* %70, align 8, !tbaa !20
  %71 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 11
  store i64 0, i64* %71, align 8, !tbaa !20
  %72 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 11
  store i64 0, i64* %72, align 8, !tbaa !20
  %73 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 12
  store i64 1, i64* %73, align 8, !tbaa !20
  %74 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 12
  store i64 0, i64* %74, align 8, !tbaa !20
  %75 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 12
  store i64 0, i64* %75, align 8, !tbaa !20
  %76 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 13
  store i64 1, i64* %76, align 8, !tbaa !20
  %77 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 13
  store i64 0, i64* %77, align 8, !tbaa !20
  %78 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 13
  store i64 0, i64* %78, align 8, !tbaa !20
  %79 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 14
  store i64 1, i64* %79, align 8, !tbaa !20
  %80 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 14
  store i64 0, i64* %80, align 8, !tbaa !20
  %81 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 14
  store i64 0, i64* %81, align 8, !tbaa !20
  %82 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 15
  store i64 1, i64* %82, align 8, !tbaa !20
  %83 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 15
  store i64 0, i64* %83, align 8, !tbaa !20
  %84 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 15
  store i64 0, i64* %84, align 8, !tbaa !20
  %85 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 2
  store i64 0, i64* %85, align 8, !tbaa !47
  %86 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 5
  %87 = load i32, i32* %86, align 4, !tbaa !34
  %88 = icmp sgt i32 %87, 0
  br i1 %88, label %89, label %109

89:                                               ; preds = %27
  %90 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 6
  %91 = load %struct.halide_dimension_t*, %struct.halide_dimension_t** %90, align 8, !tbaa !35
  %92 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %3, i32 0, i32 6
  %93 = load %struct.halide_dimension_t*, %struct.halide_dimension_t** %92, align 8, !tbaa !35
  %94 = add i32 %87, -1
  %xtraiter = and i32 %87, 7
  %95 = icmp ult i32 %94, 7
  br i1 %95, label %.unr-lcssa, label %.new

.new:                                             ; preds = %89
  %unroll_iter = sub i32 %87, %xtraiter
  br label %116

.unr-lcssa:                                       ; preds = %116, %89
  %.lcssa.ph = phi i64 [ undef, %89 ], [ %205, %116 ]
  %.unr = phi i64 [ 0, %89 ], [ %205, %116 ]
  %.unr14 = phi i32 [ 0, %89 ], [ %206, %116 ]
  %lcmp.mod = icmp eq i32 %xtraiter, 0
  br i1 %lcmp.mod, label %.epilog-lcssa, label %.epil.preheader

.epil.preheader:                                  ; preds = %.unr-lcssa, %.epil.preheader
  %96 = phi i64 [ %107, %.epil.preheader ], [ %.unr, %.unr-lcssa ]
  %97 = phi i32 [ %108, %.epil.preheader ], [ %.unr14, %.unr-lcssa ]
  %epil.iter = phi i32 [ %epil.iter.sub, %.epil.preheader ], [ %xtraiter, %.unr-lcssa ]
  %98 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %97, i32 2
  %99 = load i32, i32* %98, align 4, !tbaa !39
  %100 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %93, i32 %97, i32 0
  %101 = load i32, i32* %100, align 4, !tbaa !36
  %102 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %97, i32 0
  %103 = load i32, i32* %102, align 4, !tbaa !36
  %104 = sub nsw i32 %101, %103
  %105 = mul nsw i32 %104, %99
  %106 = sext i32 %105 to i64
  %107 = add i64 %96, %106
  %108 = add nuw nsw i32 %97, 1
  %epil.iter.sub = add i32 %epil.iter, -1
  %epil.iter.cmp = icmp eq i32 %epil.iter.sub, 0
  br i1 %epil.iter.cmp, label %.epilog-lcssa, label %.epil.preheader, !llvm.loop !48

.epilog-lcssa:                                    ; preds = %.epil.preheader, %.unr-lcssa
  %.lcssa = phi i64 [ %.lcssa.ph, %.unr-lcssa ], [ %107, %.epil.preheader ]
  store i64 %.lcssa, i64* %85, align 8, !tbaa !47
  br label %109

109:                                              ; preds = %.epilog-lcssa, %27
  %110 = phi i64 [ %.lcssa, %.epilog-lcssa ], [ 0, %27 ]
  %111 = load i64, i64* %36, align 8, !tbaa !46
  %112 = mul i64 %111, %110
  store i64 %112, i64* %85, align 8, !tbaa !47
  %113 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %3, i32 0, i32 5
  %114 = load i32, i32* %113, align 4, !tbaa !34
  %115 = icmp eq i32 %87, %114
  br i1 %115, label %207, label %216

116:                                              ; preds = %116, %.new
  %117 = phi i64 [ 0, %.new ], [ %205, %116 ]
  %118 = phi i32 [ 0, %.new ], [ %206, %116 ]
  %niter = phi i32 [ %unroll_iter, %.new ], [ %niter.nsub.7, %116 ]
  %119 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %118, i32 2
  %120 = load i32, i32* %119, align 4, !tbaa !39
  %121 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %93, i32 %118, i32 0
  %122 = load i32, i32* %121, align 4, !tbaa !36
  %123 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %118, i32 0
  %124 = load i32, i32* %123, align 4, !tbaa !36
  %125 = sub nsw i32 %122, %124
  %126 = mul nsw i32 %125, %120
  %127 = sext i32 %126 to i64
  %128 = add i64 %117, %127
  %129 = or i32 %118, 1
  %130 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %129, i32 2
  %131 = load i32, i32* %130, align 4, !tbaa !39
  %132 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %93, i32 %129, i32 0
  %133 = load i32, i32* %132, align 4, !tbaa !36
  %134 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %129, i32 0
  %135 = load i32, i32* %134, align 4, !tbaa !36
  %136 = sub nsw i32 %133, %135
  %137 = mul nsw i32 %136, %131
  %138 = sext i32 %137 to i64
  %139 = add i64 %128, %138
  %140 = or i32 %118, 2
  %141 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %140, i32 2
  %142 = load i32, i32* %141, align 4, !tbaa !39
  %143 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %93, i32 %140, i32 0
  %144 = load i32, i32* %143, align 4, !tbaa !36
  %145 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %140, i32 0
  %146 = load i32, i32* %145, align 4, !tbaa !36
  %147 = sub nsw i32 %144, %146
  %148 = mul nsw i32 %147, %142
  %149 = sext i32 %148 to i64
  %150 = add i64 %139, %149
  %151 = or i32 %118, 3
  %152 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %151, i32 2
  %153 = load i32, i32* %152, align 4, !tbaa !39
  %154 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %93, i32 %151, i32 0
  %155 = load i32, i32* %154, align 4, !tbaa !36
  %156 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %151, i32 0
  %157 = load i32, i32* %156, align 4, !tbaa !36
  %158 = sub nsw i32 %155, %157
  %159 = mul nsw i32 %158, %153
  %160 = sext i32 %159 to i64
  %161 = add i64 %150, %160
  %162 = or i32 %118, 4
  %163 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %162, i32 2
  %164 = load i32, i32* %163, align 4, !tbaa !39
  %165 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %93, i32 %162, i32 0
  %166 = load i32, i32* %165, align 4, !tbaa !36
  %167 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %162, i32 0
  %168 = load i32, i32* %167, align 4, !tbaa !36
  %169 = sub nsw i32 %166, %168
  %170 = mul nsw i32 %169, %164
  %171 = sext i32 %170 to i64
  %172 = add i64 %161, %171
  %173 = or i32 %118, 5
  %174 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %173, i32 2
  %175 = load i32, i32* %174, align 4, !tbaa !39
  %176 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %93, i32 %173, i32 0
  %177 = load i32, i32* %176, align 4, !tbaa !36
  %178 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %173, i32 0
  %179 = load i32, i32* %178, align 4, !tbaa !36
  %180 = sub nsw i32 %177, %179
  %181 = mul nsw i32 %180, %175
  %182 = sext i32 %181 to i64
  %183 = add i64 %172, %182
  %184 = or i32 %118, 6
  %185 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %184, i32 2
  %186 = load i32, i32* %185, align 4, !tbaa !39
  %187 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %93, i32 %184, i32 0
  %188 = load i32, i32* %187, align 4, !tbaa !36
  %189 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %184, i32 0
  %190 = load i32, i32* %189, align 4, !tbaa !36
  %191 = sub nsw i32 %188, %190
  %192 = mul nsw i32 %191, %186
  %193 = sext i32 %192 to i64
  %194 = add i64 %183, %193
  %195 = or i32 %118, 7
  %196 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %195, i32 2
  %197 = load i32, i32* %196, align 4, !tbaa !39
  %198 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %93, i32 %195, i32 0
  %199 = load i32, i32* %198, align 4, !tbaa !36
  %200 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %91, i32 %195, i32 0
  %201 = load i32, i32* %200, align 4, !tbaa !36
  %202 = sub nsw i32 %199, %201
  %203 = mul nsw i32 %202, %197
  %204 = sext i32 %203 to i64
  %205 = add i64 %194, %204
  %206 = add nuw nsw i32 %118, 8
  %niter.nsub.7 = add i32 %niter, -8
  %niter.ncmp.7 = icmp eq i32 %niter.nsub.7, 0
  br i1 %niter.ncmp.7, label %.unr-lcssa, label %116

207:                                              ; preds = %109
  %208 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %3, i32 0, i32 4, i32 1
  %209 = load i8, i8* %208, align 1, !tbaa !27
  %210 = zext i8 %209 to i32
  %211 = add nuw nsw i32 %210, 7
  %212 = lshr i32 %211, 3
  %213 = icmp ne i32 %34, %212
  %214 = icmp sgt i32 %87, 16
  %215 = or i1 %214, %213
  br i1 %215, label %216, label %218

216:                                              ; preds = %207, %109
  %217 = bitcast %"struct.Halide::Runtime::Internal::device_copy"* %0 to i8*
  tail call void @llvm.memset.p0i8.i32(i8* nonnull align 8 dereferenceable(416) %217, i8 0, i32 416, i1 false)
  br label %413

218:                                              ; preds = %207
  %219 = icmp eq i64 %111, 0
  br i1 %219, label %226, label %220

220:                                              ; preds = %218
  br i1 %88, label %221, label %.loopexit

221:                                              ; preds = %220
  %222 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %3, i32 0, i32 6
  %223 = load %struct.halide_dimension_t*, %struct.halide_dimension_t** %222, align 8, !tbaa !35
  %224 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 6
  %225 = load %struct.halide_dimension_t*, %struct.halide_dimension_t** %224, align 8, !tbaa !35
  br label %234

226:                                              ; preds = %218
  %227 = bitcast %"struct.Halide::Runtime::Internal::device_copy"* %0 to i8*
  tail call void @llvm.memset.p0i8.i32(i8* nonnull align 8 dereferenceable(416) %227, i8 0, i32 416, i1 false)
  br label %413

228:                                              ; preds = %.loopexit9
  %229 = load i64, i64* %36, align 8, !tbaa !46
  %230 = load i64, i64* %38, align 8, !tbaa !20
  %231 = icmp eq i64 %229, %230
  br i1 %231, label %232, label %.loopexit

232:                                              ; preds = %228
  %233 = load i64, i64* %39, align 8, !tbaa !20
  br label %359

234:                                              ; preds = %.loopexit9, %221
  %235 = phi i32 [ 0, %221 ], [ %276, %.loopexit9 ]
  %236 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %223, i32 %235, i32 2
  %237 = load i32, i32* %236, align 4, !tbaa !39
  %238 = mul nsw i32 %237, %34
  %239 = sext i32 %238 to i64
  %240 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %225, i32 %235, i32 2
  %241 = load i32, i32* %240, align 4, !tbaa !39
  %242 = mul nsw i32 %241, %34
  %243 = sext i32 %242 to i64
  %244 = icmp eq i32 %235, 0
  br i1 %244, label %.loopexit11, label %245

245:                                              ; preds = %234
  %246 = icmp eq i32 %238, 0
  br i1 %246, label %.loopexit11, label %.preheader10

.preheader10:                                     ; preds = %245, %251
  %247 = phi i32 [ %252, %251 ], [ 0, %245 ]
  %248 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %247
  %249 = load i64, i64* %248, align 8, !tbaa !20
  %250 = icmp ugt i64 %249, %239
  br i1 %250, label %.loopexit11, label %251

251:                                              ; preds = %.preheader10
  %252 = add nuw nsw i32 %247, 1
  %exitcond12 = icmp eq i32 %252, %235
  br i1 %exitcond12, label %.loopexit11, label %.preheader10

.loopexit11:                                      ; preds = %.preheader10, %251, %245, %234
  %253 = phi i32 [ 0, %234 ], [ %235, %245 ], [ %235, %251 ], [ %247, %.preheader10 ]
  %254 = icmp ugt i32 %235, %253
  br i1 %254, label %.preheader.preheader, label %.loopexit9

.preheader.preheader:                             ; preds = %.loopexit11
  %255 = sub i32 %235, %253
  %256 = xor i32 %253, -1
  %257 = add i32 %235, %256
  %xtraiter16 = and i32 %255, 7
  %lcmp.mod17 = icmp eq i32 %xtraiter16, 0
  br i1 %lcmp.mod17, label %.preheader.prol.loopexit, label %.preheader.prol

.preheader.prol:                                  ; preds = %.preheader.preheader, %.preheader.prol
  %258 = phi i32 [ %259, %.preheader.prol ], [ %235, %.preheader.preheader ]
  %prol.iter = phi i32 [ %prol.iter.sub, %.preheader.prol ], [ %xtraiter16, %.preheader.preheader ]
  %259 = add nsw i32 %258, -1
  %260 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %259
  %261 = load i64, i64* %260, align 8, !tbaa !20
  %262 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %258
  store i64 %261, i64* %262, align 8, !tbaa !20
  %263 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %259
  %264 = load i64, i64* %263, align 8, !tbaa !20
  %265 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %258
  store i64 %264, i64* %265, align 8, !tbaa !20
  %266 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %259
  %267 = load i64, i64* %266, align 8, !tbaa !20
  %268 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %258
  store i64 %267, i64* %268, align 8, !tbaa !20
  %prol.iter.sub = add i32 %prol.iter, -1
  %prol.iter.cmp = icmp eq i32 %prol.iter.sub, 0
  br i1 %prol.iter.cmp, label %.preheader.prol.loopexit, label %.preheader.prol, !llvm.loop !49

.preheader.prol.loopexit:                         ; preds = %.preheader.prol, %.preheader.preheader
  %.unr18 = phi i32 [ %235, %.preheader.preheader ], [ %259, %.preheader.prol ]
  %269 = icmp ult i32 %257, 7
  br i1 %269, label %.loopexit9, label %.preheader

.loopexit9:                                       ; preds = %.preheader.prol.loopexit, %.preheader, %.loopexit11
  %270 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %223, i32 %235, i32 1
  %271 = load i32, i32* %270, align 4, !tbaa !38
  %272 = sext i32 %271 to i64
  %273 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %253
  store i64 %272, i64* %273, align 8, !tbaa !20
  %274 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %253
  store i64 %239, i64* %274, align 8, !tbaa !20
  %275 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %253
  store i64 %243, i64* %275, align 8, !tbaa !20
  %276 = add nuw nsw i32 %235, 1
  %exitcond13 = icmp eq i32 %276, %87
  br i1 %exitcond13, label %228, label %234

.preheader:                                       ; preds = %.preheader.prol.loopexit, %.preheader
  %277 = phi i32 [ %348, %.preheader ], [ %.unr18, %.preheader.prol.loopexit ]
  %278 = add nsw i32 %277, -1
  %279 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %278
  %280 = load i64, i64* %279, align 8, !tbaa !20
  %281 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %277
  store i64 %280, i64* %281, align 8, !tbaa !20
  %282 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %278
  %283 = load i64, i64* %282, align 8, !tbaa !20
  %284 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %277
  store i64 %283, i64* %284, align 8, !tbaa !20
  %285 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %278
  %286 = load i64, i64* %285, align 8, !tbaa !20
  %287 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %277
  store i64 %286, i64* %287, align 8, !tbaa !20
  %288 = add nsw i32 %277, -2
  %289 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %288
  %290 = load i64, i64* %289, align 8, !tbaa !20
  %291 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %278
  store i64 %290, i64* %291, align 8, !tbaa !20
  %292 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %288
  %293 = load i64, i64* %292, align 8, !tbaa !20
  %294 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %278
  store i64 %293, i64* %294, align 8, !tbaa !20
  %295 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %288
  %296 = load i64, i64* %295, align 8, !tbaa !20
  %297 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %278
  store i64 %296, i64* %297, align 8, !tbaa !20
  %298 = add nsw i32 %277, -3
  %299 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %298
  %300 = load i64, i64* %299, align 8, !tbaa !20
  %301 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %288
  store i64 %300, i64* %301, align 8, !tbaa !20
  %302 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %298
  %303 = load i64, i64* %302, align 8, !tbaa !20
  %304 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %288
  store i64 %303, i64* %304, align 8, !tbaa !20
  %305 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %298
  %306 = load i64, i64* %305, align 8, !tbaa !20
  %307 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %288
  store i64 %306, i64* %307, align 8, !tbaa !20
  %308 = add nsw i32 %277, -4
  %309 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %308
  %310 = load i64, i64* %309, align 8, !tbaa !20
  %311 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %298
  store i64 %310, i64* %311, align 8, !tbaa !20
  %312 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %308
  %313 = load i64, i64* %312, align 8, !tbaa !20
  %314 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %298
  store i64 %313, i64* %314, align 8, !tbaa !20
  %315 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %308
  %316 = load i64, i64* %315, align 8, !tbaa !20
  %317 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %298
  store i64 %316, i64* %317, align 8, !tbaa !20
  %318 = add nsw i32 %277, -5
  %319 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %318
  %320 = load i64, i64* %319, align 8, !tbaa !20
  %321 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %308
  store i64 %320, i64* %321, align 8, !tbaa !20
  %322 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %318
  %323 = load i64, i64* %322, align 8, !tbaa !20
  %324 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %308
  store i64 %323, i64* %324, align 8, !tbaa !20
  %325 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %318
  %326 = load i64, i64* %325, align 8, !tbaa !20
  %327 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %308
  store i64 %326, i64* %327, align 8, !tbaa !20
  %328 = add nsw i32 %277, -6
  %329 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %328
  %330 = load i64, i64* %329, align 8, !tbaa !20
  %331 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %318
  store i64 %330, i64* %331, align 8, !tbaa !20
  %332 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %328
  %333 = load i64, i64* %332, align 8, !tbaa !20
  %334 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %318
  store i64 %333, i64* %334, align 8, !tbaa !20
  %335 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %328
  %336 = load i64, i64* %335, align 8, !tbaa !20
  %337 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %318
  store i64 %336, i64* %337, align 8, !tbaa !20
  %338 = add nsw i32 %277, -7
  %339 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %338
  %340 = load i64, i64* %339, align 8, !tbaa !20
  %341 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %328
  store i64 %340, i64* %341, align 8, !tbaa !20
  %342 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %338
  %343 = load i64, i64* %342, align 8, !tbaa !20
  %344 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %328
  store i64 %343, i64* %344, align 8, !tbaa !20
  %345 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %338
  %346 = load i64, i64* %345, align 8, !tbaa !20
  %347 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %328
  store i64 %346, i64* %347, align 8, !tbaa !20
  %348 = add nsw i32 %277, -8
  %349 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %348
  %350 = load i64, i64* %349, align 8, !tbaa !20
  %351 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 3, i32 %338
  store i64 %350, i64* %351, align 8, !tbaa !20
  %352 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %348
  %353 = load i64, i64* %352, align 8, !tbaa !20
  %354 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 5, i32 %338
  store i64 %353, i64* %354, align 8, !tbaa !20
  %355 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %348
  %356 = load i64, i64* %355, align 8, !tbaa !20
  %357 = getelementptr inbounds %"struct.Halide::Runtime::Internal::device_copy", %"struct.Halide::Runtime::Internal::device_copy"* %6, i32 0, i32 4, i32 %338
  store i64 %356, i64* %357, align 8, !tbaa !20
  %358 = icmp sgt i32 %348, %253
  br i1 %358, label %.preheader, label %.loopexit9

359:                                              ; preds = %363, %232
  %360 = phi i64 [ %233, %232 ], [ %368, %363 ]
  %361 = phi i64 [ %229, %232 ], [ %365, %363 ]
  %362 = icmp eq i64 %361, %360
  br i1 %362, label %363, label %.loopexit

363:                                              ; preds = %359
  %364 = load i64, i64* %37, align 8, !tbaa !20
  %365 = mul i64 %364, %360
  store i64 %365, i64* %36, align 8, !tbaa !46
  %366 = load i64, i64* %40, align 8, !tbaa !20
  store i64 %366, i64* %37, align 8, !tbaa !20
  %367 = load i64, i64* %41, align 8, !tbaa !20
  store i64 %367, i64* %38, align 8, !tbaa !20
  %368 = load i64, i64* %42, align 8, !tbaa !20
  store i64 %368, i64* %39, align 8, !tbaa !20
  %369 = load i64, i64* %43, align 8, !tbaa !20
  store i64 %369, i64* %40, align 8, !tbaa !20
  %370 = load i64, i64* %44, align 8, !tbaa !20
  store i64 %370, i64* %41, align 8, !tbaa !20
  %371 = load i64, i64* %45, align 8, !tbaa !20
  store i64 %371, i64* %42, align 8, !tbaa !20
  %372 = load i64, i64* %46, align 8, !tbaa !20
  store i64 %372, i64* %43, align 8, !tbaa !20
  %373 = load i64, i64* %47, align 8, !tbaa !20
  store i64 %373, i64* %44, align 8, !tbaa !20
  %374 = load i64, i64* %48, align 8, !tbaa !20
  store i64 %374, i64* %45, align 8, !tbaa !20
  %375 = load i64, i64* %49, align 8, !tbaa !20
  store i64 %375, i64* %46, align 8, !tbaa !20
  %376 = load i64, i64* %50, align 8, !tbaa !20
  store i64 %376, i64* %47, align 8, !tbaa !20
  %377 = load i64, i64* %51, align 8, !tbaa !20
  store i64 %377, i64* %48, align 8, !tbaa !20
  %378 = load i64, i64* %52, align 8, !tbaa !20
  store i64 %378, i64* %49, align 8, !tbaa !20
  %379 = load i64, i64* %53, align 8, !tbaa !20
  store i64 %379, i64* %50, align 8, !tbaa !20
  %380 = load i64, i64* %54, align 8, !tbaa !20
  store i64 %380, i64* %51, align 8, !tbaa !20
  %381 = load i64, i64* %55, align 8, !tbaa !20
  store i64 %381, i64* %52, align 8, !tbaa !20
  %382 = load i64, i64* %56, align 8, !tbaa !20
  store i64 %382, i64* %53, align 8, !tbaa !20
  %383 = load i64, i64* %57, align 8, !tbaa !20
  store i64 %383, i64* %54, align 8, !tbaa !20
  %384 = load i64, i64* %58, align 8, !tbaa !20
  store i64 %384, i64* %55, align 8, !tbaa !20
  %385 = load i64, i64* %59, align 8, !tbaa !20
  store i64 %385, i64* %56, align 8, !tbaa !20
  %386 = load i64, i64* %60, align 8, !tbaa !20
  store i64 %386, i64* %57, align 8, !tbaa !20
  %387 = load i64, i64* %61, align 8, !tbaa !20
  store i64 %387, i64* %58, align 8, !tbaa !20
  %388 = load i64, i64* %62, align 8, !tbaa !20
  store i64 %388, i64* %59, align 8, !tbaa !20
  %389 = load i64, i64* %63, align 8, !tbaa !20
  store i64 %389, i64* %60, align 8, !tbaa !20
  %390 = load i64, i64* %64, align 8, !tbaa !20
  store i64 %390, i64* %61, align 8, !tbaa !20
  %391 = load i64, i64* %65, align 8, !tbaa !20
  store i64 %391, i64* %62, align 8, !tbaa !20
  %392 = load i64, i64* %66, align 8, !tbaa !20
  store i64 %392, i64* %63, align 8, !tbaa !20
  %393 = load i64, i64* %67, align 8, !tbaa !20
  store i64 %393, i64* %64, align 8, !tbaa !20
  %394 = load i64, i64* %68, align 8, !tbaa !20
  store i64 %394, i64* %65, align 8, !tbaa !20
  %395 = load i64, i64* %69, align 8, !tbaa !20
  store i64 %395, i64* %66, align 8, !tbaa !20
  %396 = load i64, i64* %70, align 8, !tbaa !20
  store i64 %396, i64* %67, align 8, !tbaa !20
  %397 = load i64, i64* %71, align 8, !tbaa !20
  store i64 %397, i64* %68, align 8, !tbaa !20
  %398 = load i64, i64* %72, align 8, !tbaa !20
  store i64 %398, i64* %69, align 8, !tbaa !20
  %399 = load i64, i64* %73, align 8, !tbaa !20
  store i64 %399, i64* %70, align 8, !tbaa !20
  %400 = load i64, i64* %74, align 8, !tbaa !20
  store i64 %400, i64* %71, align 8, !tbaa !20
  %401 = load i64, i64* %75, align 8, !tbaa !20
  store i64 %401, i64* %72, align 8, !tbaa !20
  %402 = load i64, i64* %76, align 8, !tbaa !20
  store i64 %402, i64* %73, align 8, !tbaa !20
  %403 = load i64, i64* %77, align 8, !tbaa !20
  store i64 %403, i64* %74, align 8, !tbaa !20
  %404 = load i64, i64* %78, align 8, !tbaa !20
  store i64 %404, i64* %75, align 8, !tbaa !20
  %405 = load i64, i64* %79, align 8, !tbaa !20
  store i64 %405, i64* %76, align 8, !tbaa !20
  %406 = load i64, i64* %80, align 8, !tbaa !20
  store i64 %406, i64* %77, align 8, !tbaa !20
  %407 = load i64, i64* %81, align 8, !tbaa !20
  store i64 %407, i64* %78, align 8, !tbaa !20
  %408 = load i64, i64* %82, align 8, !tbaa !20
  store i64 %408, i64* %79, align 8, !tbaa !20
  %409 = load i64, i64* %83, align 8, !tbaa !20
  store i64 %409, i64* %80, align 8, !tbaa !20
  %410 = load i64, i64* %84, align 8, !tbaa !20
  store i64 %410, i64* %81, align 8, !tbaa !20
  store i64 1, i64* %82, align 8, !tbaa !20
  store i64 0, i64* %83, align 8, !tbaa !20
  store i64 0, i64* %84, align 8, !tbaa !20
  %411 = icmp eq i64 %365, %367
  br i1 %411, label %359, label %.loopexit

.loopexit:                                        ; preds = %363, %359, %228, %220
  %412 = bitcast %"struct.Halide::Runtime::Internal::device_copy"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* nonnull align 8 dereferenceable(416) %412, i8* nonnull align 8 dereferenceable(416) %7, i32 416, i1 false), !tbaa.struct !50
  br label %413

413:                                              ; preds = %.loopexit, %226, %216
  call void @llvm.lifetime.end.p0i8(i64 416, i8* nonnull %7) #6
  ret void
}

; Function Attrs: nounwind
define linkonce i32 @_ZN6Halide7Runtime8Internal27copy_to_host_already_lockedEPvP15halide_buffer_t(i8* %0, %struct.halide_buffer_t* %1) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %4 = load i64, i64* %3, align 8, !tbaa !33
  %5 = and i64 %4, 2
  %6 = icmp eq i64 %5, 0
  br i1 %6, label %25, label %7

7:                                                ; preds = %2
  %8 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %9 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %8, align 8, !tbaa !31
  %10 = and i64 %4, 1
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %12, label %25

12:                                               ; preds = %7
  %13 = icmp eq %struct.halide_device_interface_t* %9, null
  br i1 %13, label %25, label %14

14:                                               ; preds = %12
  %15 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %9, i32 0, i32 15
  %16 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %15, align 4, !tbaa !51
  %17 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %16, i32 0, i32 6
  %18 = load i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)** %17, align 4, !tbaa !53
  %19 = tail call i32 %18(i8* %0, %struct.halide_buffer_t* nonnull %1) #10
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %21, label %25

21:                                               ; preds = %14
  %22 = load i64, i64* %3, align 8, !tbaa !33
  %23 = and i64 %22, -3
  store i64 %23, i64* %3, align 8, !tbaa !33
  %24 = tail call i32 @halide_msan_annotate_buffer_is_initialized(i8* %0, %struct.halide_buffer_t* nonnull %1) #8
  br label %25

25:                                               ; preds = %21, %14, %12, %7, %2
  %26 = phi i32 [ 0, %2 ], [ 0, %21 ], [ -14, %7 ], [ -19, %12 ], [ -14, %14 ]
  ret i32 %26
}

; Function Attrs: nounwind
define weak void @halide_device_release(i8* %0, %struct.halide_device_interface_t* %1) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %1, i32 0, i32 15
  %4 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %3, align 4, !tbaa !51
  %5 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %4, i32 0, i32 5
  %6 = load i32 (i8*)*, i32 (i8*)** %5, align 4, !tbaa !55
  %7 = tail call i32 %6(i8* %0) #10
  ret void
}

; Function Attrs: nounwind
define weak i32 @halide_copy_to_host(i8* %0, %struct.halide_buffer_t* %1) local_unnamed_addr #2 {
  tail call void @halide_mutex_lock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal17device_copy_mutexE) #8
  %3 = icmp eq %struct.halide_buffer_t* %1, null
  br i1 %3, label %4, label %6

4:                                                ; preds = %2
  %5 = tail call i32 @halide_error_buffer_is_null(i8* %0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.6.17, i32 0, i32 0)) #8
  br label %30

6:                                                ; preds = %2
  %7 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %8 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %7, align 8, !tbaa !31
  %9 = icmp ne %struct.halide_device_interface_t* %8, null
  %10 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %11 = load i64, i64* %10, align 8, !tbaa !29
  %12 = icmp ne i64 %11, 0
  %13 = xor i1 %12, true
  %14 = or i1 %9, %13
  br i1 %14, label %17, label %15

15:                                               ; preds = %6
  %16 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %30

17:                                               ; preds = %6
  %18 = xor i1 %9, true
  %19 = or i1 %12, %18
  br i1 %19, label %22, label %20

20:                                               ; preds = %17
  %21 = tail call i32 @halide_error_device_interface_no_device(i8* %0) #8
  br label %30

22:                                               ; preds = %17
  %23 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %24 = load i64, i64* %23, align 8, !tbaa !33
  %25 = and i64 %24, 3
  %26 = icmp eq i64 %25, 3
  br i1 %26, label %28, label %.split

.split:                                           ; preds = %22
  %27 = tail call i32 @_ZN6Halide7Runtime8Internal27copy_to_host_already_lockedEPvP15halide_buffer_t(i8* %0, %struct.halide_buffer_t* nonnull %1) #9
  br label %34

28:                                               ; preds = %22
  %29 = tail call i32 @halide_error_host_and_device_dirty(i8* %0) #8
  br label %30

30:                                               ; preds = %28, %20, %15, %4
  %31 = phi i32 [ %5, %4 ], [ %21, %20 ], [ %16, %15 ], [ %29, %28 ]
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %.split1, label %34

.split1:                                          ; preds = %30
  %33 = tail call i32 @_ZN6Halide7Runtime8Internal27copy_to_host_already_lockedEPvP15halide_buffer_t(i8* %0, %struct.halide_buffer_t* %1) #9
  br label %34

34:                                               ; preds = %.split, %.split1, %30
  %35 = phi i32 [ %31, %30 ], [ %27, %.split ], [ %33, %.split1 ]
  tail call void @halide_mutex_unlock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal17device_copy_mutexE) #8
  ret i32 %35
}

; Function Attrs: nounwind
define linkonce i32 @copy_to_device_already_locked(i8* %0, %struct.halide_buffer_t* %1, %struct.halide_device_interface_t* %2) local_unnamed_addr #2 {
  %4 = icmp eq %struct.halide_buffer_t* %1, null
  br i1 %4, label %5, label %7

5:                                                ; preds = %3
  %6 = tail call i32 @halide_error_buffer_is_null(i8* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.7.18, i32 0, i32 0)) #8
  br label %30

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %9 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %8, align 8, !tbaa !31
  %10 = icmp ne %struct.halide_device_interface_t* %9, null
  %11 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %12 = load i64, i64* %11, align 8, !tbaa !29
  %13 = icmp ne i64 %12, 0
  %14 = xor i1 %13, true
  %15 = or i1 %10, %14
  br i1 %15, label %18, label %16

16:                                               ; preds = %7
  %17 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %30

18:                                               ; preds = %7
  %19 = xor i1 %10, true
  %20 = or i1 %13, %19
  br i1 %20, label %23, label %21

21:                                               ; preds = %18
  %22 = tail call i32 @halide_error_device_interface_no_device(i8* %0) #8
  br label %30

23:                                               ; preds = %18
  %24 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %25 = load i64, i64* %24, align 8, !tbaa !33
  %26 = and i64 %25, 3
  %27 = icmp eq i64 %26, 3
  br i1 %27, label %28, label %33

28:                                               ; preds = %23
  %29 = tail call i32 @halide_error_host_and_device_dirty(i8* %0) #8
  br label %30

30:                                               ; preds = %28, %21, %16, %5
  %31 = phi i32 [ %6, %5 ], [ %22, %21 ], [ %17, %16 ], [ %29, %28 ]
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %33, label %72

33:                                               ; preds = %30, %23
  %34 = icmp eq %struct.halide_device_interface_t* %2, null
  br i1 %34, label %35, label %41

35:                                               ; preds = %33
  %36 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %37 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %36, align 8, !tbaa !31
  %38 = icmp eq %struct.halide_device_interface_t* %37, null
  br i1 %38, label %39, label %41

39:                                               ; preds = %35
  %40 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %72

41:                                               ; preds = %35, %33
  %42 = phi %struct.halide_device_interface_t* [ %2, %33 ], [ %37, %35 ]
  %43 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %44 = load i64, i64* %43, align 8, !tbaa !29
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %51, label %46

46:                                               ; preds = %41
  %47 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %48 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %47, align 8, !tbaa !31
  %49 = icmp eq %struct.halide_device_interface_t* %48, %42
  br i1 %49, label %54, label %50

50:                                               ; preds = %46
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([61 x i8], [61 x i8]* @.str.9.19, i32 0, i32 0)) #8
  br label %72

51:                                               ; preds = %41
  %52 = tail call i32 @halide_device_malloc(i8* %0, %struct.halide_buffer_t* nonnull %1, %struct.halide_device_interface_t* nonnull %42) #9
  %53 = icmp eq i32 %52, 0
  br i1 %53, label %54, label %72

54:                                               ; preds = %51, %46
  %55 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %56 = load i64, i64* %55, align 8, !tbaa !33
  %57 = and i64 %56, 1
  %58 = icmp eq i64 %57, 0
  br i1 %58, label %72, label %59

59:                                               ; preds = %54
  %60 = and i64 %56, 2
  %61 = icmp eq i64 %60, 0
  br i1 %61, label %62, label %72

62:                                               ; preds = %59
  %63 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %42, i32 0, i32 15
  %64 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %63, align 4, !tbaa !51
  %65 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %64, i32 0, i32 7
  %66 = load i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)** %65, align 4, !tbaa !56
  %67 = tail call i32 %66(i8* %0, %struct.halide_buffer_t* nonnull %1) #10
  %68 = icmp eq i32 %67, 0
  br i1 %68, label %69, label %72

69:                                               ; preds = %62
  %70 = load i64, i64* %55, align 8, !tbaa !33
  %71 = and i64 %70, -2
  store i64 %71, i64* %55, align 8, !tbaa !33
  br label %72

72:                                               ; preds = %69, %62, %59, %54, %51, %50, %39, %30
  %73 = phi i32 [ %40, %39 ], [ -42, %50 ], [ %31, %30 ], [ -15, %59 ], [ 0, %54 ], [ 0, %69 ], [ %52, %51 ], [ -15, %62 ]
  ret i32 %73
}

; Function Attrs: nounwind
define weak i32 @halide_device_malloc(i8* %0, %struct.halide_buffer_t* %1, %struct.halide_device_interface_t* %2) local_unnamed_addr #2 {
  %4 = icmp eq %struct.halide_buffer_t* %1, null
  br i1 %4, label %5, label %7

5:                                                ; preds = %3
  %6 = tail call i32 @halide_error_buffer_is_null(i8* %0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.17.20, i32 0, i32 0)) #8
  br label %30

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %9 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %8, align 8, !tbaa !31
  %10 = icmp ne %struct.halide_device_interface_t* %9, null
  %11 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %12 = load i64, i64* %11, align 8, !tbaa !29
  %13 = icmp ne i64 %12, 0
  %14 = xor i1 %13, true
  %15 = or i1 %10, %14
  br i1 %15, label %18, label %16

16:                                               ; preds = %7
  %17 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %30

18:                                               ; preds = %7
  %19 = xor i1 %10, true
  %20 = or i1 %13, %19
  br i1 %20, label %23, label %21

21:                                               ; preds = %18
  %22 = tail call i32 @halide_error_device_interface_no_device(i8* %0) #8
  br label %30

23:                                               ; preds = %18
  %24 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %25 = load i64, i64* %24, align 8, !tbaa !33
  %26 = and i64 %25, 3
  %27 = icmp eq i64 %26, 3
  br i1 %27, label %28, label %36

28:                                               ; preds = %23
  %29 = tail call i32 @halide_error_host_and_device_dirty(i8* %0) #8
  br label %30

30:                                               ; preds = %28, %21, %16, %5
  %31 = phi i32 [ %6, %5 ], [ %22, %21 ], [ %17, %16 ], [ %29, %28 ]
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %33, label %56

33:                                               ; preds = %30
  %34 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %35 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %34, align 8, !tbaa !31
  br label %36

36:                                               ; preds = %33, %23
  %37 = phi %struct.halide_device_interface_t* [ %35, %33 ], [ %9, %23 ]
  %38 = icmp eq %struct.halide_device_interface_t* %37, null
  %39 = icmp eq %struct.halide_device_interface_t* %37, %2
  %40 = or i1 %38, %39
  br i1 %40, label %42, label %41

41:                                               ; preds = %36
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.20.21, i32 0, i32 0)) #8
  br label %56

42:                                               ; preds = %36
  %43 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %2, i32 0, i32 15
  %44 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %43, align 4, !tbaa !51
  %45 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %44, i32 0, i32 0
  %46 = load void ()*, void ()** %45, align 4, !tbaa !57
  tail call void %46() #10
  %47 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %43, align 4, !tbaa !51
  %48 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %47, i32 0, i32 2
  %49 = load i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)** %48, align 4, !tbaa !58
  %50 = tail call i32 %49(i8* %0, %struct.halide_buffer_t* nonnull %1) #10
  %51 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %43, align 4, !tbaa !51
  %52 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %51, i32 0, i32 1
  %53 = load void ()*, void ()** %52, align 4, !tbaa !59
  tail call void %53() #10
  %54 = icmp eq i32 %50, 0
  %55 = select i1 %54, i32 0, i32 -16
  br label %56

56:                                               ; preds = %42, %41, %30
  %57 = phi i32 [ %31, %30 ], [ -42, %41 ], [ %55, %42 ]
  ret i32 %57
}

; Function Attrs: nounwind
define weak i32 @halide_copy_to_device(i8* %0, %struct.halide_buffer_t* %1, %struct.halide_device_interface_t* %2) local_unnamed_addr #2 {
  tail call void @halide_mutex_lock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal17device_copy_mutexE) #8
  %4 = tail call i32 @copy_to_device_already_locked(i8* %0, %struct.halide_buffer_t* %1, %struct.halide_device_interface_t* %2) #9
  tail call void @halide_mutex_unlock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal17device_copy_mutexE) #8
  ret i32 %4
}

; Function Attrs: nounwind
define weak i32 @halide_device_sync(i8* %0, %struct.halide_buffer_t* %1) local_unnamed_addr #2 {
  %3 = icmp eq %struct.halide_buffer_t* %1, null
  br i1 %3, label %4, label %6

4:                                                ; preds = %2
  %5 = tail call i32 @halide_error_buffer_is_null(i8* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.16.22, i32 0, i32 0)) #8
  br label %29

6:                                                ; preds = %2
  %7 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %8 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %7, align 8, !tbaa !31
  %9 = icmp ne %struct.halide_device_interface_t* %8, null
  %10 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %11 = load i64, i64* %10, align 8, !tbaa !29
  %12 = icmp ne i64 %11, 0
  %13 = xor i1 %12, true
  %14 = or i1 %9, %13
  br i1 %14, label %17, label %15

15:                                               ; preds = %6
  %16 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %29

17:                                               ; preds = %6
  %18 = xor i1 %9, true
  %19 = or i1 %12, %18
  br i1 %19, label %22, label %20

20:                                               ; preds = %17
  %21 = tail call i32 @halide_error_device_interface_no_device(i8* %0) #8
  br label %29

22:                                               ; preds = %17
  %23 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %24 = load i64, i64* %23, align 8, !tbaa !33
  %25 = and i64 %24, 3
  %26 = icmp eq i64 %25, 3
  br i1 %26, label %27, label %35

27:                                               ; preds = %22
  %28 = tail call i32 @halide_error_host_and_device_dirty(i8* %0) #8
  br label %29

29:                                               ; preds = %27, %20, %15, %4
  %30 = phi i32 [ %5, %4 ], [ %21, %20 ], [ %16, %15 ], [ %28, %27 ]
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %32, label %48

32:                                               ; preds = %29
  %33 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %34 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %33, align 8, !tbaa !31
  br label %35

35:                                               ; preds = %32, %22
  %36 = phi %struct.halide_device_interface_t* [ %34, %32 ], [ %8, %22 ]
  %37 = icmp eq %struct.halide_device_interface_t* %36, null
  br i1 %37, label %38, label %40

38:                                               ; preds = %35
  %39 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %48

40:                                               ; preds = %35
  %41 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %36, i32 0, i32 15
  %42 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %41, align 4, !tbaa !51
  %43 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %42, i32 0, i32 4
  %44 = load i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)** %43, align 4, !tbaa !60
  %45 = tail call i32 %44(i8* %0, %struct.halide_buffer_t* nonnull %1) #10
  %46 = icmp eq i32 %45, 0
  %47 = select i1 %46, i32 0, i32 -17
  br label %48

48:                                               ; preds = %40, %38, %29
  %49 = phi i32 [ %30, %29 ], [ %39, %38 ], [ %47, %40 ]
  ret i32 %49
}

; Function Attrs: nounwind
define weak i32 @halide_device_free(i8* %0, %struct.halide_buffer_t* %1) local_unnamed_addr #2 {
  %3 = icmp eq %struct.halide_buffer_t* %1, null
  br i1 %3, label %4, label %6

4:                                                ; preds = %2
  %5 = tail call i32 @halide_error_buffer_is_null(i8* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.21.23, i32 0, i32 0)) #8
  br label %29

6:                                                ; preds = %2
  %7 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %8 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %7, align 8, !tbaa !31
  %9 = icmp ne %struct.halide_device_interface_t* %8, null
  %10 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %11 = load i64, i64* %10, align 8, !tbaa !29
  %12 = icmp ne i64 %11, 0
  %13 = xor i1 %12, true
  %14 = or i1 %9, %13
  br i1 %14, label %17, label %15

15:                                               ; preds = %6
  %16 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %29

17:                                               ; preds = %6
  %18 = xor i1 %9, true
  %19 = or i1 %12, %18
  br i1 %19, label %22, label %20

20:                                               ; preds = %17
  %21 = tail call i32 @halide_error_device_interface_no_device(i8* %0) #8
  br label %29

22:                                               ; preds = %17
  %23 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %24 = load i64, i64* %23, align 8, !tbaa !33
  %25 = and i64 %24, 3
  %26 = icmp eq i64 %25, 3
  br i1 %26, label %27, label %35

27:                                               ; preds = %22
  %28 = tail call i32 @halide_error_host_and_device_dirty(i8* %0) #8
  br label %29

29:                                               ; preds = %27, %20, %15, %4
  %30 = phi i32 [ %5, %4 ], [ %21, %20 ], [ %16, %15 ], [ %28, %27 ]
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %32, label %61

32:                                               ; preds = %29
  %33 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %34 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %33, align 8, !tbaa !31
  br label %35

35:                                               ; preds = %32, %22
  %36 = phi %struct.halide_device_interface_t* [ %34, %32 ], [ %8, %22 ]
  %37 = icmp eq %struct.halide_device_interface_t* %36, null
  br i1 %37, label %57, label %38

38:                                               ; preds = %35
  %39 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %36, i32 0, i32 15
  %40 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %39, align 4, !tbaa !51
  %41 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %40, i32 0, i32 0
  %42 = load void ()*, void ()** %41, align 4, !tbaa !57
  tail call void %42() #10
  %43 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %39, align 4, !tbaa !51
  %44 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %43, i32 0, i32 3
  %45 = load i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)** %44, align 4, !tbaa !61
  %46 = tail call i32 %45(i8* %0, %struct.halide_buffer_t* nonnull %1) #10
  %47 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %39, align 4, !tbaa !51
  %48 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %47, i32 0, i32 1
  %49 = load void ()*, void ()** %48, align 4, !tbaa !59
  tail call void %49() #10
  %50 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %51 = load i64, i64* %50, align 8, !tbaa !29
  %52 = icmp eq i64 %51, 0
  br i1 %52, label %54, label %53

53:                                               ; preds = %38
  tail call void @halide_print(i8* %0, i8* getelementptr inbounds ([104 x i8], [104 x i8]* @.str.22.24, i32 0, i32 0)) #8
  tail call void @abort() #8
  br label %54

54:                                               ; preds = %53, %38
  %55 = icmp eq i32 %46, 0
  %56 = select i1 %55, i32 0, i32 -18
  br label %61

57:                                               ; preds = %35
  %58 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %59 = load i64, i64* %58, align 8, !tbaa !33
  %60 = and i64 %59, -3
  store i64 %60, i64* %58, align 8, !tbaa !33
  br label %61

61:                                               ; preds = %57, %54, %29
  %62 = phi i32 [ %30, %29 ], [ 0, %57 ], [ %56, %54 ]
  ret i32 %62
}

; Function Attrs: nounwind
define weak void @halide_device_free_as_destructor(i8* %0, i8* %1) local_unnamed_addr #2 {
  %3 = bitcast i8* %1 to %struct.halide_buffer_t*
  %4 = tail call i32 @halide_device_free(i8* %0, %struct.halide_buffer_t* %3) #9
  ret void
}

; Function Attrs: nounwind
define weak i32 @halide_device_and_host_malloc(i8* %0, %struct.halide_buffer_t* %1, %struct.halide_device_interface_t* %2) local_unnamed_addr #2 {
  %4 = icmp eq %struct.halide_buffer_t* %1, null
  br i1 %4, label %5, label %7

5:                                                ; preds = %3
  %6 = tail call i32 @halide_error_buffer_is_null(i8* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.23.25, i32 0, i32 0)) #8
  br label %30

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %9 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %8, align 8, !tbaa !31
  %10 = icmp ne %struct.halide_device_interface_t* %9, null
  %11 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %12 = load i64, i64* %11, align 8, !tbaa !29
  %13 = icmp ne i64 %12, 0
  %14 = xor i1 %13, true
  %15 = or i1 %10, %14
  br i1 %15, label %18, label %16

16:                                               ; preds = %7
  %17 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %30

18:                                               ; preds = %7
  %19 = xor i1 %10, true
  %20 = or i1 %13, %19
  br i1 %20, label %23, label %21

21:                                               ; preds = %18
  %22 = tail call i32 @halide_error_device_interface_no_device(i8* %0) #8
  br label %30

23:                                               ; preds = %18
  %24 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %25 = load i64, i64* %24, align 8, !tbaa !33
  %26 = and i64 %25, 3
  %27 = icmp eq i64 %26, 3
  br i1 %27, label %28, label %36

28:                                               ; preds = %23
  %29 = tail call i32 @halide_error_host_and_device_dirty(i8* %0) #8
  br label %30

30:                                               ; preds = %28, %21, %16, %5
  %31 = phi i32 [ %6, %5 ], [ %22, %21 ], [ %17, %16 ], [ %29, %28 ]
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %33, label %56

33:                                               ; preds = %30
  %34 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %35 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %34, align 8, !tbaa !31
  br label %36

36:                                               ; preds = %33, %23
  %37 = phi %struct.halide_device_interface_t* [ %35, %33 ], [ %9, %23 ]
  %38 = icmp eq %struct.halide_device_interface_t* %37, null
  %39 = icmp eq %struct.halide_device_interface_t* %37, %2
  %40 = or i1 %38, %39
  br i1 %40, label %42, label %41

41:                                               ; preds = %36
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.25, i32 0, i32 0)) #8
  br label %56

42:                                               ; preds = %36
  %43 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %2, i32 0, i32 15
  %44 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %43, align 4, !tbaa !51
  %45 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %44, i32 0, i32 0
  %46 = load void ()*, void ()** %45, align 4, !tbaa !57
  tail call void %46() #10
  %47 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %43, align 4, !tbaa !51
  %48 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %47, i32 0, i32 8
  %49 = load i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)** %48, align 4, !tbaa !62
  %50 = tail call i32 %49(i8* %0, %struct.halide_buffer_t* nonnull %1) #10
  %51 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %43, align 4, !tbaa !51
  %52 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %51, i32 0, i32 1
  %53 = load void ()*, void ()** %52, align 4, !tbaa !59
  tail call void %53() #10
  %54 = icmp eq i32 %50, 0
  br i1 %54, label %56, label %55

55:                                               ; preds = %42
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.26, i32 0, i32 0)) #8
  br label %56

56:                                               ; preds = %55, %42, %41, %30
  %57 = phi i32 [ %31, %30 ], [ -42, %41 ], [ -16, %55 ], [ 0, %42 ]
  ret i32 %57
}

; Function Attrs: nounwind
define weak i32 @halide_device_and_host_free(i8* %0, %struct.halide_buffer_t* %1) local_unnamed_addr #2 {
  %3 = icmp eq %struct.halide_buffer_t* %1, null
  br i1 %3, label %4, label %6

4:                                                ; preds = %2
  %5 = tail call i32 @halide_error_buffer_is_null(i8* %0, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.27, i32 0, i32 0)) #8
  br label %29

6:                                                ; preds = %2
  %7 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %8 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %7, align 8, !tbaa !31
  %9 = icmp ne %struct.halide_device_interface_t* %8, null
  %10 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %11 = load i64, i64* %10, align 8, !tbaa !29
  %12 = icmp ne i64 %11, 0
  %13 = xor i1 %12, true
  %14 = or i1 %9, %13
  br i1 %14, label %17, label %15

15:                                               ; preds = %6
  %16 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %29

17:                                               ; preds = %6
  %18 = xor i1 %9, true
  %19 = or i1 %12, %18
  br i1 %19, label %22, label %20

20:                                               ; preds = %17
  %21 = tail call i32 @halide_error_device_interface_no_device(i8* %0) #8
  br label %29

22:                                               ; preds = %17
  %23 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %24 = load i64, i64* %23, align 8, !tbaa !33
  %25 = and i64 %24, 3
  %26 = icmp eq i64 %25, 3
  br i1 %26, label %27, label %35

27:                                               ; preds = %22
  %28 = tail call i32 @halide_error_host_and_device_dirty(i8* %0) #8
  br label %29

29:                                               ; preds = %27, %20, %15, %4
  %30 = phi i32 [ %5, %4 ], [ %21, %20 ], [ %16, %15 ], [ %28, %27 ]
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %32, label %66

32:                                               ; preds = %29
  %33 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %34 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %33, align 8, !tbaa !31
  br label %35

35:                                               ; preds = %32, %22
  %36 = phi %struct.halide_device_interface_t* [ %34, %32 ], [ %8, %22 ]
  %37 = icmp eq %struct.halide_device_interface_t* %36, null
  br i1 %37, label %57, label %38

38:                                               ; preds = %35
  %39 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %36, i32 0, i32 15
  %40 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %39, align 4, !tbaa !51
  %41 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %40, i32 0, i32 0
  %42 = load void ()*, void ()** %41, align 4, !tbaa !57
  tail call void %42() #10
  %43 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %39, align 4, !tbaa !51
  %44 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %43, i32 0, i32 9
  %45 = load i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)** %44, align 4, !tbaa !63
  %46 = tail call i32 %45(i8* %0, %struct.halide_buffer_t* nonnull %1) #10
  %47 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %39, align 4, !tbaa !51
  %48 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %47, i32 0, i32 1
  %49 = load void ()*, void ()** %48, align 4, !tbaa !59
  tail call void %49() #10
  %50 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %51 = load i64, i64* %50, align 8, !tbaa !29
  %52 = icmp eq i64 %51, 0
  br i1 %52, label %54, label %53

53:                                               ; preds = %38
  tail call void @halide_print(i8* %0, i8* getelementptr inbounds ([104 x i8], [104 x i8]* @.str.28, i32 0, i32 0)) #8
  tail call void @abort() #8
  br label %54

54:                                               ; preds = %53, %38
  %55 = icmp eq i32 %46, 0
  %56 = select i1 %55, i32 0, i32 -18
  br label %66

57:                                               ; preds = %35
  %58 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 2
  %59 = load i8*, i8** %58, align 4, !tbaa !32
  %60 = icmp eq i8* %59, null
  br i1 %60, label %62, label %61

61:                                               ; preds = %57
  tail call void @halide_free(i8* %0, i8* nonnull %59) #8
  store i8* null, i8** %58, align 4, !tbaa !32
  br label %62

62:                                               ; preds = %61, %57
  %63 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %64 = load i64, i64* %63, align 8, !tbaa !33
  %65 = and i64 %64, -3
  store i64 %65, i64* %63, align 8, !tbaa !33
  br label %66

66:                                               ; preds = %62, %54, %29
  %67 = phi i32 [ %30, %29 ], [ 0, %62 ], [ %56, %54 ]
  ret i32 %67
}

; Function Attrs: nounwind
define weak i32 @halide_default_device_and_host_malloc(i8* %0, %struct.halide_buffer_t* %1, %struct.halide_device_interface_t* %2) local_unnamed_addr #2 {
  %4 = icmp eq %struct.halide_buffer_t* %1, null
  br i1 %4, label %5, label %7

5:                                                ; preds = %3
  %6 = tail call i32 @halide_error_buffer_is_null(i8* %0, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.29, i32 0, i32 0)) #8
  br label %30

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %9 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %8, align 8, !tbaa !31
  %10 = icmp ne %struct.halide_device_interface_t* %9, null
  %11 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %12 = load i64, i64* %11, align 8, !tbaa !29
  %13 = icmp ne i64 %12, 0
  %14 = xor i1 %13, true
  %15 = or i1 %10, %14
  br i1 %15, label %18, label %16

16:                                               ; preds = %7
  %17 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %30

18:                                               ; preds = %7
  %19 = xor i1 %10, true
  %20 = or i1 %13, %19
  br i1 %20, label %23, label %21

21:                                               ; preds = %18
  %22 = tail call i32 @halide_error_device_interface_no_device(i8* %0) #8
  br label %30

23:                                               ; preds = %18
  %24 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %25 = load i64, i64* %24, align 8, !tbaa !33
  %26 = and i64 %25, 3
  %27 = icmp eq i64 %26, 3
  br i1 %27, label %28, label %33

28:                                               ; preds = %23
  %29 = tail call i32 @halide_error_host_and_device_dirty(i8* %0) #8
  br label %30

30:                                               ; preds = %28, %21, %16, %5
  %31 = phi i32 [ %6, %5 ], [ %22, %21 ], [ %17, %16 ], [ %29, %28 ]
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %33, label %127

33:                                               ; preds = %30, %23
  %34 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 5
  %35 = load i32, i32* %34, align 4, !tbaa !34
  %36 = icmp sgt i32 %35, 0
  br i1 %36, label %40, label %37

37:                                               ; preds = %33
  %38 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 4, i32 1
  %39 = load i8, i8* %38, align 1, !tbaa !27
  %.0 = sub i32 1, 0
  br label %113

40:                                               ; preds = %33
  %41 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 6
  %42 = load %struct.halide_dimension_t*, %struct.halide_dimension_t** %41, align 8, !tbaa !35
  %43 = add i32 %35, -1
  %xtraiter = and i32 %35, 7
  %44 = icmp ult i32 %43, 7
  br i1 %44, label %.unr-lcssa, label %.new

.new:                                             ; preds = %40
  %unroll_iter = sub i32 %35, %xtraiter
  br label %45

45:                                               ; preds = %207, %.new
  %46 = phi i32 [ 0, %.new ], [ %209, %207 ]
  %47 = phi i32 [ 0, %.new ], [ %208, %207 ]
  %niter = phi i32 [ %unroll_iter, %.new ], [ %niter.nsub.7, %207 ]
  %48 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %46, i32 2
  %49 = load i32, i32* %48, align 4, !tbaa !39
  %50 = icmp sgt i32 %49, 0
  br i1 %50, label %51, label %57

51:                                               ; preds = %45
  %52 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %46, i32 1
  %53 = load i32, i32* %52, align 4, !tbaa !38
  %54 = add nsw i32 %53, -1
  %55 = mul nsw i32 %54, %49
  %56 = add nsw i32 %55, %47
  br label %57

57:                                               ; preds = %51, %45
  %58 = phi i32 [ %56, %51 ], [ %47, %45 ]
  %59 = or i32 %46, 1
  %60 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %59, i32 2
  %61 = load i32, i32* %60, align 4, !tbaa !39
  %62 = icmp sgt i32 %61, 0
  br i1 %62, label %129, label %135

.unr-lcssa:                                       ; preds = %207, %40
  %.lcssa13.ph = phi i32 [ undef, %40 ], [ %208, %207 ]
  %.unr = phi i32 [ 0, %40 ], [ %209, %207 ]
  %.unr14 = phi i32 [ 0, %40 ], [ %208, %207 ]
  %lcmp.mod = icmp eq i32 %xtraiter, 0
  br i1 %lcmp.mod, label %.epilog-lcssa, label %.epil.preheader

.epil.preheader:                                  ; preds = %.unr-lcssa, %74
  %63 = phi i32 [ %76, %74 ], [ %.unr, %.unr-lcssa ]
  %64 = phi i32 [ %75, %74 ], [ %.unr14, %.unr-lcssa ]
  %epil.iter = phi i32 [ %epil.iter.sub, %74 ], [ %xtraiter, %.unr-lcssa ]
  %65 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %63, i32 2
  %66 = load i32, i32* %65, align 4, !tbaa !39
  %67 = icmp sgt i32 %66, 0
  br i1 %67, label %68, label %74

68:                                               ; preds = %.epil.preheader
  %69 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %63, i32 1
  %70 = load i32, i32* %69, align 4, !tbaa !38
  %71 = add nsw i32 %70, -1
  %72 = mul nsw i32 %71, %66
  %73 = add nsw i32 %72, %64
  br label %74

74:                                               ; preds = %68, %.epil.preheader
  %75 = phi i32 [ %73, %68 ], [ %64, %.epil.preheader ]
  %76 = add nuw nsw i32 %63, 1
  %epil.iter.sub = add i32 %epil.iter, -1
  %epil.iter.cmp = icmp eq i32 %epil.iter.sub, 0
  br i1 %epil.iter.cmp, label %.epilog-lcssa, label %.epil.preheader, !llvm.loop !64

.epilog-lcssa:                                    ; preds = %74, %.unr-lcssa
  %.lcssa13 = phi i32 [ %.lcssa13.ph, %.unr-lcssa ], [ %75, %74 ]
  %77 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 4, i32 1
  %78 = load i8, i8* %77, align 1, !tbaa !27
  %xtraiter19 = and i32 %35, 7
  %79 = icmp ult i32 %43, 7
  br i1 %79, label %.unr-lcssa17, label %.new16

.new16:                                           ; preds = %.epilog-lcssa
  %unroll_iter26 = sub i32 %35, %xtraiter19
  br label %80

80:                                               ; preds = %288, %.new16
  %81 = phi i32 [ 0, %.new16 ], [ %290, %288 ]
  %82 = phi i32 [ 0, %.new16 ], [ %289, %288 ]
  %niter27 = phi i32 [ %unroll_iter26, %.new16 ], [ %niter27.nsub.7, %288 ]
  %83 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %81, i32 2
  %84 = load i32, i32* %83, align 4, !tbaa !39
  %85 = icmp slt i32 %84, 0
  br i1 %85, label %86, label %92

86:                                               ; preds = %80
  %87 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %81, i32 1
  %88 = load i32, i32* %87, align 4, !tbaa !38
  %89 = add nsw i32 %88, -1
  %90 = mul nsw i32 %89, %84
  %91 = add nsw i32 %90, %82
  br label %92

92:                                               ; preds = %86, %80
  %93 = phi i32 [ %91, %86 ], [ %82, %80 ]
  %94 = or i32 %81, 1
  %95 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %94, i32 2
  %96 = load i32, i32* %95, align 4, !tbaa !39
  %97 = icmp slt i32 %96, 0
  br i1 %97, label %210, label %216

.unr-lcssa17:                                     ; preds = %288, %.epilog-lcssa
  %.lcssa.ph = phi i32 [ undef, %.epilog-lcssa ], [ %289, %288 ]
  %.unr21 = phi i32 [ 0, %.epilog-lcssa ], [ %290, %288 ]
  %.unr22 = phi i32 [ 0, %.epilog-lcssa ], [ %289, %288 ]
  %lcmp.mod23 = icmp eq i32 %xtraiter19, 0
  br i1 %lcmp.mod23, label %.epilog-lcssa24, label %.epil.preheader18

.epil.preheader18:                                ; preds = %.unr-lcssa17, %109
  %98 = phi i32 [ %111, %109 ], [ %.unr21, %.unr-lcssa17 ]
  %99 = phi i32 [ %110, %109 ], [ %.unr22, %.unr-lcssa17 ]
  %epil.iter20 = phi i32 [ %epil.iter20.sub, %109 ], [ %xtraiter19, %.unr-lcssa17 ]
  %100 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %98, i32 2
  %101 = load i32, i32* %100, align 4, !tbaa !39
  %102 = icmp slt i32 %101, 0
  br i1 %102, label %103, label %109

103:                                              ; preds = %.epil.preheader18
  %104 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %98, i32 1
  %105 = load i32, i32* %104, align 4, !tbaa !38
  %106 = add nsw i32 %105, -1
  %107 = mul nsw i32 %106, %101
  %108 = add nsw i32 %107, %99
  br label %109

109:                                              ; preds = %103, %.epil.preheader18
  %110 = phi i32 [ %108, %103 ], [ %99, %.epil.preheader18 ]
  %111 = add nuw nsw i32 %98, 1
  %epil.iter20.sub = add i32 %epil.iter20, -1
  %epil.iter20.cmp = icmp eq i32 %epil.iter20.sub, 0
  br i1 %epil.iter20.cmp, label %.epilog-lcssa24, label %.epil.preheader18, !llvm.loop !65

.epilog-lcssa24:                                  ; preds = %109, %.unr-lcssa17
  %.lcssa = phi i32 [ %.lcssa.ph, %.unr-lcssa17 ], [ %110, %109 ]
  %112 = add nsw i32 %.lcssa13, 1
  %.1 = sub i32 %112, %.lcssa
  br label %113

113:                                              ; preds = %.epilog-lcssa24, %37
  %114 = phi i8 [ %39, %37 ], [ %78, %.epilog-lcssa24 ]
  %.phi = phi i32 [ %.0, %37 ], [ %.1, %.epilog-lcssa24 ]
  %115 = zext i8 %114 to i32
  %116 = add nuw nsw i32 %115, 7
  %117 = lshr i32 %116, 3
  %118 = mul i32 %.phi, %117
  %119 = tail call i8* @halide_malloc(i8* %0, i32 %118) #8
  %120 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 2
  store i8* %119, i8** %120, align 4, !tbaa !32
  %121 = icmp eq i8* %119, null
  br i1 %121, label %127, label %122

122:                                              ; preds = %113
  %123 = tail call i32 @halide_device_malloc(i8* %0, %struct.halide_buffer_t* nonnull %1, %struct.halide_device_interface_t* %2) #9
  %124 = icmp eq i32 %123, 0
  br i1 %124, label %127, label %125

125:                                              ; preds = %122
  %126 = load i8*, i8** %120, align 4, !tbaa !32
  tail call void @halide_free(i8* %0, i8* %126) #8
  store i8* null, i8** %120, align 4, !tbaa !32
  br label %127

127:                                              ; preds = %125, %122, %113, %30
  %128 = phi i32 [ %31, %30 ], [ -1, %113 ], [ 0, %122 ], [ %123, %125 ]
  ret i32 %128

129:                                              ; preds = %57
  %130 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %59, i32 1
  %131 = load i32, i32* %130, align 4, !tbaa !38
  %132 = add nsw i32 %131, -1
  %133 = mul nsw i32 %132, %61
  %134 = add nsw i32 %133, %58
  br label %135

135:                                              ; preds = %129, %57
  %136 = phi i32 [ %134, %129 ], [ %58, %57 ]
  %137 = or i32 %46, 2
  %138 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %137, i32 2
  %139 = load i32, i32* %138, align 4, !tbaa !39
  %140 = icmp sgt i32 %139, 0
  br i1 %140, label %141, label %147

141:                                              ; preds = %135
  %142 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %137, i32 1
  %143 = load i32, i32* %142, align 4, !tbaa !38
  %144 = add nsw i32 %143, -1
  %145 = mul nsw i32 %144, %139
  %146 = add nsw i32 %145, %136
  br label %147

147:                                              ; preds = %141, %135
  %148 = phi i32 [ %146, %141 ], [ %136, %135 ]
  %149 = or i32 %46, 3
  %150 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %149, i32 2
  %151 = load i32, i32* %150, align 4, !tbaa !39
  %152 = icmp sgt i32 %151, 0
  br i1 %152, label %153, label %159

153:                                              ; preds = %147
  %154 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %149, i32 1
  %155 = load i32, i32* %154, align 4, !tbaa !38
  %156 = add nsw i32 %155, -1
  %157 = mul nsw i32 %156, %151
  %158 = add nsw i32 %157, %148
  br label %159

159:                                              ; preds = %153, %147
  %160 = phi i32 [ %158, %153 ], [ %148, %147 ]
  %161 = or i32 %46, 4
  %162 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %161, i32 2
  %163 = load i32, i32* %162, align 4, !tbaa !39
  %164 = icmp sgt i32 %163, 0
  br i1 %164, label %165, label %171

165:                                              ; preds = %159
  %166 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %161, i32 1
  %167 = load i32, i32* %166, align 4, !tbaa !38
  %168 = add nsw i32 %167, -1
  %169 = mul nsw i32 %168, %163
  %170 = add nsw i32 %169, %160
  br label %171

171:                                              ; preds = %165, %159
  %172 = phi i32 [ %170, %165 ], [ %160, %159 ]
  %173 = or i32 %46, 5
  %174 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %173, i32 2
  %175 = load i32, i32* %174, align 4, !tbaa !39
  %176 = icmp sgt i32 %175, 0
  br i1 %176, label %177, label %183

177:                                              ; preds = %171
  %178 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %173, i32 1
  %179 = load i32, i32* %178, align 4, !tbaa !38
  %180 = add nsw i32 %179, -1
  %181 = mul nsw i32 %180, %175
  %182 = add nsw i32 %181, %172
  br label %183

183:                                              ; preds = %177, %171
  %184 = phi i32 [ %182, %177 ], [ %172, %171 ]
  %185 = or i32 %46, 6
  %186 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %185, i32 2
  %187 = load i32, i32* %186, align 4, !tbaa !39
  %188 = icmp sgt i32 %187, 0
  br i1 %188, label %189, label %195

189:                                              ; preds = %183
  %190 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %185, i32 1
  %191 = load i32, i32* %190, align 4, !tbaa !38
  %192 = add nsw i32 %191, -1
  %193 = mul nsw i32 %192, %187
  %194 = add nsw i32 %193, %184
  br label %195

195:                                              ; preds = %189, %183
  %196 = phi i32 [ %194, %189 ], [ %184, %183 ]
  %197 = or i32 %46, 7
  %198 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %197, i32 2
  %199 = load i32, i32* %198, align 4, !tbaa !39
  %200 = icmp sgt i32 %199, 0
  br i1 %200, label %201, label %207

201:                                              ; preds = %195
  %202 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %197, i32 1
  %203 = load i32, i32* %202, align 4, !tbaa !38
  %204 = add nsw i32 %203, -1
  %205 = mul nsw i32 %204, %199
  %206 = add nsw i32 %205, %196
  br label %207

207:                                              ; preds = %201, %195
  %208 = phi i32 [ %206, %201 ], [ %196, %195 ]
  %209 = add nuw nsw i32 %46, 8
  %niter.nsub.7 = add i32 %niter, -8
  %niter.ncmp.7 = icmp eq i32 %niter.nsub.7, 0
  br i1 %niter.ncmp.7, label %.unr-lcssa, label %45

210:                                              ; preds = %92
  %211 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %94, i32 1
  %212 = load i32, i32* %211, align 4, !tbaa !38
  %213 = add nsw i32 %212, -1
  %214 = mul nsw i32 %213, %96
  %215 = add nsw i32 %214, %93
  br label %216

216:                                              ; preds = %210, %92
  %217 = phi i32 [ %215, %210 ], [ %93, %92 ]
  %218 = or i32 %81, 2
  %219 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %218, i32 2
  %220 = load i32, i32* %219, align 4, !tbaa !39
  %221 = icmp slt i32 %220, 0
  br i1 %221, label %222, label %228

222:                                              ; preds = %216
  %223 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %218, i32 1
  %224 = load i32, i32* %223, align 4, !tbaa !38
  %225 = add nsw i32 %224, -1
  %226 = mul nsw i32 %225, %220
  %227 = add nsw i32 %226, %217
  br label %228

228:                                              ; preds = %222, %216
  %229 = phi i32 [ %227, %222 ], [ %217, %216 ]
  %230 = or i32 %81, 3
  %231 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %230, i32 2
  %232 = load i32, i32* %231, align 4, !tbaa !39
  %233 = icmp slt i32 %232, 0
  br i1 %233, label %234, label %240

234:                                              ; preds = %228
  %235 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %230, i32 1
  %236 = load i32, i32* %235, align 4, !tbaa !38
  %237 = add nsw i32 %236, -1
  %238 = mul nsw i32 %237, %232
  %239 = add nsw i32 %238, %229
  br label %240

240:                                              ; preds = %234, %228
  %241 = phi i32 [ %239, %234 ], [ %229, %228 ]
  %242 = or i32 %81, 4
  %243 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %242, i32 2
  %244 = load i32, i32* %243, align 4, !tbaa !39
  %245 = icmp slt i32 %244, 0
  br i1 %245, label %246, label %252

246:                                              ; preds = %240
  %247 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %242, i32 1
  %248 = load i32, i32* %247, align 4, !tbaa !38
  %249 = add nsw i32 %248, -1
  %250 = mul nsw i32 %249, %244
  %251 = add nsw i32 %250, %241
  br label %252

252:                                              ; preds = %246, %240
  %253 = phi i32 [ %251, %246 ], [ %241, %240 ]
  %254 = or i32 %81, 5
  %255 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %254, i32 2
  %256 = load i32, i32* %255, align 4, !tbaa !39
  %257 = icmp slt i32 %256, 0
  br i1 %257, label %258, label %264

258:                                              ; preds = %252
  %259 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %254, i32 1
  %260 = load i32, i32* %259, align 4, !tbaa !38
  %261 = add nsw i32 %260, -1
  %262 = mul nsw i32 %261, %256
  %263 = add nsw i32 %262, %253
  br label %264

264:                                              ; preds = %258, %252
  %265 = phi i32 [ %263, %258 ], [ %253, %252 ]
  %266 = or i32 %81, 6
  %267 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %266, i32 2
  %268 = load i32, i32* %267, align 4, !tbaa !39
  %269 = icmp slt i32 %268, 0
  br i1 %269, label %270, label %276

270:                                              ; preds = %264
  %271 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %266, i32 1
  %272 = load i32, i32* %271, align 4, !tbaa !38
  %273 = add nsw i32 %272, -1
  %274 = mul nsw i32 %273, %268
  %275 = add nsw i32 %274, %265
  br label %276

276:                                              ; preds = %270, %264
  %277 = phi i32 [ %275, %270 ], [ %265, %264 ]
  %278 = or i32 %81, 7
  %279 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %278, i32 2
  %280 = load i32, i32* %279, align 4, !tbaa !39
  %281 = icmp slt i32 %280, 0
  br i1 %281, label %282, label %288

282:                                              ; preds = %276
  %283 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %42, i32 %278, i32 1
  %284 = load i32, i32* %283, align 4, !tbaa !38
  %285 = add nsw i32 %284, -1
  %286 = mul nsw i32 %285, %280
  %287 = add nsw i32 %286, %277
  br label %288

288:                                              ; preds = %282, %276
  %289 = phi i32 [ %287, %282 ], [ %277, %276 ]
  %290 = add nuw nsw i32 %81, 8
  %niter27.nsub.7 = add i32 %niter27, -8
  %niter27.ncmp.7 = icmp eq i32 %niter27.nsub.7, 0
  br i1 %niter27.ncmp.7, label %.unr-lcssa17, label %80
}

; Function Attrs: nounwind
define weak i32 @halide_default_device_and_host_free(i8* %0, %struct.halide_buffer_t* %1, %struct.halide_device_interface_t* %2) local_unnamed_addr #2 {
  %4 = icmp eq %struct.halide_buffer_t* %1, null
  br i1 %4, label %5, label %7

5:                                                ; preds = %3
  %6 = tail call i32 @halide_error_buffer_is_null(i8* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.30, i32 0, i32 0)) #8
  br label %31

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %9 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %8, align 8, !tbaa !31
  %10 = icmp ne %struct.halide_device_interface_t* %9, null
  %11 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %12 = load i64, i64* %11, align 8, !tbaa !29
  %13 = icmp ne i64 %12, 0
  %14 = xor i1 %13, true
  %15 = or i1 %10, %14
  br i1 %15, label %18, label %16

16:                                               ; preds = %7
  %17 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %31

18:                                               ; preds = %7
  %19 = xor i1 %10, true
  %20 = or i1 %13, %19
  br i1 %20, label %23, label %21

21:                                               ; preds = %18
  %22 = tail call i32 @halide_error_device_interface_no_device(i8* %0) #8
  br label %31

23:                                               ; preds = %18
  %24 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %25 = load i64, i64* %24, align 8, !tbaa !33
  %26 = and i64 %25, 3
  %27 = icmp eq i64 %26, 3
  br i1 %27, label %29, label %.split

.split:                                           ; preds = %23
  %28 = tail call i32 @halide_device_free(i8* %0, %struct.halide_buffer_t* nonnull %1) #9
  br label %35

29:                                               ; preds = %23
  %30 = tail call i32 @halide_error_host_and_device_dirty(i8* %0) #8
  br label %31

31:                                               ; preds = %29, %21, %16, %5
  %32 = phi i32 [ %6, %5 ], [ %22, %21 ], [ %17, %16 ], [ %30, %29 ]
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %.split1, label %44

.split1:                                          ; preds = %31
  %34 = tail call i32 @halide_device_free(i8* %0, %struct.halide_buffer_t* %1) #9
  br label %35

35:                                               ; preds = %.split1, %.split
  %phi.call = phi i32 [ %28, %.split ], [ %34, %.split1 ]
  %36 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 2
  %37 = load i8*, i8** %36, align 4, !tbaa !32
  %38 = icmp eq i8* %37, null
  br i1 %38, label %40, label %39

39:                                               ; preds = %35
  tail call void @halide_free(i8* %0, i8* nonnull %37) #8
  store i8* null, i8** %36, align 4, !tbaa !32
  br label %40

40:                                               ; preds = %39, %35
  %41 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %42 = load i64, i64* %41, align 8, !tbaa !33
  %43 = and i64 %42, -4
  store i64 %43, i64* %41, align 8, !tbaa !33
  br label %44

44:                                               ; preds = %40, %31
  %45 = phi i32 [ %phi.call, %40 ], [ %32, %31 ]
  ret i32 %45
}

; Function Attrs: nounwind
define weak i32 @halide_device_wrap_native(i8* %0, %struct.halide_buffer_t* %1, i64 %2, %struct.halide_device_interface_t* %3) local_unnamed_addr #2 {
  %5 = icmp eq %struct.halide_buffer_t* %1, null
  br i1 %5, label %6, label %8

6:                                                ; preds = %4
  %7 = tail call i32 @halide_error_buffer_is_null(i8* %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.31, i32 0, i32 0)) #8
  br label %31

8:                                                ; preds = %4
  %9 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %10 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %9, align 8, !tbaa !31
  %11 = icmp ne %struct.halide_device_interface_t* %10, null
  %12 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %13 = load i64, i64* %12, align 8, !tbaa !29
  %14 = icmp ne i64 %13, 0
  %15 = xor i1 %14, true
  %16 = or i1 %11, %15
  br i1 %16, label %19, label %17

17:                                               ; preds = %8
  %18 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %31

19:                                               ; preds = %8
  %20 = xor i1 %11, true
  %21 = or i1 %14, %20
  br i1 %21, label %24, label %22

22:                                               ; preds = %19
  %23 = tail call i32 @halide_error_device_interface_no_device(i8* %0) #8
  br label %31

24:                                               ; preds = %19
  %25 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %26 = load i64, i64* %25, align 8, !tbaa !33
  %27 = and i64 %26, 3
  %28 = icmp eq i64 %27, 3
  br i1 %28, label %29, label %37

29:                                               ; preds = %24
  %30 = tail call i32 @halide_error_host_and_device_dirty(i8* %0) #8
  br label %31

31:                                               ; preds = %29, %22, %17, %6
  %32 = phi i32 [ %7, %6 ], [ %23, %22 ], [ %18, %17 ], [ %30, %29 ]
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %34, label %58

34:                                               ; preds = %31
  %35 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %36 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %35, align 8, !tbaa !31
  br label %37

37:                                               ; preds = %34, %24
  %38 = phi %struct.halide_device_interface_t* [ %36, %34 ], [ %10, %24 ]
  %39 = icmp eq %struct.halide_device_interface_t* %38, null
  %40 = icmp eq %struct.halide_device_interface_t* %38, %3
  %41 = or i1 %39, %40
  br i1 %41, label %43, label %42

42:                                               ; preds = %37
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([64 x i8], [64 x i8]* @.str.32, i32 0, i32 0)) #8
  br label %58

43:                                               ; preds = %37
  %44 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %45 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %3, i32 0, i32 15
  %46 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %45, align 4, !tbaa !51
  %47 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %46, i32 0, i32 0
  %48 = load void ()*, void ()** %47, align 4, !tbaa !57
  tail call void %48() #10
  store %struct.halide_device_interface_t* %3, %struct.halide_device_interface_t** %44, align 8, !tbaa !31
  %49 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %45, align 4, !tbaa !51
  %50 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %49, i32 0, i32 14
  %51 = load i32 (i8*, %struct.halide_buffer_t*, i64)*, i32 (i8*, %struct.halide_buffer_t*, i64)** %50, align 4, !tbaa !66
  %52 = tail call i32 %51(i8* %0, %struct.halide_buffer_t* nonnull %1, i64 %2) #10
  %53 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %45, align 4, !tbaa !51
  %54 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %53, i32 0, i32 1
  %55 = load void ()*, void ()** %54, align 4, !tbaa !59
  tail call void %55() #10
  %56 = icmp eq i32 %52, 0
  %57 = select i1 %56, i32 0, i32 -16
  br label %58

58:                                               ; preds = %43, %42, %31
  %59 = phi i32 [ %32, %31 ], [ -42, %42 ], [ %57, %43 ]
  ret i32 %59
}

; Function Attrs: nounwind
define weak i32 @halide_device_detach_native(i8* %0, %struct.halide_buffer_t* %1) local_unnamed_addr #2 {
  %3 = icmp eq %struct.halide_buffer_t* %1, null
  br i1 %3, label %4, label %6

4:                                                ; preds = %2
  %5 = tail call i32 @halide_error_buffer_is_null(i8* %0, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.33, i32 0, i32 0)) #8
  br label %29

6:                                                ; preds = %2
  %7 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %8 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %7, align 8, !tbaa !31
  %9 = icmp ne %struct.halide_device_interface_t* %8, null
  %10 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %11 = load i64, i64* %10, align 8, !tbaa !29
  %12 = icmp ne i64 %11, 0
  %13 = xor i1 %12, true
  %14 = or i1 %9, %13
  br i1 %14, label %17, label %15

15:                                               ; preds = %6
  %16 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %29

17:                                               ; preds = %6
  %18 = xor i1 %9, true
  %19 = or i1 %12, %18
  br i1 %19, label %22, label %20

20:                                               ; preds = %17
  %21 = tail call i32 @halide_error_device_interface_no_device(i8* %0) #8
  br label %29

22:                                               ; preds = %17
  %23 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %24 = load i64, i64* %23, align 8, !tbaa !33
  %25 = and i64 %24, 3
  %26 = icmp eq i64 %25, 3
  br i1 %26, label %27, label %35

27:                                               ; preds = %22
  %28 = tail call i32 @halide_error_host_and_device_dirty(i8* %0) #8
  br label %29

29:                                               ; preds = %27, %20, %15, %4
  %30 = phi i32 [ %5, %4 ], [ %21, %20 ], [ %16, %15 ], [ %28, %27 ]
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %32, label %57

32:                                               ; preds = %29
  %33 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %34 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %33, align 8, !tbaa !31
  br label %35

35:                                               ; preds = %32, %22
  %36 = phi %struct.halide_device_interface_t* [ %34, %32 ], [ %8, %22 ]
  %37 = icmp eq %struct.halide_device_interface_t* %36, null
  br i1 %37, label %57, label %38

38:                                               ; preds = %35
  %39 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %36, i32 0, i32 15
  %40 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %39, align 4, !tbaa !51
  %41 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %40, i32 0, i32 0
  %42 = load void ()*, void ()** %41, align 4, !tbaa !57
  tail call void %42() #10
  %43 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %39, align 4, !tbaa !51
  %44 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %43, i32 0, i32 15
  %45 = load i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)** %44, align 4, !tbaa !67
  %46 = tail call i32 %45(i8* %0, %struct.halide_buffer_t* nonnull %1) #10
  %47 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %39, align 4, !tbaa !51
  %48 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %47, i32 0, i32 1
  %49 = load void ()*, void ()** %48, align 4, !tbaa !59
  tail call void %49() #10
  %50 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %51 = load i64, i64* %50, align 8, !tbaa !29
  %52 = icmp eq i64 %51, 0
  br i1 %52, label %54, label %53

53:                                               ; preds = %38
  tail call void @halide_print(i8* %0, i8* getelementptr inbounds ([104 x i8], [104 x i8]* @.str.34, i32 0, i32 0)) #8
  tail call void @abort() #8
  br label %54

54:                                               ; preds = %53, %38
  %55 = icmp eq i32 %46, 0
  %56 = select i1 %55, i32 0, i32 -33
  ret i32 %56

57:                                               ; preds = %35, %29
  %58 = phi i32 [ %30, %29 ], [ 0, %35 ]
  ret i32 %58
}

; Function Attrs: nounwind
define weak i32 @halide_default_device_wrap_native(i8* %0, %struct.halide_buffer_t* %1, i64 %2) local_unnamed_addr #2 {
  %4 = icmp eq %struct.halide_buffer_t* %1, null
  br i1 %4, label %5, label %7

5:                                                ; preds = %3
  %6 = tail call i32 @halide_error_buffer_is_null(i8* %0, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.35, i32 0, i32 0)) #8
  br label %30

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %9 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %8, align 8, !tbaa !31
  %10 = icmp ne %struct.halide_device_interface_t* %9, null
  %11 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %12 = load i64, i64* %11, align 8, !tbaa !29
  %13 = icmp ne i64 %12, 0
  %14 = xor i1 %13, true
  %15 = or i1 %10, %14
  br i1 %15, label %18, label %16

16:                                               ; preds = %7
  %17 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %30

18:                                               ; preds = %7
  %19 = xor i1 %10, true
  %20 = or i1 %13, %19
  br i1 %20, label %23, label %21

21:                                               ; preds = %18
  %22 = tail call i32 @halide_error_device_interface_no_device(i8* %0) #8
  br label %30

23:                                               ; preds = %18
  %24 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %25 = load i64, i64* %24, align 8, !tbaa !33
  %26 = and i64 %25, 3
  %27 = icmp eq i64 %26, 3
  br i1 %27, label %28, label %36

28:                                               ; preds = %23
  %29 = tail call i32 @halide_error_host_and_device_dirty(i8* %0) #8
  br label %30

30:                                               ; preds = %28, %21, %16, %5
  %31 = phi i32 [ %6, %5 ], [ %22, %21 ], [ %17, %16 ], [ %29, %28 ]
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %33, label %43

33:                                               ; preds = %30
  %34 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %35 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %34, align 8, !tbaa !31
  br label %36

36:                                               ; preds = %33, %23
  %37 = phi %struct.halide_device_interface_t* [ %35, %33 ], [ %9, %23 ]
  %38 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %37, i32 0, i32 15
  %39 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %38, align 4, !tbaa !51
  %40 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %39, i32 0, i32 0
  %41 = load void ()*, void ()** %40, align 4, !tbaa !57
  tail call void %41() #10
  %42 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  store i64 %2, i64* %42, align 8, !tbaa !29
  br label %43

43:                                               ; preds = %36, %30
  %44 = phi i32 [ 0, %36 ], [ %31, %30 ]
  ret i32 %44
}

; Function Attrs: nounwind
define weak i32 @halide_default_device_detach_native(i8* %0, %struct.halide_buffer_t* %1) local_unnamed_addr #2 {
  %3 = icmp eq %struct.halide_buffer_t* %1, null
  br i1 %3, label %4, label %6

4:                                                ; preds = %2
  %5 = tail call i32 @halide_error_buffer_is_null(i8* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.36, i32 0, i32 0)) #8
  br label %29

6:                                                ; preds = %2
  %7 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %8 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %7, align 8, !tbaa !31
  %9 = icmp ne %struct.halide_device_interface_t* %8, null
  %10 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %11 = load i64, i64* %10, align 8, !tbaa !29
  %12 = icmp ne i64 %11, 0
  %13 = xor i1 %12, true
  %14 = or i1 %9, %13
  br i1 %14, label %17, label %15

15:                                               ; preds = %6
  %16 = tail call i32 @halide_error_no_device_interface(i8* %0) #8
  br label %29

17:                                               ; preds = %6
  %18 = xor i1 %9, true
  %19 = or i1 %12, %18
  br i1 %19, label %22, label %20

20:                                               ; preds = %17
  %21 = tail call i32 @halide_error_device_interface_no_device(i8* %0) #8
  br label %29

22:                                               ; preds = %17
  %23 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %24 = load i64, i64* %23, align 8, !tbaa !33
  %25 = and i64 %24, 3
  %26 = icmp eq i64 %25, 3
  br i1 %26, label %27, label %35

27:                                               ; preds = %22
  %28 = tail call i32 @halide_error_host_and_device_dirty(i8* %0) #8
  br label %29

29:                                               ; preds = %27, %20, %15, %4
  %30 = phi i32 [ %5, %4 ], [ %21, %20 ], [ %16, %15 ], [ %28, %27 ]
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %32, label %46

32:                                               ; preds = %29
  %33 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %34 = load i64, i64* %33, align 8, !tbaa !29
  br label %35

35:                                               ; preds = %32, %22
  %36 = phi i64 [ %34, %32 ], [ %11, %22 ]
  %37 = icmp eq i64 %36, 0
  br i1 %37, label %46, label %38

38:                                               ; preds = %35
  %39 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %40 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %41 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %40, align 8, !tbaa !31
  %42 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %41, i32 0, i32 15
  %43 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %42, align 4, !tbaa !51
  %44 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %43, i32 0, i32 1
  %45 = load void ()*, void ()** %44, align 4, !tbaa !59
  tail call void %45() #10
  store i64 0, i64* %39, align 8, !tbaa !29
  store %struct.halide_device_interface_t* null, %struct.halide_device_interface_t** %40, align 8, !tbaa !31
  br label %46

46:                                               ; preds = %38, %35, %29
  %47 = phi i32 [ 0, %38 ], [ %30, %29 ], [ 0, %35 ]
  ret i32 %47
}

; Function Attrs: nounwind
define weak void @halide_device_and_host_free_as_destructor(i8* %0, i8* %1) local_unnamed_addr #2 {
  %3 = bitcast i8* %1 to %struct.halide_buffer_t*
  %4 = tail call i32 @halide_device_and_host_free(i8* %0, %struct.halide_buffer_t* %3) #9
  ret void
}

; Function Attrs: nounwind
define weak void @halide_device_host_nop_free(i8* %0, i8* %1) local_unnamed_addr #2 {
  ret void
}

; Function Attrs: nounwind
define weak i32 @halide_default_buffer_copy(i8* %0, %struct.halide_buffer_t* %1, %struct.halide_device_interface_t* %2, %struct.halide_buffer_t* %3) local_unnamed_addr #2 {
  ret i32 -39
}

; Function Attrs: nounwind
define weak i32 @halide_buffer_copy_already_locked(i8* %0, %struct.halide_buffer_t* %1, %struct.halide_device_interface_t* %2, %struct.halide_buffer_t* %3) local_unnamed_addr #2 {
  %5 = alloca %"struct.Halide::Runtime::Internal::device_copy", align 8
  %6 = icmp ne %struct.halide_device_interface_t* %2, null
  br i1 %6, label %7, label %21

7:                                                ; preds = %4
  %8 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %3, i32 0, i32 1
  %9 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %8, align 8, !tbaa !31
  %10 = icmp eq %struct.halide_device_interface_t* %9, null
  %11 = icmp eq %struct.halide_device_interface_t* %9, %2
  %12 = or i1 %10, %11
  br i1 %12, label %14, label %13

13:                                               ; preds = %7
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([64 x i8], [64 x i8]* @.str.42, i32 0, i32 0)) #8
  br label %130

14:                                               ; preds = %7
  %15 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %3, i32 0, i32 0
  %16 = load i64, i64* %15, align 8, !tbaa !29
  %17 = icmp eq i64 %16, 0
  br i1 %17, label %18, label %21

18:                                               ; preds = %14
  %19 = tail call i32 @halide_device_malloc(i8* %0, %struct.halide_buffer_t* nonnull %3, %struct.halide_device_interface_t* nonnull %2) #9
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %21, label %130

21:                                               ; preds = %18, %14, %4
  %22 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %23 = load i64, i64* %22, align 8, !tbaa !29
  %24 = icmp eq i64 %23, 0
  %25 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 2
  %26 = load i8*, i8** %25, align 4, !tbaa !32
  br i1 %24, label %37, label %27

27:                                               ; preds = %21
  %28 = icmp eq i8* %26, null
  br i1 %28, label %29, label %31

29:                                               ; preds = %27
  %30 = icmp eq %struct.halide_device_interface_t* %2, null
  br label %50

31:                                               ; preds = %27
  %32 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %33 = load i64, i64* %32, align 8, !tbaa !33
  %34 = and i64 %33, 1
  %35 = icmp ne i64 %34, 0
  %36 = icmp eq %struct.halide_device_interface_t* %2, null
  br label %40

37:                                               ; preds = %21
  %38 = icmp eq %struct.halide_device_interface_t* %2, null
  %39 = icmp eq i8* %26, null
  br i1 %39, label %50, label %._crit_edge

._crit_edge:                                      ; preds = %37
  %.phi.trans.insert = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 3
  %.pre = load i64, i64* %.phi.trans.insert, align 8, !tbaa !33
  br label %40

40:                                               ; preds = %._crit_edge, %31
  %41 = phi i64 [ %33, %31 ], [ %.pre, %._crit_edge ]
  %42 = phi i1 [ %36, %31 ], [ %38, %._crit_edge ]
  %43 = phi i1 [ %35, %31 ], [ true, %._crit_edge ]
  %44 = and i64 %41, 2
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %50, label %46

46:                                               ; preds = %40
  %47 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %48 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %47, align 8, !tbaa !31
  %49 = icmp ne %struct.halide_device_interface_t* %48, null
  br label %50

50:                                               ; preds = %46, %40, %37, %29
  %51 = phi i1 [ false, %37 ], [ true, %40 ], [ true, %46 ], [ false, %29 ]
  %52 = phi i1 [ %38, %37 ], [ %42, %40 ], [ %42, %46 ], [ %30, %29 ]
  %53 = phi i1 [ true, %37 ], [ %43, %40 ], [ %43, %46 ], [ false, %29 ]
  %54 = phi i1 [ true, %37 ], [ false, %40 ], [ %49, %46 ], [ true, %29 ]
  %55 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %3, i32 0, i32 2
  %56 = load i8*, i8** %55, align 4, !tbaa !32
  %57 = icmp ne i8* %56, null
  %58 = xor i1 %52, true
  %59 = or i1 %57, %58
  br i1 %59, label %60, label %130

60:                                               ; preds = %50
  %61 = xor i1 %6, true
  %62 = or i1 %53, %61
  br i1 %62, label %70, label %63

63:                                               ; preds = %60
  %64 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %2, i32 0, i32 15
  %65 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %64, align 4, !tbaa !51
  %66 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %65, i32 0, i32 10
  %67 = load i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*, %struct.halide_buffer_t*)** %66, align 4, !tbaa !68
  %68 = tail call i32 %67(i8* %0, %struct.halide_buffer_t* nonnull %1, %struct.halide_device_interface_t* nonnull %2, %struct.halide_buffer_t* nonnull %3) #10
  %69 = icmp eq i32 %68, -42
  br i1 %69, label %70, label %117

70:                                               ; preds = %63, %60
  %71 = or i1 %51, %57
  br i1 %71, label %72, label %130

72:                                               ; preds = %70
  %73 = or i1 %54, %58
  br i1 %73, label %76, label %74

74:                                               ; preds = %72
  %75 = bitcast %"struct.Halide::Runtime::Internal::device_copy"* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 416, i8* nonnull %75) #6
  call void @_ZN6Halide7Runtime8Internal16make_buffer_copyEPK15halide_buffer_tbS4_b(%"struct.Halide::Runtime::Internal::device_copy"* nonnull sret %5, %struct.halide_buffer_t* nonnull %1, i1 zeroext true, %struct.halide_buffer_t* nonnull %3, i1 zeroext true) #9
  call void @_ZN6Halide7Runtime8Internal11copy_memoryERKNS1_11device_copyEPv(%"struct.Halide::Runtime::Internal::device_copy"* nonnull dereferenceable(416) %5, i8* %0) #9
  call void @llvm.lifetime.end.p0i8(i64 416, i8* nonnull %75) #6
  br label %120

76:                                               ; preds = %72
  br i1 %52, label %77, label %91

77:                                               ; preds = %76
  %78 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %79 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %78, align 8, !tbaa !31
  %80 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %79, i32 0, i32 15
  %81 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %80, align 4, !tbaa !51
  %82 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %81, i32 0, i32 10
  %83 = load i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*, %struct.halide_buffer_t*)** %82, align 4, !tbaa !68
  %84 = tail call i32 %83(i8* %0, %struct.halide_buffer_t* nonnull %1, %struct.halide_device_interface_t* null, %struct.halide_buffer_t* nonnull %3) #10
  %85 = icmp eq i32 %84, -42
  br i1 %85, label %86, label %117

86:                                               ; preds = %77
  %87 = tail call i32 @_ZN6Halide7Runtime8Internal27copy_to_host_already_lockedEPvP15halide_buffer_t(i8* %0, %struct.halide_buffer_t* nonnull %1) #9
  %88 = icmp eq i32 %87, 0
  br i1 %88, label %89, label %130

89:                                               ; preds = %86
  %90 = tail call i32 @halide_buffer_copy_already_locked(i8* %0, %struct.halide_buffer_t* nonnull %1, %struct.halide_device_interface_t* null, %struct.halide_buffer_t* nonnull %3) #9
  br label %117

91:                                               ; preds = %76
  %92 = xor i1 %57, true
  %93 = or i1 %53, %92
  br i1 %93, label %108, label %94

94:                                               ; preds = %91
  %95 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %96 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %95, align 8, !tbaa !31
  %97 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %96, i32 0, i32 15
  %98 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %97, align 4, !tbaa !51
  %99 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %98, i32 0, i32 10
  %100 = load i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*, %struct.halide_buffer_t*)** %99, align 4, !tbaa !68
  %101 = tail call i32 %100(i8* %0, %struct.halide_buffer_t* nonnull %1, %struct.halide_device_interface_t* null, %struct.halide_buffer_t* nonnull %3) #10
  %102 = icmp eq i32 %101, 0
  br i1 %102, label %103, label %130

103:                                              ; preds = %94
  %104 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %3, i32 0, i32 3
  %105 = load i64, i64* %104, align 8, !tbaa !33
  %106 = or i64 %105, 1
  store i64 %106, i64* %104, align 8, !tbaa !33
  %107 = tail call i32 @copy_to_device_already_locked(i8* %0, %struct.halide_buffer_t* nonnull %3, %struct.halide_device_interface_t* nonnull %2) #9
  br label %117

108:                                              ; preds = %91
  %109 = tail call i32 @_ZN6Halide7Runtime8Internal27copy_to_host_already_lockedEPvP15halide_buffer_t(i8* %0, %struct.halide_buffer_t* nonnull %1) #9
  %110 = icmp eq i32 %109, 0
  br i1 %110, label %111, label %130

111:                                              ; preds = %108
  %112 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %2, i32 0, i32 15
  %113 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %112, align 4, !tbaa !51
  %114 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %113, i32 0, i32 10
  %115 = load i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*, %struct.halide_buffer_t*)** %114, align 4, !tbaa !68
  %116 = tail call i32 %115(i8* %0, %struct.halide_buffer_t* nonnull %1, %struct.halide_device_interface_t* nonnull %2, %struct.halide_buffer_t* nonnull %3) #10
  br label %117

117:                                              ; preds = %111, %103, %89, %77, %63
  %118 = phi i32 [ %90, %89 ], [ %84, %77 ], [ %107, %103 ], [ %116, %111 ], [ %68, %63 ]
  %119 = icmp eq i32 %118, 0
  br i1 %119, label %120, label %130

120:                                              ; preds = %117, %74
  %121 = icmp eq %struct.halide_buffer_t* %3, %1
  br i1 %121, label %130, label %122

122:                                              ; preds = %120
  %123 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %3, i32 0, i32 3
  %124 = load i64, i64* %123, align 8, !tbaa !33
  %125 = and i64 %124, -4
  br i1 %6, label %126, label %128

126:                                              ; preds = %122
  %127 = or i64 %125, 2
  store i64 %127, i64* %123, align 8, !tbaa !33
  br label %130

128:                                              ; preds = %122
  %129 = or i64 %125, 1
  store i64 %129, i64* %123, align 8, !tbaa !33
  br label %130

130:                                              ; preds = %128, %126, %120, %117, %108, %94, %86, %70, %50, %18, %13
  %131 = phi i32 [ -42, %13 ], [ %19, %18 ], [ -34, %50 ], [ 0, %120 ], [ 0, %126 ], [ 0, %128 ], [ -42, %70 ], [ %118, %117 ], [ %109, %108 ], [ %101, %94 ], [ %87, %86 ]
  ret i32 %131
}

; Function Attrs: nounwind
define weak i32 @halide_buffer_copy(i8* %0, %struct.halide_buffer_t* %1, %struct.halide_device_interface_t* %2, %struct.halide_buffer_t* %3) local_unnamed_addr #2 {
  tail call void @halide_mutex_lock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal17device_copy_mutexE) #8
  %5 = icmp ne %struct.halide_device_interface_t* %2, null
  br i1 %5, label %6, label %11

6:                                                ; preds = %4
  %7 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %2, i32 0, i32 15
  %8 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %7, align 4, !tbaa !51
  %9 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %8, i32 0, i32 0
  %10 = load void ()*, void ()** %9, align 4, !tbaa !57
  tail call void %10() #10
  br label %11

11:                                               ; preds = %6, %4
  %12 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %13 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %12, align 8, !tbaa !31
  %14 = icmp eq %struct.halide_device_interface_t* %13, null
  br i1 %14, label %20, label %15

15:                                               ; preds = %11
  %16 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %13, i32 0, i32 15
  %17 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %16, align 4, !tbaa !51
  %18 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %17, i32 0, i32 0
  %19 = load void ()*, void ()** %18, align 4, !tbaa !57
  tail call void %19() #10
  br label %20

20:                                               ; preds = %15, %11
  %21 = tail call i32 @halide_buffer_copy_already_locked(i8* %0, %struct.halide_buffer_t* nonnull %1, %struct.halide_device_interface_t* %2, %struct.halide_buffer_t* %3) #9
  br i1 %5, label %22, label %27

22:                                               ; preds = %20
  %23 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %2, i32 0, i32 15
  %24 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %23, align 4, !tbaa !51
  %25 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %24, i32 0, i32 1
  %26 = load void ()*, void ()** %25, align 4, !tbaa !59
  tail call void %26() #10
  br label %27

27:                                               ; preds = %22, %20
  %28 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %12, align 8, !tbaa !31
  %29 = icmp eq %struct.halide_device_interface_t* %28, null
  br i1 %29, label %35, label %30

30:                                               ; preds = %27
  %31 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %28, i32 0, i32 15
  %32 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %31, align 4, !tbaa !51
  %33 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %32, i32 0, i32 1
  %34 = load void ()*, void ()** %33, align 4, !tbaa !59
  tail call void %34() #10
  br label %35

35:                                               ; preds = %30, %27
  tail call void @halide_mutex_unlock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal17device_copy_mutexE) #8
  ret i32 %21
}

; Function Attrs: nounwind
define weak i32 @halide_default_device_crop(i8* %0, %struct.halide_buffer_t* %1, %struct.halide_buffer_t* %2) local_unnamed_addr #2 {
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.58, i32 0, i32 0)) #8
  ret i32 -40
}

; Function Attrs: nounwind
define weak i32 @halide_default_device_slice(i8* %0, %struct.halide_buffer_t* %1, i32 %2, i32 %3, %struct.halide_buffer_t* %4) local_unnamed_addr #2 {
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.59, i32 0, i32 0)) #8
  ret i32 -40
}

; Function Attrs: nounwind
define weak i32 @halide_device_crop(i8* %0, %struct.halide_buffer_t* %1, %struct.halide_buffer_t* %2) local_unnamed_addr #2 {
  tail call void @halide_mutex_lock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal17device_copy_mutexE) #8
  %4 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %5 = load i64, i64* %4, align 8, !tbaa !29
  %6 = icmp eq i64 %5, 0
  br i1 %6, label %32, label %7

7:                                                ; preds = %3
  %8 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %2, i32 0, i32 0
  %9 = load i64, i64* %8, align 8, !tbaa !29
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %12, label %11

11:                                               ; preds = %7
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.60, i32 0, i32 0)) #8
  br label %32

12:                                               ; preds = %7
  %13 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 5
  %14 = load i32, i32* %13, align 4, !tbaa !34
  %15 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %2, i32 0, i32 5
  %16 = load i32, i32* %15, align 4, !tbaa !34
  %17 = icmp eq i32 %14, %16
  br i1 %17, label %19, label %18

18:                                               ; preds = %12
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.61, i32 0, i32 0)) #8
  br label %32

19:                                               ; preds = %12
  %20 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %21 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %20, align 8, !tbaa !31
  %22 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %21, i32 0, i32 15
  %23 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %22, align 4, !tbaa !51
  %24 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %23, i32 0, i32 0
  %25 = load void ()*, void ()** %24, align 4, !tbaa !57
  tail call void %25() #10
  %26 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %20, align 8, !tbaa !31
  %27 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %26, i32 0, i32 15
  %28 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %27, align 4, !tbaa !51
  %29 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %28, i32 0, i32 11
  %30 = load i32 (i8*, %struct.halide_buffer_t*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_buffer_t*)** %29, align 4, !tbaa !69
  %31 = tail call i32 %30(i8* %0, %struct.halide_buffer_t* nonnull %1, %struct.halide_buffer_t* nonnull %2) #10
  br label %32

32:                                               ; preds = %19, %18, %11, %3
  %33 = phi i32 [ -41, %11 ], [ -41, %18 ], [ %31, %19 ], [ 0, %3 ]
  tail call void @halide_mutex_unlock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal17device_copy_mutexE) #8
  ret i32 %33
}

; Function Attrs: nounwind
define weak i32 @halide_device_slice(i8* %0, %struct.halide_buffer_t* %1, i32 %2, i32 %3, %struct.halide_buffer_t* %4) local_unnamed_addr #2 {
  tail call void @halide_mutex_lock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal17device_copy_mutexE) #8
  %6 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %7 = load i64, i64* %6, align 8, !tbaa !29
  %8 = icmp eq i64 %7, 0
  br i1 %8, label %35, label %9

9:                                                ; preds = %5
  %10 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %4, i32 0, i32 0
  %11 = load i64, i64* %10, align 8, !tbaa !29
  %12 = icmp eq i64 %11, 0
  br i1 %12, label %14, label %13

13:                                               ; preds = %9
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.60, i32 0, i32 0)) #8
  br label %35

14:                                               ; preds = %9
  %15 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 5
  %16 = load i32, i32* %15, align 4, !tbaa !34
  %17 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %4, i32 0, i32 5
  %18 = load i32, i32* %17, align 4, !tbaa !34
  %19 = add nsw i32 %18, 1
  %20 = icmp eq i32 %16, %19
  br i1 %20, label %22, label %21

21:                                               ; preds = %14
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.64, i32 0, i32 0)) #8
  br label %35

22:                                               ; preds = %14
  %23 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %24 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %23, align 8, !tbaa !31
  %25 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %24, i32 0, i32 15
  %26 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %25, align 4, !tbaa !51
  %27 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %26, i32 0, i32 0
  %28 = load void ()*, void ()** %27, align 4, !tbaa !57
  tail call void %28() #10
  %29 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %23, align 8, !tbaa !31
  %30 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %29, i32 0, i32 15
  %31 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %30, align 4, !tbaa !51
  %32 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %31, i32 0, i32 12
  %33 = load i32 (i8*, %struct.halide_buffer_t*, i32, i32, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, i32, i32, %struct.halide_buffer_t*)** %32, align 4, !tbaa !70
  %34 = tail call i32 %33(i8* %0, %struct.halide_buffer_t* nonnull %1, i32 %2, i32 %3, %struct.halide_buffer_t* nonnull %4) #10
  br label %35

35:                                               ; preds = %22, %21, %13, %5
  %36 = phi i32 [ -41, %13 ], [ -41, %21 ], [ %34, %22 ], [ 0, %5 ]
  tail call void @halide_mutex_unlock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal17device_copy_mutexE) #8
  ret i32 %36
}

; Function Attrs: nounwind
define weak i32 @halide_default_device_release_crop(i8* %0, %struct.halide_buffer_t* %1) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %4 = load i64, i64* %3, align 8, !tbaa !29
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %7, label %6

6:                                                ; preds = %2
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.58, i32 0, i32 0)) #8
  br label %7

7:                                                ; preds = %6, %2
  %8 = phi i32 [ -40, %6 ], [ 0, %2 ]
  ret i32 %8
}

; Function Attrs: nounwind
define weak i32 @halide_device_release_crop(i8* %0, %struct.halide_buffer_t* %1) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 0
  %4 = load i64, i64* %3, align 8, !tbaa !29
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %17, label %6

6:                                                ; preds = %2
  tail call void @halide_mutex_lock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal17device_copy_mutexE) #8
  %7 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %1, i32 0, i32 1
  %8 = load %struct.halide_device_interface_t*, %struct.halide_device_interface_t** %7, align 8, !tbaa !31
  %9 = getelementptr inbounds %struct.halide_device_interface_t, %struct.halide_device_interface_t* %8, i32 0, i32 15
  %10 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %9, align 4, !tbaa !51
  %11 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %10, i32 0, i32 13
  %12 = load i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)** %11, align 4, !tbaa !71
  %13 = tail call i32 %12(i8* %0, %struct.halide_buffer_t* nonnull %1) #10
  store i64 0, i64* %3, align 8, !tbaa !29
  %14 = load %struct.halide_device_interface_impl_t*, %struct.halide_device_interface_impl_t** %9, align 4, !tbaa !51
  %15 = getelementptr inbounds %struct.halide_device_interface_impl_t, %struct.halide_device_interface_impl_t* %14, i32 0, i32 1
  %16 = load void ()*, void ()** %15, align 4, !tbaa !59
  tail call void %16() #10
  store %struct.halide_device_interface_t* null, %struct.halide_device_interface_t** %7, align 8, !tbaa !31
  tail call void @halide_mutex_unlock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal17device_copy_mutexE) #8
  br label %17

17:                                               ; preds = %6, %2
  %18 = phi i32 [ %13, %6 ], [ 0, %2 ]
  ret i32 %18
}

; Function Attrs: nounwind
define weak float @halide_float16_bits_to_float(i16 zeroext %0) local_unnamed_addr #2 {
  %2 = zext i16 %0 to i32
  %3 = shl nuw i32 %2, 16
  %4 = and i32 %3, -2147483648
  %5 = and i32 %2, 1023
  %6 = lshr i32 %2, 10
  %7 = and i32 %6, 31
  %8 = icmp eq i32 %7, 0
  %9 = icmp ne i32 %5, 0
  %10 = and i1 %9, %8
  br i1 %10, label %11, label %21

11:                                               ; preds = %1
  %12 = tail call i32 @llvm.ctlz.i32(i32 %5, i1 true), !range !72
  %13 = xor i32 %12, 31
  %14 = shl nuw i32 1, %13
  %15 = xor i32 %14, -1
  %16 = and i32 %5, %15
  %17 = sub nsw i32 23, %13
  %18 = shl i32 %16, %17
  %19 = shl nuw nsw i32 %13, 23
  %20 = add nuw nsw i32 %19, 864026624
  br label %27

21:                                               ; preds = %1
  %22 = shl nuw nsw i32 %5, 13
  br i1 %8, label %27, label %23

23:                                               ; preds = %21
  %24 = icmp eq i32 %7, 31
  %25 = shl nuw nsw i32 %7, 23
  %26 = add nuw nsw i32 %25, 939524096
  %spec.select = select i1 %24, i32 2139095040, i32 %26
  br label %27

27:                                               ; preds = %23, %21, %11
  %28 = phi i32 [ %20, %11 ], [ %22, %21 ], [ %22, %23 ]
  %29 = phi i32 [ %18, %11 ], [ 0, %21 ], [ %spec.select, %23 ]
  %30 = or i32 %28, %4
  %31 = or i32 %30, %29
  %32 = bitcast i32 %31 to float
  ret float %32
}

; Function Attrs: nounwind readnone speculatable willreturn
declare i32 @llvm.ctlz.i32(i32 %0, i1 immarg %1) #4

; Function Attrs: nounwind
define weak double @halide_float16_bits_to_double(i16 zeroext %0) local_unnamed_addr #2 {
  %2 = tail call float @halide_float16_bits_to_float(i16 zeroext %0) #9
  %3 = fpext float %2 to double
  ret double %3
}

; Function Attrs: nounwind
define weak i32 @halide_error_bounds_inference_call_failed(i8* %0, i8* %1, i32 %2) local_unnamed_addr #2 {
  %4 = tail call i8* @malloc(i32 1024) #8
  %5 = icmp eq i8* %4, null
  br i1 %5, label %.split, label %.split2

.split:                                           ; preds = %3
  %6 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([41 x i8], [41 x i8]* @.str.37, i32 0, i32 0)) #8
  br label %9

.split2:                                          ; preds = %3
  %7 = getelementptr inbounds i8, i8* %4, i32 1023
  store i8 0, i8* %7, align 1, !tbaa !17
  %8 = tail call i8* @halide_string_to_string(i8* nonnull %4, i8* nonnull %7, i8* nonnull getelementptr inbounds ([41 x i8], [41 x i8]* @.str.37, i32 0, i32 0)) #8
  br label %9

9:                                                ; preds = %.split, %.split2
  %phi.call = phi i8* [ %6, %.split ], [ %8, %.split2 ]
  %10 = phi i8* [ null, %.split ], [ %7, %.split2 ]
  %11 = icmp eq i8* %1, null
  br i1 %11, label %12, label %14

12:                                               ; preds = %9
  %13 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %10, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %16

14:                                               ; preds = %9
  %15 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %10, i8* nonnull %1) #8
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i8* [ %15, %14 ], [ %13, %12 ]
  %18 = tail call i8* @halide_string_to_string(i8* %17, i8* %10, i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.1.38, i32 0, i32 0)) #8
  %19 = sext i32 %2 to i64
  %20 = tail call i8* @halide_int64_to_string(i8* %18, i8* %10, i64 %19, i32 1) #8
  br i1 %5, label %21, label %22

21:                                               ; preds = %16
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %29

22:                                               ; preds = %16
  %23 = ptrtoint i8* %20 to i32
  %24 = ptrtoint i8* %4 to i32
  %25 = sub i32 1, %24
  %26 = add i32 %25, %23
  %27 = sext i32 %26 to i64
  %28 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %4, i64 %27) #8
  tail call void @halide_error(i8* %0, i8* nonnull %4) #8
  br label %29

29:                                               ; preds = %22, %21
  tail call void @free(i8* %4) #8
  ret i32 %2
}

; Function Attrs: nounwind
define weak i32 @halide_error_extern_stage_failed(i8* %0, i8* %1, i32 %2) local_unnamed_addr #2 {
  %4 = tail call i8* @malloc(i32 1024) #8
  %5 = icmp eq i8* %4, null
  br i1 %5, label %.split, label %.split2

.split:                                           ; preds = %3
  %6 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.2.39, i32 0, i32 0)) #8
  br label %9

.split2:                                          ; preds = %3
  %7 = getelementptr inbounds i8, i8* %4, i32 1023
  store i8 0, i8* %7, align 1, !tbaa !17
  %8 = tail call i8* @halide_string_to_string(i8* nonnull %4, i8* nonnull %7, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.2.39, i32 0, i32 0)) #8
  br label %9

9:                                                ; preds = %.split, %.split2
  %phi.call = phi i8* [ %6, %.split ], [ %8, %.split2 ]
  %10 = phi i8* [ null, %.split ], [ %7, %.split2 ]
  %11 = icmp eq i8* %1, null
  br i1 %11, label %12, label %14

12:                                               ; preds = %9
  %13 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %10, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %16

14:                                               ; preds = %9
  %15 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %10, i8* nonnull %1) #8
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i8* [ %15, %14 ], [ %13, %12 ]
  %18 = tail call i8* @halide_string_to_string(i8* %17, i8* %10, i8* nonnull getelementptr inbounds ([27 x i8], [27 x i8]* @.str.1.38, i32 0, i32 0)) #8
  %19 = sext i32 %2 to i64
  %20 = tail call i8* @halide_int64_to_string(i8* %18, i8* %10, i64 %19, i32 1) #8
  br i1 %5, label %21, label %22

21:                                               ; preds = %16
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %29

22:                                               ; preds = %16
  %23 = ptrtoint i8* %20 to i32
  %24 = ptrtoint i8* %4 to i32
  %25 = sub i32 1, %24
  %26 = add i32 %25, %23
  %27 = sext i32 %26 to i64
  %28 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %4, i64 %27) #8
  tail call void @halide_error(i8* %0, i8* nonnull %4) #8
  br label %29

29:                                               ; preds = %22, %21
  tail call void @free(i8* %4) #8
  ret i32 %2
}

; Function Attrs: nounwind
define weak i32 @halide_error_explicit_bounds_too_small(i8* %0, i8* %1, i8* %2, i32 %3, i32 %4, i32 %5, i32 %6) local_unnamed_addr #2 {
  %8 = tail call i8* @malloc(i32 1024) #8
  %9 = icmp eq i8* %8, null
  br i1 %9, label %.split, label %.split2

.split:                                           ; preds = %7
  %10 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.3.40, i32 0, i32 0)) #8
  br label %13

.split2:                                          ; preds = %7
  %11 = getelementptr inbounds i8, i8* %8, i32 1023
  store i8 0, i8* %11, align 1, !tbaa !17
  %12 = tail call i8* @halide_string_to_string(i8* nonnull %8, i8* nonnull %11, i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.3.40, i32 0, i32 0)) #8
  br label %13

13:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %10, %.split ], [ %12, %.split2 ]
  %14 = phi i8* [ null, %.split ], [ %11, %.split2 ]
  %15 = icmp eq i8* %2, null
  br i1 %15, label %16, label %18

16:                                               ; preds = %13
  %17 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %14, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %20

18:                                               ; preds = %13
  %19 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %14, i8* nonnull %2) #8
  br label %20

20:                                               ; preds = %18, %16
  %21 = phi i8* [ %19, %18 ], [ %17, %16 ]
  %22 = tail call i8* @halide_string_to_string(i8* %21, i8* %14, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4.41, i32 0, i32 0)) #8
  %23 = icmp eq i8* %1, null
  br i1 %23, label %24, label %26

24:                                               ; preds = %20
  %25 = tail call i8* @halide_string_to_string(i8* %22, i8* %14, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %28

26:                                               ; preds = %20
  %27 = tail call i8* @halide_string_to_string(i8* %22, i8* %14, i8* nonnull %1) #8
  br label %28

28:                                               ; preds = %26, %24
  %29 = phi i8* [ %27, %26 ], [ %25, %24 ]
  %30 = tail call i8* @halide_string_to_string(i8* %29, i8* %14, i8* nonnull getelementptr inbounds ([8 x i8], [8 x i8]* @.str.5.42, i32 0, i32 0)) #8
  %31 = sext i32 %3 to i64
  %32 = tail call i8* @halide_int64_to_string(i8* %30, i8* %14, i64 %31, i32 1) #8
  %33 = tail call i8* @halide_string_to_string(i8* %32, i8* %14, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.6.43, i32 0, i32 0)) #8
  %34 = sext i32 %4 to i64
  %35 = tail call i8* @halide_int64_to_string(i8* %33, i8* %14, i64 %34, i32 1) #8
  %36 = tail call i8* @halide_string_to_string(i8* %35, i8* %14, i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.7.44, i32 0, i32 0)) #8
  %37 = sext i32 %5 to i64
  %38 = tail call i8* @halide_int64_to_string(i8* %36, i8* %14, i64 %37, i32 1) #8
  %39 = tail call i8* @halide_string_to_string(i8* %38, i8* %14, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.6.43, i32 0, i32 0)) #8
  %40 = sext i32 %6 to i64
  %41 = tail call i8* @halide_int64_to_string(i8* %39, i8* %14, i64 %40, i32 1) #8
  %42 = tail call i8* @halide_string_to_string(i8* %41, i8* %14, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8.45, i32 0, i32 0)) #8
  br i1 %9, label %43, label %44

43:                                               ; preds = %28
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %51

44:                                               ; preds = %28
  %45 = ptrtoint i8* %42 to i32
  %46 = ptrtoint i8* %8 to i32
  %47 = sub i32 1, %46
  %48 = add i32 %47, %45
  %49 = sext i32 %48 to i64
  %50 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %8, i64 %49) #8
  tail call void @halide_error(i8* %0, i8* nonnull %8) #8
  br label %51

51:                                               ; preds = %44, %43
  tail call void @free(i8* %8) #8
  ret i32 -2
}

; Function Attrs: nounwind
define weak i32 @halide_error_bad_type(i8* %0, i8* %1, i32 %2, i32 %3) local_unnamed_addr #2 {
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca %struct.halide_type_t, align 2
  %8 = alloca %struct.halide_type_t, align 2
  store i32 %2, i32* %5, align 4, !tbaa !12
  store i32 %3, i32* %6, align 4, !tbaa !12
  %9 = getelementptr inbounds %struct.halide_type_t, %struct.halide_type_t* %7, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %9) #6
  store i8 0, i8* %9, align 2, !tbaa !24
  %10 = getelementptr inbounds %struct.halide_type_t, %struct.halide_type_t* %7, i32 0, i32 1
  store i8 0, i8* %10, align 1, !tbaa !27
  %11 = getelementptr inbounds %struct.halide_type_t, %struct.halide_type_t* %7, i32 0, i32 2
  store i16 0, i16* %11, align 2, !tbaa !28
  %12 = getelementptr inbounds %struct.halide_type_t, %struct.halide_type_t* %8, i32 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %12) #6
  store i8 0, i8* %12, align 2, !tbaa !24
  %13 = getelementptr inbounds %struct.halide_type_t, %struct.halide_type_t* %8, i32 0, i32 1
  store i8 0, i8* %13, align 1, !tbaa !27
  %14 = getelementptr inbounds %struct.halide_type_t, %struct.halide_type_t* %8, i32 0, i32 2
  store i16 0, i16* %14, align 2, !tbaa !28
  %15 = bitcast i32* %6 to i8*
  %16 = call i8* @memcpy(i8* nonnull %9, i8* nonnull %15, i32 4) #8
  %17 = bitcast i32* %5 to i8*
  %18 = call i8* @memcpy(i8* nonnull %12, i8* nonnull %17, i32 4) #8
  %19 = call i8* @malloc(i32 1024) #8
  %20 = icmp eq i8* %19, null
  br i1 %20, label %23, label %21

21:                                               ; preds = %4
  %22 = getelementptr inbounds i8, i8* %19, i32 1023
  store i8 0, i8* %22, align 1, !tbaa !17
  br label %23

23:                                               ; preds = %21, %4
  %24 = phi i8* [ %22, %21 ], [ null, %4 ]
  %25 = icmp eq i8* %1, null
  br i1 %25, label %26, label %28

26:                                               ; preds = %23
  %27 = call i8* @halide_string_to_string(i8* %19, i8* %24, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %30

28:                                               ; preds = %23
  %29 = call i8* @halide_string_to_string(i8* %19, i8* %24, i8* nonnull %1) #8
  br label %30

30:                                               ; preds = %28, %26
  %31 = phi i8* [ %29, %28 ], [ %27, %26 ]
  %32 = call i8* @halide_string_to_string(i8* %31, i8* %24, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.9.46, i32 0, i32 0)) #8
  %33 = call i8* @halide_type_to_string(i8* %32, i8* %24, %struct.halide_type_t* nonnull %7) #8
  %34 = call i8* @halide_string_to_string(i8* %33, i8* %24, i8* nonnull getelementptr inbounds ([38 x i8], [38 x i8]* @.str.10.47, i32 0, i32 0)) #8
  %35 = call i8* @halide_type_to_string(i8* %34, i8* %24, %struct.halide_type_t* nonnull %8) #8
  br i1 %20, label %36, label %37

36:                                               ; preds = %30
  call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %44

37:                                               ; preds = %30
  %38 = ptrtoint i8* %35 to i32
  %39 = ptrtoint i8* %19 to i32
  %40 = sub i32 1, %39
  %41 = add i32 %40, %38
  %42 = sext i32 %41 to i64
  %43 = call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %19, i64 %42) #8
  call void @halide_error(i8* %0, i8* nonnull %19) #8
  br label %44

44:                                               ; preds = %36, %37
  call void @free(i8* %19) #8
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %12) #6
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %9) #6
  ret i32 -3
}

; Function Attrs: nounwind
define weak i32 @halide_error_bad_dimensions(i8* %0, i8* %1, i32 %2, i32 %3) local_unnamed_addr #2 {
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %9, label %7

7:                                                ; preds = %4
  %8 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %8, align 1, !tbaa !17
  br label %9

9:                                                ; preds = %7, %4
  %10 = phi i8* [ %8, %7 ], [ null, %4 ]
  %11 = icmp eq i8* %1, null
  br i1 %11, label %12, label %14

12:                                               ; preds = %9
  %13 = tail call i8* @halide_string_to_string(i8* %5, i8* %10, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %16

14:                                               ; preds = %9
  %15 = tail call i8* @halide_string_to_string(i8* %5, i8* %10, i8* nonnull %1) #8
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i8* [ %15, %14 ], [ %13, %12 ]
  %18 = tail call i8* @halide_string_to_string(i8* %17, i8* %10, i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.11.48, i32 0, i32 0)) #8
  %19 = sext i32 %3 to i64
  %20 = tail call i8* @halide_int64_to_string(i8* %18, i8* %10, i64 %19, i32 1) #8
  %21 = tail call i8* @halide_string_to_string(i8* %20, i8* %10, i8* nonnull getelementptr inbounds ([43 x i8], [43 x i8]* @.str.12.49, i32 0, i32 0)) #8
  %22 = sext i32 %2 to i64
  %23 = tail call i8* @halide_int64_to_string(i8* %21, i8* %10, i64 %22, i32 1) #8
  %24 = tail call i8* @halide_string_to_string(i8* %23, i8* %10, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.13.50, i32 0, i32 0)) #8
  br i1 %6, label %25, label %26

25:                                               ; preds = %16
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %33

26:                                               ; preds = %16
  %27 = ptrtoint i8* %24 to i32
  %28 = ptrtoint i8* %5 to i32
  %29 = sub i32 1, %28
  %30 = add i32 %29, %27
  %31 = sext i32 %30 to i64
  %32 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %31) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %33

33:                                               ; preds = %26, %25
  tail call void @free(i8* %5) #8
  ret i32 -43
}

; Function Attrs: nounwind
define weak i32 @halide_error_access_out_of_bounds(i8* %0, i8* %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6) local_unnamed_addr #2 {
  %8 = icmp slt i32 %3, %5
  br i1 %8, label %9, label %40

9:                                                ; preds = %7
  %10 = tail call i8* @malloc(i32 1024) #8
  %11 = icmp eq i8* %10, null
  br i1 %11, label %14, label %12

12:                                               ; preds = %9
  %13 = getelementptr inbounds i8, i8* %10, i32 1023
  store i8 0, i8* %13, align 1, !tbaa !17
  br label %14

14:                                               ; preds = %12, %9
  %15 = phi i8* [ %13, %12 ], [ null, %9 ]
  %16 = icmp eq i8* %1, null
  br i1 %16, label %17, label %19

17:                                               ; preds = %14
  %18 = tail call i8* @halide_string_to_string(i8* %10, i8* %15, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %21

19:                                               ; preds = %14
  %20 = tail call i8* @halide_string_to_string(i8* %10, i8* %15, i8* nonnull %1) #8
  br label %21

21:                                               ; preds = %19, %17
  %22 = phi i8* [ %20, %19 ], [ %18, %17 ]
  %23 = tail call i8* @halide_string_to_string(i8* %22, i8* %15, i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.14.51, i32 0, i32 0)) #8
  %24 = sext i32 %3 to i64
  %25 = tail call i8* @halide_int64_to_string(i8* %23, i8* %15, i64 %24, i32 1) #8
  %26 = tail call i8* @halide_string_to_string(i8* %25, i8* %15, i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.15.52, i32 0, i32 0)) #8
  %27 = sext i32 %5 to i64
  %28 = tail call i8* @halide_int64_to_string(i8* %26, i8* %15, i64 %27, i32 1) #8
  %29 = tail call i8* @halide_string_to_string(i8* %28, i8* %15, i8* nonnull getelementptr inbounds ([16 x i8], [16 x i8]* @.str.16.53, i32 0, i32 0)) #8
  %30 = sext i32 %2 to i64
  %31 = tail call i8* @halide_int64_to_string(i8* %29, i8* %15, i64 %30, i32 1) #8
  br i1 %11, label %32, label %33

32:                                               ; preds = %21
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %73

33:                                               ; preds = %21
  %34 = ptrtoint i8* %31 to i32
  %35 = ptrtoint i8* %10 to i32
  %36 = sub i32 1, %35
  %37 = add i32 %36, %34
  %38 = sext i32 %37 to i64
  %39 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %10, i64 %38) #8
  tail call void @halide_error(i8* %0, i8* nonnull %10) #8
  br label %73

40:                                               ; preds = %7
  %41 = icmp sgt i32 %4, %6
  br i1 %41, label %42, label %75

42:                                               ; preds = %40
  %43 = tail call i8* @malloc(i32 1024) #8
  %44 = icmp eq i8* %43, null
  br i1 %44, label %47, label %45

45:                                               ; preds = %42
  %46 = getelementptr inbounds i8, i8* %43, i32 1023
  store i8 0, i8* %46, align 1, !tbaa !17
  br label %47

47:                                               ; preds = %45, %42
  %48 = phi i8* [ %46, %45 ], [ null, %42 ]
  %49 = icmp eq i8* %1, null
  br i1 %49, label %50, label %52

50:                                               ; preds = %47
  %51 = tail call i8* @halide_string_to_string(i8* %43, i8* %48, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %54

52:                                               ; preds = %47
  %53 = tail call i8* @halide_string_to_string(i8* %43, i8* %48, i8* nonnull %1) #8
  br label %54

54:                                               ; preds = %52, %50
  %55 = phi i8* [ %53, %52 ], [ %51, %50 ]
  %56 = tail call i8* @halide_string_to_string(i8* %55, i8* %48, i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.14.51, i32 0, i32 0)) #8
  %57 = sext i32 %4 to i64
  %58 = tail call i8* @halide_int64_to_string(i8* %56, i8* %48, i64 %57, i32 1) #8
  %59 = tail call i8* @halide_string_to_string(i8* %58, i8* %48, i8* nonnull getelementptr inbounds ([28 x i8], [28 x i8]* @.str.17.54, i32 0, i32 0)) #8
  %60 = sext i32 %6 to i64
  %61 = tail call i8* @halide_int64_to_string(i8* %59, i8* %48, i64 %60, i32 1) #8
  %62 = tail call i8* @halide_string_to_string(i8* %61, i8* %48, i8* nonnull getelementptr inbounds ([16 x i8], [16 x i8]* @.str.16.53, i32 0, i32 0)) #8
  %63 = sext i32 %2 to i64
  %64 = tail call i8* @halide_int64_to_string(i8* %62, i8* %48, i64 %63, i32 1) #8
  br i1 %44, label %65, label %66

65:                                               ; preds = %54
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %73

66:                                               ; preds = %54
  %67 = ptrtoint i8* %64 to i32
  %68 = ptrtoint i8* %43 to i32
  %69 = sub i32 1, %68
  %70 = add i32 %69, %67
  %71 = sext i32 %70 to i64
  %72 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %43, i64 %71) #8
  tail call void @halide_error(i8* %0, i8* nonnull %43) #8
  br label %73

73:                                               ; preds = %66, %65, %33, %32
  %74 = phi i8* [ null, %32 ], [ %10, %33 ], [ null, %65 ], [ %43, %66 ]
  tail call void @free(i8* %74) #8
  br label %75

75:                                               ; preds = %73, %40
  ret i32 -4
}

; Function Attrs: nounwind
define weak i32 @halide_error_buffer_allocation_too_large(i8* %0, i8* %1, i64 %2, i64 %3) local_unnamed_addr #2 {
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %.split, label %.split2

.split:                                           ; preds = %4
  %7 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.18.55, i32 0, i32 0)) #8
  br label %10

.split2:                                          ; preds = %4
  %8 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %8, align 1, !tbaa !17
  %9 = tail call i8* @halide_string_to_string(i8* nonnull %5, i8* nonnull %8, i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.18.55, i32 0, i32 0)) #8
  br label %10

10:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %7, %.split ], [ %9, %.split2 ]
  %11 = phi i8* [ null, %.split ], [ %8, %.split2 ]
  %12 = icmp eq i8* %1, null
  br i1 %12, label %13, label %15

13:                                               ; preds = %10
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %17

15:                                               ; preds = %10
  %16 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* nonnull %1) #8
  br label %17

17:                                               ; preds = %15, %13
  %18 = phi i8* [ %16, %15 ], [ %14, %13 ]
  %19 = tail call i8* @halide_string_to_string(i8* %18, i8* %11, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.56, i32 0, i32 0)) #8
  %20 = tail call i8* @halide_uint64_to_string(i8* %19, i8* %11, i64 %2, i32 1) #8
  %21 = tail call i8* @halide_string_to_string(i8* %20, i8* %11, i8* nonnull getelementptr inbounds ([37 x i8], [37 x i8]* @.str.20.57, i32 0, i32 0)) #8
  %22 = tail call i8* @halide_uint64_to_string(i8* %21, i8* %11, i64 %3, i32 1) #8
  br i1 %6, label %23, label %24

23:                                               ; preds = %17
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %31

24:                                               ; preds = %17
  %25 = ptrtoint i8* %22 to i32
  %26 = ptrtoint i8* %5 to i32
  %27 = sub i32 1, %26
  %28 = add i32 %27, %25
  %29 = sext i32 %28 to i64
  %30 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %29) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %31

31:                                               ; preds = %24, %23
  tail call void @free(i8* %5) #8
  ret i32 -5
}

; Function Attrs: nounwind
define weak i32 @halide_error_buffer_extents_negative(i8* %0, i8* %1, i32 %2, i32 %3) local_unnamed_addr #2 {
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %.split, label %.split2

.split:                                           ; preds = %4
  %7 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.21.58, i32 0, i32 0)) #8
  br label %10

.split2:                                          ; preds = %4
  %8 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %8, align 1, !tbaa !17
  %9 = tail call i8* @halide_string_to_string(i8* nonnull %5, i8* nonnull %8, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.21.58, i32 0, i32 0)) #8
  br label %10

10:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %7, %.split ], [ %9, %.split2 ]
  %11 = phi i8* [ null, %.split ], [ %8, %.split2 ]
  %12 = icmp eq i8* %1, null
  br i1 %12, label %13, label %15

13:                                               ; preds = %10
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %17

15:                                               ; preds = %10
  %16 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* nonnull %1) #8
  br label %17

17:                                               ; preds = %15, %13
  %18 = phi i8* [ %16, %15 ], [ %14, %13 ]
  %19 = tail call i8* @halide_string_to_string(i8* %18, i8* %11, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.22.59, i32 0, i32 0)) #8
  %20 = sext i32 %2 to i64
  %21 = tail call i8* @halide_int64_to_string(i8* %19, i8* %11, i64 %20, i32 1) #8
  %22 = tail call i8* @halide_string_to_string(i8* %21, i8* %11, i8* nonnull getelementptr inbounds ([15 x i8], [15 x i8]* @.str.23.60, i32 0, i32 0)) #8
  %23 = sext i32 %3 to i64
  %24 = tail call i8* @halide_int64_to_string(i8* %22, i8* %11, i64 %23, i32 1) #8
  %25 = tail call i8* @halide_string_to_string(i8* %24, i8* %11, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8.45, i32 0, i32 0)) #8
  br i1 %6, label %26, label %27

26:                                               ; preds = %17
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %34

27:                                               ; preds = %17
  %28 = ptrtoint i8* %25 to i32
  %29 = ptrtoint i8* %5 to i32
  %30 = sub i32 1, %29
  %31 = add i32 %30, %28
  %32 = sext i32 %31 to i64
  %33 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %32) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %34

34:                                               ; preds = %27, %26
  tail call void @free(i8* %5) #8
  ret i32 -28
}

; Function Attrs: nounwind
define weak i32 @halide_error_buffer_extents_too_large(i8* %0, i8* %1, i64 %2, i64 %3) local_unnamed_addr #2 {
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %.split, label %.split2

.split:                                           ; preds = %4
  %7 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.24.61, i32 0, i32 0)) #8
  br label %10

.split2:                                          ; preds = %4
  %8 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %8, align 1, !tbaa !17
  %9 = tail call i8* @halide_string_to_string(i8* nonnull %5, i8* nonnull %8, i8* nonnull getelementptr inbounds ([31 x i8], [31 x i8]* @.str.24.61, i32 0, i32 0)) #8
  br label %10

10:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %7, %.split ], [ %9, %.split2 ]
  %11 = phi i8* [ null, %.split ], [ %8, %.split2 ]
  %12 = icmp eq i8* %1, null
  br i1 %12, label %13, label %15

13:                                               ; preds = %10
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %17

15:                                               ; preds = %10
  %16 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* nonnull %1) #8
  br label %17

17:                                               ; preds = %15, %13
  %18 = phi i8* [ %16, %15 ], [ %14, %13 ]
  %19 = tail call i8* @halide_string_to_string(i8* %18, i8* %11, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.56, i32 0, i32 0)) #8
  %20 = tail call i8* @halide_int64_to_string(i8* %19, i8* %11, i64 %2, i32 1) #8
  %21 = tail call i8* @halide_string_to_string(i8* %20, i8* %11, i8* nonnull getelementptr inbounds ([37 x i8], [37 x i8]* @.str.20.57, i32 0, i32 0)) #8
  %22 = tail call i8* @halide_int64_to_string(i8* %21, i8* %11, i64 %3, i32 1) #8
  br i1 %6, label %23, label %24

23:                                               ; preds = %17
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %31

24:                                               ; preds = %17
  %25 = ptrtoint i8* %22 to i32
  %26 = ptrtoint i8* %5 to i32
  %27 = sub i32 1, %26
  %28 = add i32 %27, %25
  %29 = sext i32 %28 to i64
  %30 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %29) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %31

31:                                               ; preds = %24, %23
  tail call void @free(i8* %5) #8
  ret i32 -6
}

; Function Attrs: nounwind
define weak i32 @halide_error_constraints_make_required_region_smaller(i8* %0, i8* %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6) local_unnamed_addr #2 {
  %8 = add i32 %5, -1
  %9 = add i32 %8, %6
  %10 = add i32 %3, -1
  %11 = add i32 %10, %4
  %12 = tail call i8* @malloc(i32 1024) #8
  %13 = icmp eq i8* %12, null
  br i1 %13, label %.split, label %.split2

.split:                                           ; preds = %7
  %14 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.25.62, i32 0, i32 0)) #8
  br label %17

.split2:                                          ; preds = %7
  %15 = getelementptr inbounds i8, i8* %12, i32 1023
  store i8 0, i8* %15, align 1, !tbaa !17
  %16 = tail call i8* @halide_string_to_string(i8* nonnull %12, i8* nonnull %15, i8* nonnull getelementptr inbounds ([29 x i8], [29 x i8]* @.str.25.62, i32 0, i32 0)) #8
  br label %17

17:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %14, %.split ], [ %16, %.split2 ]
  %18 = phi i8* [ null, %.split ], [ %15, %.split2 ]
  %19 = icmp eq i8* %1, null
  br i1 %19, label %20, label %22

20:                                               ; preds = %17
  %21 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %18, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %24

22:                                               ; preds = %17
  %23 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %18, i8* nonnull %1) #8
  br label %24

24:                                               ; preds = %22, %20
  %25 = phi i8* [ %23, %22 ], [ %21, %20 ]
  %26 = tail call i8* @halide_string_to_string(i8* %25, i8* %18, i8* nonnull getelementptr inbounds ([54 x i8], [54 x i8]* @.str.26.63, i32 0, i32 0)) #8
  %27 = sext i32 %2 to i64
  %28 = tail call i8* @halide_int64_to_string(i8* %26, i8* %18, i64 %27, i32 1) #8
  %29 = tail call i8* @halide_string_to_string(i8* %28, i8* %18, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.27.64, i32 0, i32 0)) #8
  %30 = tail call i8* @halide_string_to_string(i8* %29, i8* %18, i8* nonnull getelementptr inbounds ([16 x i8], [16 x i8]* @.str.28.65, i32 0, i32 0)) #8
  %31 = sext i32 %5 to i64
  %32 = tail call i8* @halide_int64_to_string(i8* %30, i8* %18, i64 %31, i32 1) #8
  %33 = tail call i8* @halide_string_to_string(i8* %32, i8* %18, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.6.43, i32 0, i32 0)) #8
  %34 = sext i32 %9 to i64
  %35 = tail call i8* @halide_int64_to_string(i8* %33, i8* %18, i64 %34, i32 1) #8
  %36 = tail call i8* @halide_string_to_string(i8* %35, i8* %18, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.27.64, i32 0, i32 0)) #8
  %37 = tail call i8* @halide_string_to_string(i8* %36, i8* %18, i8* nonnull getelementptr inbounds ([19 x i8], [19 x i8]* @.str.29.66, i32 0, i32 0)) #8
  %38 = sext i32 %3 to i64
  %39 = tail call i8* @halide_int64_to_string(i8* %37, i8* %18, i64 %38, i32 1) #8
  %40 = tail call i8* @halide_string_to_string(i8* %39, i8* %18, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.6.43, i32 0, i32 0)) #8
  %41 = sext i32 %11 to i64
  %42 = tail call i8* @halide_int64_to_string(i8* %40, i8* %18, i64 %41, i32 1) #8
  %43 = tail call i8* @halide_string_to_string(i8* %42, i8* %18, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str.30.67, i32 0, i32 0)) #8
  br i1 %13, label %44, label %45

44:                                               ; preds = %24
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %52

45:                                               ; preds = %24
  %46 = ptrtoint i8* %43 to i32
  %47 = ptrtoint i8* %12 to i32
  %48 = sub i32 1, %47
  %49 = add i32 %48, %46
  %50 = sext i32 %49 to i64
  %51 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %12, i64 %50) #8
  tail call void @halide_error(i8* %0, i8* nonnull %12) #8
  br label %52

52:                                               ; preds = %45, %44
  tail call void @free(i8* %12) #8
  ret i32 -7
}

; Function Attrs: nounwind
define weak i32 @halide_error_constraint_violated(i8* %0, i8* %1, i32 %2, i8* %3, i32 %4) local_unnamed_addr #2 {
  %6 = tail call i8* @malloc(i32 1024) #8
  %7 = icmp eq i8* %6, null
  br i1 %7, label %.split, label %.split2

.split:                                           ; preds = %5
  %8 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.31.68, i32 0, i32 0)) #8
  br label %11

.split2:                                          ; preds = %5
  %9 = getelementptr inbounds i8, i8* %6, i32 1023
  store i8 0, i8* %9, align 1, !tbaa !17
  %10 = tail call i8* @halide_string_to_string(i8* nonnull %6, i8* nonnull %9, i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.31.68, i32 0, i32 0)) #8
  br label %11

11:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %8, %.split ], [ %10, %.split2 ]
  %12 = phi i8* [ null, %.split ], [ %9, %.split2 ]
  %13 = icmp eq i8* %1, null
  br i1 %13, label %14, label %16

14:                                               ; preds = %11
  %15 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %12, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %18

16:                                               ; preds = %11
  %17 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %12, i8* nonnull %1) #8
  br label %18

18:                                               ; preds = %16, %14
  %19 = phi i8* [ %17, %16 ], [ %15, %14 ]
  %20 = tail call i8* @halide_string_to_string(i8* %19, i8* %12, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32.69, i32 0, i32 0)) #8
  %21 = sext i32 %2 to i64
  %22 = tail call i8* @halide_int64_to_string(i8* %20, i8* %12, i64 %21, i32 1) #8
  %23 = tail call i8* @halide_string_to_string(i8* %22, i8* %12, i8* nonnull getelementptr inbounds ([6 x i8], [6 x i8]* @.str.33.70, i32 0, i32 0)) #8
  %24 = icmp eq i8* %3, null
  br i1 %24, label %25, label %27

25:                                               ; preds = %18
  %26 = tail call i8* @halide_string_to_string(i8* %23, i8* %12, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %29

27:                                               ; preds = %18
  %28 = tail call i8* @halide_string_to_string(i8* %23, i8* %12, i8* nonnull %3) #8
  br label %29

29:                                               ; preds = %27, %25
  %30 = phi i8* [ %28, %27 ], [ %26, %25 ]
  %31 = tail call i8* @halide_string_to_string(i8* %30, i8* %12, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32.69, i32 0, i32 0)) #8
  %32 = sext i32 %4 to i64
  %33 = tail call i8* @halide_int64_to_string(i8* %31, i8* %12, i64 %32, i32 1) #8
  %34 = tail call i8* @halide_string_to_string(i8* %33, i8* %12, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8.45, i32 0, i32 0)) #8
  br i1 %7, label %35, label %36

35:                                               ; preds = %29
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %43

36:                                               ; preds = %29
  %37 = ptrtoint i8* %34 to i32
  %38 = ptrtoint i8* %6 to i32
  %39 = sub i32 1, %38
  %40 = add i32 %39, %37
  %41 = sext i32 %40 to i64
  %42 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %6, i64 %41) #8
  tail call void @halide_error(i8* %0, i8* nonnull %6) #8
  br label %43

43:                                               ; preds = %36, %35
  tail call void @free(i8* %6) #8
  ret i32 -8
}

; Function Attrs: nounwind
define weak i32 @halide_error_param_too_small_i64(i8* %0, i8* %1, i64 %2, i64 %3) local_unnamed_addr #2 {
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %.split, label %.split2

.split:                                           ; preds = %4
  %7 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34.71, i32 0, i32 0)) #8
  br label %10

.split2:                                          ; preds = %4
  %8 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %8, align 1, !tbaa !17
  %9 = tail call i8* @halide_string_to_string(i8* nonnull %5, i8* nonnull %8, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34.71, i32 0, i32 0)) #8
  br label %10

10:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %7, %.split ], [ %9, %.split2 ]
  %11 = phi i8* [ null, %.split ], [ %8, %.split2 ]
  %12 = icmp eq i8* %1, null
  br i1 %12, label %13, label %15

13:                                               ; preds = %10
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %17

15:                                               ; preds = %10
  %16 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* nonnull %1) #8
  br label %17

17:                                               ; preds = %15, %13
  %18 = phi i8* [ %16, %15 ], [ %14, %13 ]
  %19 = tail call i8* @halide_string_to_string(i8* %18, i8* %11, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.56, i32 0, i32 0)) #8
  %20 = tail call i8* @halide_int64_to_string(i8* %19, i8* %11, i64 %2, i32 1) #8
  %21 = tail call i8* @halide_string_to_string(i8* %20, i8* %11, i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.35.72, i32 0, i32 0)) #8
  %22 = tail call i8* @halide_int64_to_string(i8* %21, i8* %11, i64 %3, i32 1) #8
  br i1 %6, label %23, label %24

23:                                               ; preds = %17
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %31

24:                                               ; preds = %17
  %25 = ptrtoint i8* %22 to i32
  %26 = ptrtoint i8* %5 to i32
  %27 = sub i32 1, %26
  %28 = add i32 %27, %25
  %29 = sext i32 %28 to i64
  %30 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %29) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %31

31:                                               ; preds = %24, %23
  tail call void @free(i8* %5) #8
  ret i32 -9
}

; Function Attrs: nounwind
define weak i32 @halide_error_param_too_small_u64(i8* %0, i8* %1, i64 %2, i64 %3) local_unnamed_addr #2 {
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %.split, label %.split2

.split:                                           ; preds = %4
  %7 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34.71, i32 0, i32 0)) #8
  br label %10

.split2:                                          ; preds = %4
  %8 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %8, align 1, !tbaa !17
  %9 = tail call i8* @halide_string_to_string(i8* nonnull %5, i8* nonnull %8, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34.71, i32 0, i32 0)) #8
  br label %10

10:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %7, %.split ], [ %9, %.split2 ]
  %11 = phi i8* [ null, %.split ], [ %8, %.split2 ]
  %12 = icmp eq i8* %1, null
  br i1 %12, label %13, label %15

13:                                               ; preds = %10
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %17

15:                                               ; preds = %10
  %16 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* nonnull %1) #8
  br label %17

17:                                               ; preds = %15, %13
  %18 = phi i8* [ %16, %15 ], [ %14, %13 ]
  %19 = tail call i8* @halide_string_to_string(i8* %18, i8* %11, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.56, i32 0, i32 0)) #8
  %20 = tail call i8* @halide_uint64_to_string(i8* %19, i8* %11, i64 %2, i32 1) #8
  %21 = tail call i8* @halide_string_to_string(i8* %20, i8* %11, i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.35.72, i32 0, i32 0)) #8
  %22 = tail call i8* @halide_uint64_to_string(i8* %21, i8* %11, i64 %3, i32 1) #8
  br i1 %6, label %23, label %24

23:                                               ; preds = %17
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %31

24:                                               ; preds = %17
  %25 = ptrtoint i8* %22 to i32
  %26 = ptrtoint i8* %5 to i32
  %27 = sub i32 1, %26
  %28 = add i32 %27, %25
  %29 = sext i32 %28 to i64
  %30 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %29) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %31

31:                                               ; preds = %24, %23
  tail call void @free(i8* %5) #8
  ret i32 -9
}

; Function Attrs: nounwind
define weak i32 @halide_error_param_too_small_f64(i8* %0, i8* %1, double %2, double %3) local_unnamed_addr #2 {
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %.split, label %.split2

.split:                                           ; preds = %4
  %7 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34.71, i32 0, i32 0)) #8
  br label %10

.split2:                                          ; preds = %4
  %8 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %8, align 1, !tbaa !17
  %9 = tail call i8* @halide_string_to_string(i8* nonnull %5, i8* nonnull %8, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34.71, i32 0, i32 0)) #8
  br label %10

10:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %7, %.split ], [ %9, %.split2 ]
  %11 = phi i8* [ null, %.split ], [ %8, %.split2 ]
  %12 = icmp eq i8* %1, null
  br i1 %12, label %13, label %15

13:                                               ; preds = %10
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %17

15:                                               ; preds = %10
  %16 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* nonnull %1) #8
  br label %17

17:                                               ; preds = %15, %13
  %18 = phi i8* [ %16, %15 ], [ %14, %13 ]
  %19 = tail call i8* @halide_string_to_string(i8* %18, i8* %11, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.56, i32 0, i32 0)) #8
  %20 = tail call i8* @halide_double_to_string(i8* %19, i8* %11, double %2, i32 1) #8
  %21 = tail call i8* @halide_string_to_string(i8* %20, i8* %11, i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.35.72, i32 0, i32 0)) #8
  %22 = tail call i8* @halide_double_to_string(i8* %21, i8* %11, double %3, i32 1) #8
  br i1 %6, label %23, label %24

23:                                               ; preds = %17
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %31

24:                                               ; preds = %17
  %25 = ptrtoint i8* %22 to i32
  %26 = ptrtoint i8* %5 to i32
  %27 = sub i32 1, %26
  %28 = add i32 %27, %25
  %29 = sext i32 %28 to i64
  %30 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %29) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %31

31:                                               ; preds = %24, %23
  tail call void @free(i8* %5) #8
  ret i32 -9
}

; Function Attrs: nounwind
define weak i32 @halide_error_param_too_large_i64(i8* %0, i8* %1, i64 %2, i64 %3) local_unnamed_addr #2 {
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %.split, label %.split2

.split:                                           ; preds = %4
  %7 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34.71, i32 0, i32 0)) #8
  br label %10

.split2:                                          ; preds = %4
  %8 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %8, align 1, !tbaa !17
  %9 = tail call i8* @halide_string_to_string(i8* nonnull %5, i8* nonnull %8, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34.71, i32 0, i32 0)) #8
  br label %10

10:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %7, %.split ], [ %9, %.split2 ]
  %11 = phi i8* [ null, %.split ], [ %8, %.split2 ]
  %12 = icmp eq i8* %1, null
  br i1 %12, label %13, label %15

13:                                               ; preds = %10
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %17

15:                                               ; preds = %10
  %16 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* nonnull %1) #8
  br label %17

17:                                               ; preds = %15, %13
  %18 = phi i8* [ %16, %15 ], [ %14, %13 ]
  %19 = tail call i8* @halide_string_to_string(i8* %18, i8* %11, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.56, i32 0, i32 0)) #8
  %20 = tail call i8* @halide_int64_to_string(i8* %19, i8* %11, i64 %2, i32 1) #8
  %21 = tail call i8* @halide_string_to_string(i8* %20, i8* %11, i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.36.73, i32 0, i32 0)) #8
  %22 = tail call i8* @halide_int64_to_string(i8* %21, i8* %11, i64 %3, i32 1) #8
  br i1 %6, label %23, label %24

23:                                               ; preds = %17
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %31

24:                                               ; preds = %17
  %25 = ptrtoint i8* %22 to i32
  %26 = ptrtoint i8* %5 to i32
  %27 = sub i32 1, %26
  %28 = add i32 %27, %25
  %29 = sext i32 %28 to i64
  %30 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %29) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %31

31:                                               ; preds = %24, %23
  tail call void @free(i8* %5) #8
  ret i32 -10
}

; Function Attrs: nounwind
define weak i32 @halide_error_param_too_large_u64(i8* %0, i8* %1, i64 %2, i64 %3) local_unnamed_addr #2 {
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %.split, label %.split2

.split:                                           ; preds = %4
  %7 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34.71, i32 0, i32 0)) #8
  br label %10

.split2:                                          ; preds = %4
  %8 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %8, align 1, !tbaa !17
  %9 = tail call i8* @halide_string_to_string(i8* nonnull %5, i8* nonnull %8, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34.71, i32 0, i32 0)) #8
  br label %10

10:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %7, %.split ], [ %9, %.split2 ]
  %11 = phi i8* [ null, %.split ], [ %8, %.split2 ]
  %12 = icmp eq i8* %1, null
  br i1 %12, label %13, label %15

13:                                               ; preds = %10
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %17

15:                                               ; preds = %10
  %16 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* nonnull %1) #8
  br label %17

17:                                               ; preds = %15, %13
  %18 = phi i8* [ %16, %15 ], [ %14, %13 ]
  %19 = tail call i8* @halide_string_to_string(i8* %18, i8* %11, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.56, i32 0, i32 0)) #8
  %20 = tail call i8* @halide_uint64_to_string(i8* %19, i8* %11, i64 %2, i32 1) #8
  %21 = tail call i8* @halide_string_to_string(i8* %20, i8* %11, i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.36.73, i32 0, i32 0)) #8
  %22 = tail call i8* @halide_uint64_to_string(i8* %21, i8* %11, i64 %3, i32 1) #8
  br i1 %6, label %23, label %24

23:                                               ; preds = %17
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %31

24:                                               ; preds = %17
  %25 = ptrtoint i8* %22 to i32
  %26 = ptrtoint i8* %5 to i32
  %27 = sub i32 1, %26
  %28 = add i32 %27, %25
  %29 = sext i32 %28 to i64
  %30 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %29) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %31

31:                                               ; preds = %24, %23
  tail call void @free(i8* %5) #8
  ret i32 -10
}

; Function Attrs: nounwind
define weak i32 @halide_error_param_too_large_f64(i8* %0, i8* %1, double %2, double %3) local_unnamed_addr #2 {
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %.split, label %.split2

.split:                                           ; preds = %4
  %7 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34.71, i32 0, i32 0)) #8
  br label %10

.split2:                                          ; preds = %4
  %8 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %8, align 1, !tbaa !17
  %9 = tail call i8* @halide_string_to_string(i8* nonnull %5, i8* nonnull %8, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34.71, i32 0, i32 0)) #8
  br label %10

10:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %7, %.split ], [ %9, %.split2 ]
  %11 = phi i8* [ null, %.split ], [ %8, %.split2 ]
  %12 = icmp eq i8* %1, null
  br i1 %12, label %13, label %15

13:                                               ; preds = %10
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %17

15:                                               ; preds = %10
  %16 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* nonnull %1) #8
  br label %17

17:                                               ; preds = %15, %13
  %18 = phi i8* [ %16, %15 ], [ %14, %13 ]
  %19 = tail call i8* @halide_string_to_string(i8* %18, i8* %11, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.56, i32 0, i32 0)) #8
  %20 = tail call i8* @halide_double_to_string(i8* %19, i8* %11, double %2, i32 1) #8
  %21 = tail call i8* @halide_string_to_string(i8* %20, i8* %11, i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.36.73, i32 0, i32 0)) #8
  %22 = tail call i8* @halide_double_to_string(i8* %21, i8* %11, double %3, i32 1) #8
  br i1 %6, label %23, label %24

23:                                               ; preds = %17
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %31

24:                                               ; preds = %17
  %25 = ptrtoint i8* %22 to i32
  %26 = ptrtoint i8* %5 to i32
  %27 = sub i32 1, %26
  %28 = add i32 %27, %25
  %29 = sext i32 %28 to i64
  %30 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %29) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %31

31:                                               ; preds = %24, %23
  tail call void @free(i8* %5) #8
  ret i32 -10
}

; Function Attrs: nounwind
define weak i32 @halide_error_out_of_memory(i8* %0) local_unnamed_addr #2 {
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.37.74, i32 0, i32 0)) #8
  ret i32 -11
}

; Function Attrs: nounwind
define weak i32 @halide_error_buffer_argument_is_null(i8* %0, i8* %1) local_unnamed_addr #2 {
  %3 = tail call i8* @malloc(i32 1024) #8
  %4 = icmp eq i8* %3, null
  br i1 %4, label %.split, label %.split2

.split:                                           ; preds = %2
  %5 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.38, i32 0, i32 0)) #8
  br label %8

.split2:                                          ; preds = %2
  %6 = getelementptr inbounds i8, i8* %3, i32 1023
  store i8 0, i8* %6, align 1, !tbaa !17
  %7 = tail call i8* @halide_string_to_string(i8* nonnull %3, i8* nonnull %6, i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.38, i32 0, i32 0)) #8
  br label %8

8:                                                ; preds = %.split, %.split2
  %phi.call = phi i8* [ %5, %.split ], [ %7, %.split2 ]
  %9 = phi i8* [ null, %.split ], [ %6, %.split2 ]
  %10 = icmp eq i8* %1, null
  br i1 %10, label %11, label %13

11:                                               ; preds = %8
  %12 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %9, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %15

13:                                               ; preds = %8
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %9, i8* nonnull %1) #8
  br label %15

15:                                               ; preds = %13, %11
  %16 = phi i8* [ %14, %13 ], [ %12, %11 ]
  %17 = tail call i8* @halide_string_to_string(i8* %16, i8* %9, i8* nonnull getelementptr inbounds ([9 x i8], [9 x i8]* @.str.39, i32 0, i32 0)) #8
  br i1 %4, label %18, label %19

18:                                               ; preds = %15
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %26

19:                                               ; preds = %15
  %20 = ptrtoint i8* %17 to i32
  %21 = ptrtoint i8* %3 to i32
  %22 = sub i32 1, %21
  %23 = add i32 %22, %20
  %24 = sext i32 %23 to i64
  %25 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %3, i64 %24) #8
  tail call void @halide_error(i8* %0, i8* nonnull %3) #8
  br label %26

26:                                               ; preds = %19, %18
  tail call void @free(i8* %3) #8
  ret i32 -12
}

; Function Attrs: nounwind
define weak i32 @halide_error_debug_to_file_failed(i8* %0, i8* %1, i8* %2, i32 %3) local_unnamed_addr #2 {
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %.split, label %.split2

.split:                                           ; preds = %4
  %7 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([25 x i8], [25 x i8]* @.str.40, i32 0, i32 0)) #8
  br label %10

.split2:                                          ; preds = %4
  %8 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %8, align 1, !tbaa !17
  %9 = tail call i8* @halide_string_to_string(i8* nonnull %5, i8* nonnull %8, i8* nonnull getelementptr inbounds ([25 x i8], [25 x i8]* @.str.40, i32 0, i32 0)) #8
  br label %10

10:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %7, %.split ], [ %9, %.split2 ]
  %11 = phi i8* [ null, %.split ], [ %8, %.split2 ]
  %12 = icmp eq i8* %1, null
  br i1 %12, label %13, label %15

13:                                               ; preds = %10
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %17

15:                                               ; preds = %10
  %16 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* nonnull %1) #8
  br label %17

17:                                               ; preds = %15, %13
  %18 = phi i8* [ %16, %15 ], [ %14, %13 ]
  %19 = tail call i8* @halide_string_to_string(i8* %18, i8* %11, i8* nonnull getelementptr inbounds ([10 x i8], [10 x i8]* @.str.41, i32 0, i32 0)) #8
  %20 = icmp eq i8* %2, null
  br i1 %20, label %21, label %23

21:                                               ; preds = %17
  %22 = tail call i8* @halide_string_to_string(i8* %19, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %25

23:                                               ; preds = %17
  %24 = tail call i8* @halide_string_to_string(i8* %19, i8* %11, i8* nonnull %2) #8
  br label %25

25:                                               ; preds = %23, %21
  %26 = phi i8* [ %24, %23 ], [ %22, %21 ]
  %27 = tail call i8* @halide_string_to_string(i8* %26, i8* %11, i8* nonnull getelementptr inbounds ([13 x i8], [13 x i8]* @.str.42.75, i32 0, i32 0)) #8
  %28 = sext i32 %3 to i64
  %29 = tail call i8* @halide_int64_to_string(i8* %27, i8* %11, i64 %28, i32 1) #8
  br i1 %6, label %30, label %31

30:                                               ; preds = %25
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %38

31:                                               ; preds = %25
  %32 = ptrtoint i8* %29 to i32
  %33 = ptrtoint i8* %5 to i32
  %34 = sub i32 1, %33
  %35 = add i32 %34, %32
  %36 = sext i32 %35 to i64
  %37 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %36) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %38

38:                                               ; preds = %31, %30
  tail call void @free(i8* %5) #8
  ret i32 -13
}

; Function Attrs: nounwind
define weak i32 @halide_error_unaligned_host_ptr(i8* %0, i8* %1, i32 %2) local_unnamed_addr #2 {
  %4 = tail call i8* @malloc(i32 1024) #8
  %5 = icmp eq i8* %4, null
  br i1 %5, label %.split, label %.split2

.split:                                           ; preds = %3
  %6 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.43, i32 0, i32 0)) #8
  br label %9

.split2:                                          ; preds = %3
  %7 = getelementptr inbounds i8, i8* %4, i32 1023
  store i8 0, i8* %7, align 1, !tbaa !17
  %8 = tail call i8* @halide_string_to_string(i8* nonnull %4, i8* nonnull %7, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.43, i32 0, i32 0)) #8
  br label %9

9:                                                ; preds = %.split, %.split2
  %phi.call = phi i8* [ %6, %.split ], [ %8, %.split2 ]
  %10 = phi i8* [ null, %.split ], [ %7, %.split2 ]
  %11 = icmp eq i8* %1, null
  br i1 %11, label %12, label %14

12:                                               ; preds = %9
  %13 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %10, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %16

14:                                               ; preds = %9
  %15 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %10, i8* nonnull %1) #8
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i8* [ %15, %14 ], [ %13, %12 ]
  %18 = tail call i8* @halide_string_to_string(i8* %17, i8* %10, i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.44, i32 0, i32 0)) #8
  %19 = sext i32 %2 to i64
  %20 = tail call i8* @halide_int64_to_string(i8* %18, i8* %10, i64 %19, i32 1) #8
  %21 = tail call i8* @halide_string_to_string(i8* %20, i8* %10, i8* nonnull getelementptr inbounds ([17 x i8], [17 x i8]* @.str.45, i32 0, i32 0)) #8
  br i1 %5, label %22, label %23

22:                                               ; preds = %16
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %30

23:                                               ; preds = %16
  %24 = ptrtoint i8* %21 to i32
  %25 = ptrtoint i8* %4 to i32
  %26 = sub i32 1, %25
  %27 = add i32 %26, %24
  %28 = sext i32 %27 to i64
  %29 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %4, i64 %28) #8
  tail call void @halide_error(i8* %0, i8* nonnull %4) #8
  br label %30

30:                                               ; preds = %23, %22
  tail call void @free(i8* %4) #8
  ret i32 -24
}

; Function Attrs: nounwind
define weak i32 @halide_error_device_dirty_with_no_device_support(i8* %0, i8* %1) local_unnamed_addr #2 {
  %3 = tail call i8* @malloc(i32 1024) #8
  %4 = icmp eq i8* %3, null
  br i1 %4, label %.split, label %.split2

.split:                                           ; preds = %2
  %5 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.46, i32 0, i32 0)) #8
  br label %8

.split2:                                          ; preds = %2
  %6 = getelementptr inbounds i8, i8* %3, i32 1023
  store i8 0, i8* %6, align 1, !tbaa !17
  %7 = tail call i8* @halide_string_to_string(i8* nonnull %3, i8* nonnull %6, i8* nonnull getelementptr inbounds ([12 x i8], [12 x i8]* @.str.46, i32 0, i32 0)) #8
  br label %8

8:                                                ; preds = %.split, %.split2
  %phi.call = phi i8* [ %5, %.split ], [ %7, %.split2 ]
  %9 = phi i8* [ null, %.split ], [ %6, %.split2 ]
  %10 = icmp eq i8* %1, null
  br i1 %10, label %11, label %13

11:                                               ; preds = %8
  %12 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %9, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %15

13:                                               ; preds = %8
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %9, i8* nonnull %1) #8
  br label %15

15:                                               ; preds = %13, %11
  %16 = phi i8* [ %14, %13 ], [ %12, %11 ]
  %17 = tail call i8* @halide_string_to_string(i8* %16, i8* %9, i8* nonnull getelementptr inbounds ([53 x i8], [53 x i8]* @.str.47, i32 0, i32 0)) #8
  %18 = tail call i8* @halide_string_to_string(i8* %17, i8* %9, i8* nonnull getelementptr inbounds ([43 x i8], [43 x i8]* @.str.48, i32 0, i32 0)) #8
  br i1 %4, label %19, label %20

19:                                               ; preds = %15
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %27

20:                                               ; preds = %15
  %21 = ptrtoint i8* %18 to i32
  %22 = ptrtoint i8* %3 to i32
  %23 = sub i32 1, %22
  %24 = add i32 %23, %21
  %25 = sext i32 %24 to i64
  %26 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %3, i64 %25) #8
  tail call void @halide_error(i8* %0, i8* nonnull %3) #8
  br label %27

27:                                               ; preds = %20, %19
  tail call void @free(i8* %3) #8
  ret i32 -44
}

; Function Attrs: nounwind
define weak i32 @halide_error_host_is_null(i8* %0, i8* %1) local_unnamed_addr #2 {
  %3 = tail call i8* @malloc(i32 1024) #8
  %4 = icmp eq i8* %3, null
  br i1 %4, label %.split, label %.split2

.split:                                           ; preds = %2
  %5 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.43, i32 0, i32 0)) #8
  br label %8

.split2:                                          ; preds = %2
  %6 = getelementptr inbounds i8, i8* %3, i32 1023
  store i8 0, i8* %6, align 1, !tbaa !17
  %7 = tail call i8* @halide_string_to_string(i8* nonnull %3, i8* nonnull %6, i8* nonnull getelementptr inbounds ([21 x i8], [21 x i8]* @.str.43, i32 0, i32 0)) #8
  br label %8

8:                                                ; preds = %.split, %.split2
  %phi.call = phi i8* [ %5, %.split ], [ %7, %.split2 ]
  %9 = phi i8* [ null, %.split ], [ %6, %.split2 ]
  %10 = icmp eq i8* %1, null
  br i1 %10, label %11, label %13

11:                                               ; preds = %8
  %12 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %9, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %15

13:                                               ; preds = %8
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %9, i8* nonnull %1) #8
  br label %15

15:                                               ; preds = %13, %11
  %16 = phi i8* [ %14, %13 ], [ %12, %11 ]
  %17 = tail call i8* @halide_string_to_string(i8* %16, i8* %9, i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.49, i32 0, i32 0)) #8
  br i1 %4, label %18, label %19

18:                                               ; preds = %15
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %26

19:                                               ; preds = %15
  %20 = ptrtoint i8* %17 to i32
  %21 = ptrtoint i8* %3 to i32
  %22 = sub i32 1, %21
  %23 = add i32 %22, %20
  %24 = sext i32 %23 to i64
  %25 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %3, i64 %24) #8
  tail call void @halide_error(i8* %0, i8* nonnull %3) #8
  br label %26

26:                                               ; preds = %19, %18
  tail call void @free(i8* %3) #8
  ret i32 -34
}

; Function Attrs: nounwind
define weak i32 @halide_error_bad_fold(i8* %0, i8* %1, i8* %2, i8* %3) local_unnamed_addr #2 {
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %.split, label %.split2

.split:                                           ; preds = %4
  %7 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([30 x i8], [30 x i8]* @.str.50, i32 0, i32 0)) #8
  br label %10

.split2:                                          ; preds = %4
  %8 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %8, align 1, !tbaa !17
  %9 = tail call i8* @halide_string_to_string(i8* nonnull %5, i8* nonnull %8, i8* nonnull getelementptr inbounds ([30 x i8], [30 x i8]* @.str.50, i32 0, i32 0)) #8
  br label %10

10:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %7, %.split ], [ %9, %.split2 ]
  %11 = phi i8* [ null, %.split ], [ %8, %.split2 ]
  %12 = icmp eq i8* %2, null
  br i1 %12, label %13, label %15

13:                                               ; preds = %10
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %17

15:                                               ; preds = %10
  %16 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %11, i8* nonnull %2) #8
  br label %17

17:                                               ; preds = %15, %13
  %18 = phi i8* [ %16, %15 ], [ %14, %13 ]
  %19 = tail call i8* @halide_string_to_string(i8* %18, i8* %11, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.51, i32 0, i32 0)) #8
  %20 = icmp eq i8* %1, null
  br i1 %20, label %21, label %23

21:                                               ; preds = %17
  %22 = tail call i8* @halide_string_to_string(i8* %19, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %25

23:                                               ; preds = %17
  %24 = tail call i8* @halide_string_to_string(i8* %19, i8* %11, i8* nonnull %1) #8
  br label %25

25:                                               ; preds = %23, %21
  %26 = phi i8* [ %24, %23 ], [ %22, %21 ]
  %27 = tail call i8* @halide_string_to_string(i8* %26, i8* %11, i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.52, i32 0, i32 0)) #8
  %28 = icmp eq i8* %3, null
  br i1 %28, label %29, label %31

29:                                               ; preds = %25
  %30 = tail call i8* @halide_string_to_string(i8* %27, i8* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %33

31:                                               ; preds = %25
  %32 = tail call i8* @halide_string_to_string(i8* %27, i8* %11, i8* nonnull %3) #8
  br label %33

33:                                               ; preds = %31, %29
  %34 = phi i8* [ %32, %31 ], [ %30, %29 ]
  %35 = tail call i8* @halide_string_to_string(i8* %34, i8* %11, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str.30.67, i32 0, i32 0)) #8
  br i1 %6, label %36, label %37

36:                                               ; preds = %33
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %44

37:                                               ; preds = %33
  %38 = ptrtoint i8* %35 to i32
  %39 = ptrtoint i8* %5 to i32
  %40 = sub i32 1, %39
  %41 = add i32 %40, %38
  %42 = sext i32 %41 to i64
  %43 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %42) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %44

44:                                               ; preds = %37, %36
  tail call void @free(i8* %5) #8
  ret i32 -25
}

; Function Attrs: nounwind
define weak i32 @halide_error_bad_extern_fold(i8* %0, i8* %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6) local_unnamed_addr #2 {
  %8 = icmp slt i32 %3, %5
  br i1 %8, label %13, label %9

9:                                                ; preds = %7
  %10 = add nsw i32 %4, %3
  %11 = add nsw i32 %6, %5
  %12 = icmp sgt i32 %10, %11
  br i1 %12, label %13, label %57

13:                                               ; preds = %9, %7
  %14 = tail call i8* @malloc(i32 1024) #8
  %15 = icmp eq i8* %14, null
  br i1 %15, label %.split, label %.split2

.split:                                           ; preds = %13
  %16 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.53, i32 0, i32 0)) #8
  br label %19

.split2:                                          ; preds = %13
  %17 = getelementptr inbounds i8, i8* %14, i32 1023
  store i8 0, i8* %17, align 1, !tbaa !17
  %18 = tail call i8* @halide_string_to_string(i8* nonnull %14, i8* nonnull %17, i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.53, i32 0, i32 0)) #8
  br label %19

19:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %16, %.split ], [ %18, %.split2 ]
  %20 = phi i8* [ null, %.split ], [ %17, %.split2 ]
  %21 = sext i32 %2 to i64
  %22 = tail call i8* @halide_int64_to_string(i8* %phi.call, i8* %20, i64 %21, i32 1) #8
  %23 = tail call i8* @halide_string_to_string(i8* %22, i8* %20, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.51, i32 0, i32 0)) #8
  %24 = icmp eq i8* %1, null
  br i1 %24, label %25, label %27

25:                                               ; preds = %19
  %26 = tail call i8* @halide_string_to_string(i8* %23, i8* %20, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %29

27:                                               ; preds = %19
  %28 = tail call i8* @halide_string_to_string(i8* %23, i8* %20, i8* nonnull %1) #8
  br label %29

29:                                               ; preds = %27, %25
  %30 = phi i8* [ %28, %27 ], [ %26, %25 ]
  %31 = tail call i8* @halide_string_to_string(i8* %30, i8* %20, i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.54, i32 0, i32 0)) #8
  %32 = sext i32 %3 to i64
  %33 = tail call i8* @halide_int64_to_string(i8* %31, i8* %20, i64 %32, i32 1) #8
  %34 = tail call i8* @halide_string_to_string(i8* %33, i8* %20, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.55, i32 0, i32 0)) #8
  %35 = add nsw i32 %4, %3
  %36 = add nsw i32 %35, -1
  %37 = sext i32 %36 to i64
  %38 = tail call i8* @halide_int64_to_string(i8* %34, i8* %20, i64 %37, i32 1) #8
  %39 = tail call i8* @halide_string_to_string(i8* %38, i8* %20, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.56, i32 0, i32 0)) #8
  %40 = tail call i8* @halide_string_to_string(i8* %39, i8* %20, i8* nonnull getelementptr inbounds ([47 x i8], [47 x i8]* @.str.57, i32 0, i32 0)) #8
  %41 = sext i32 %5 to i64
  %42 = tail call i8* @halide_int64_to_string(i8* %40, i8* %20, i64 %41, i32 1) #8
  %43 = tail call i8* @halide_string_to_string(i8* %42, i8* %20, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.55, i32 0, i32 0)) #8
  %44 = add nsw i32 %6, %5
  %45 = add nsw i32 %44, -1
  %46 = sext i32 %45 to i64
  %47 = tail call i8* @halide_int64_to_string(i8* %43, i8* %20, i64 %46, i32 1) #8
  %48 = tail call i8* @halide_string_to_string(i8* %47, i8* %20, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.58.76, i32 0, i32 0)) #8
  br i1 %15, label %49, label %50

49:                                               ; preds = %29
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %96

50:                                               ; preds = %29
  %51 = ptrtoint i8* %48 to i32
  %52 = ptrtoint i8* %14 to i32
  %53 = sub i32 1, %52
  %54 = add i32 %53, %51
  %55 = sext i32 %54 to i64
  %56 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %14, i64 %55) #8
  tail call void @halide_error(i8* %0, i8* nonnull %14) #8
  br label %96

57:                                               ; preds = %9
  %58 = tail call i8* @malloc(i32 1024) #8
  %59 = icmp eq i8* %58, null
  br i1 %59, label %.split3, label %.split5

.split3:                                          ; preds = %57
  %60 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.53, i32 0, i32 0)) #8
  br label %63

.split5:                                          ; preds = %57
  %61 = getelementptr inbounds i8, i8* %58, i32 1023
  store i8 0, i8* %61, align 1, !tbaa !17
  %62 = tail call i8* @halide_string_to_string(i8* nonnull %58, i8* nonnull %61, i8* nonnull getelementptr inbounds ([23 x i8], [23 x i8]* @.str.53, i32 0, i32 0)) #8
  br label %63

63:                                               ; preds = %.split3, %.split5
  %phi.call6 = phi i8* [ %60, %.split3 ], [ %62, %.split5 ]
  %64 = phi i8* [ null, %.split3 ], [ %61, %.split5 ]
  %65 = sext i32 %2 to i64
  %66 = tail call i8* @halide_int64_to_string(i8* %phi.call6, i8* %64, i64 %65, i32 1) #8
  %67 = tail call i8* @halide_string_to_string(i8* %66, i8* %64, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.51, i32 0, i32 0)) #8
  %68 = icmp eq i8* %1, null
  br i1 %68, label %69, label %71

69:                                               ; preds = %63
  %70 = tail call i8* @halide_string_to_string(i8* %67, i8* %64, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %73

71:                                               ; preds = %63
  %72 = tail call i8* @halide_string_to_string(i8* %67, i8* %64, i8* nonnull %1) #8
  br label %73

73:                                               ; preds = %71, %69
  %74 = phi i8* [ %72, %71 ], [ %70, %69 ]
  %75 = tail call i8* @halide_string_to_string(i8* %74, i8* %64, i8* nonnull getelementptr inbounds ([36 x i8], [36 x i8]* @.str.54, i32 0, i32 0)) #8
  %76 = sext i32 %3 to i64
  %77 = tail call i8* @halide_int64_to_string(i8* %75, i8* %64, i64 %76, i32 1) #8
  %78 = tail call i8* @halide_string_to_string(i8* %77, i8* %64, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.55, i32 0, i32 0)) #8
  %79 = add nsw i32 %10, -1
  %80 = sext i32 %79 to i64
  %81 = tail call i8* @halide_int64_to_string(i8* %78, i8* %64, i64 %80, i32 1) #8
  %82 = tail call i8* @halide_string_to_string(i8* %81, i8* %64, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.56, i32 0, i32 0)) #8
  %83 = tail call i8* @halide_string_to_string(i8* %82, i8* %64, i8* nonnull getelementptr inbounds ([47 x i8], [47 x i8]* @.str.59.77, i32 0, i32 0)) #8
  %84 = tail call i8* @halide_string_to_string(i8* %83, i8* %64, i8* nonnull getelementptr inbounds ([30 x i8], [30 x i8]* @.str.60.78, i32 0, i32 0)) #8
  %85 = sext i32 %6 to i64
  %86 = tail call i8* @halide_int64_to_string(i8* %84, i8* %64, i64 %85, i32 1) #8
  %87 = tail call i8* @halide_string_to_string(i8* %86, i8* %64, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str.30.67, i32 0, i32 0)) #8
  br i1 %59, label %88, label %89

88:                                               ; preds = %73
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %96

89:                                               ; preds = %73
  %90 = ptrtoint i8* %87 to i32
  %91 = ptrtoint i8* %58 to i32
  %92 = sub i32 1, %91
  %93 = add i32 %92, %90
  %94 = sext i32 %93 to i64
  %95 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %58, i64 %94) #8
  tail call void @halide_error(i8* %0, i8* nonnull %58) #8
  br label %96

96:                                               ; preds = %89, %88, %50, %49
  %97 = phi i8* [ null, %49 ], [ %14, %50 ], [ null, %88 ], [ %58, %89 ]
  tail call void @free(i8* %97) #8
  ret i32 -35
}

; Function Attrs: nounwind
define weak i32 @halide_error_fold_factor_too_small(i8* %0, i8* %1, i8* %2, i32 %3, i8* %4, i32 %5) local_unnamed_addr #2 {
  %7 = tail call i8* @malloc(i32 1024) #8
  %8 = icmp eq i8* %7, null
  br i1 %8, label %.split, label %.split2

.split:                                           ; preds = %6
  %9 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.61.79, i32 0, i32 0)) #8
  br label %12

.split2:                                          ; preds = %6
  %10 = getelementptr inbounds i8, i8* %7, i32 1023
  store i8 0, i8* %10, align 1, !tbaa !17
  %11 = tail call i8* @halide_string_to_string(i8* nonnull %7, i8* nonnull %10, i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.61.79, i32 0, i32 0)) #8
  br label %12

12:                                               ; preds = %.split, %.split2
  %phi.call = phi i8* [ %9, %.split ], [ %11, %.split2 ]
  %13 = phi i8* [ null, %.split ], [ %10, %.split2 ]
  %14 = sext i32 %3 to i64
  %15 = tail call i8* @halide_int64_to_string(i8* %phi.call, i8* %13, i64 %14, i32 1) #8
  %16 = tail call i8* @halide_string_to_string(i8* %15, i8* %13, i8* nonnull getelementptr inbounds ([16 x i8], [16 x i8]* @.str.62, i32 0, i32 0)) #8
  %17 = icmp eq i8* %2, null
  br i1 %17, label %18, label %20

18:                                               ; preds = %12
  %19 = tail call i8* @halide_string_to_string(i8* %16, i8* %13, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %22

20:                                               ; preds = %12
  %21 = tail call i8* @halide_string_to_string(i8* %16, i8* %13, i8* nonnull %2) #8
  br label %22

22:                                               ; preds = %20, %18
  %23 = phi i8* [ %21, %20 ], [ %19, %18 ]
  %24 = tail call i8* @halide_string_to_string(i8* %23, i8* %13, i8* nonnull getelementptr inbounds ([5 x i8], [5 x i8]* @.str.51, i32 0, i32 0)) #8
  %25 = icmp eq i8* %1, null
  br i1 %25, label %26, label %28

26:                                               ; preds = %22
  %27 = tail call i8* @halide_string_to_string(i8* %24, i8* %13, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %30

28:                                               ; preds = %22
  %29 = tail call i8* @halide_string_to_string(i8* %24, i8* %13, i8* nonnull %1) #8
  br label %30

30:                                               ; preds = %28, %26
  %31 = phi i8* [ %29, %28 ], [ %27, %26 ]
  %32 = tail call i8* @halide_string_to_string(i8* %31, i8* %13, i8* nonnull getelementptr inbounds ([61 x i8], [61 x i8]* @.str.63, i32 0, i32 0)) #8
  %33 = icmp eq i8* %4, null
  br i1 %33, label %34, label %36

34:                                               ; preds = %30
  %35 = tail call i8* @halide_string_to_string(i8* %32, i8* %13, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %38

36:                                               ; preds = %30
  %37 = tail call i8* @halide_string_to_string(i8* %32, i8* %13, i8* nonnull %4) #8
  br label %38

38:                                               ; preds = %36, %34
  %39 = phi i8* [ %37, %36 ], [ %35, %34 ]
  %40 = tail call i8* @halide_string_to_string(i8* %39, i8* %13, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32.69, i32 0, i32 0)) #8
  %41 = sext i32 %5 to i64
  %42 = tail call i8* @halide_int64_to_string(i8* %40, i8* %13, i64 %41, i32 1) #8
  %43 = tail call i8* @halide_string_to_string(i8* %42, i8* %13, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.64.80, i32 0, i32 0)) #8
  br i1 %8, label %44, label %45

44:                                               ; preds = %38
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %52

45:                                               ; preds = %38
  %46 = ptrtoint i8* %43 to i32
  %47 = ptrtoint i8* %7 to i32
  %48 = sub i32 1, %47
  %49 = add i32 %48, %46
  %50 = sext i32 %49 to i64
  %51 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %7, i64 %50) #8
  tail call void @halide_error(i8* %0, i8* nonnull %7) #8
  br label %52

52:                                               ; preds = %45, %44
  tail call void @free(i8* %7) #8
  ret i32 -26
}

; Function Attrs: nounwind
define weak i32 @halide_error_requirement_failed(i8* %0, i8* %1, i8* %2) local_unnamed_addr #2 {
  %4 = tail call i8* @malloc(i32 1024) #8
  %5 = icmp eq i8* %4, null
  br i1 %5, label %.split, label %.split2

.split:                                           ; preds = %3
  %6 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.65, i32 0, i32 0)) #8
  br label %9

.split2:                                          ; preds = %3
  %7 = getelementptr inbounds i8, i8* %4, i32 1023
  store i8 0, i8* %7, align 1, !tbaa !17
  %8 = tail call i8* @halide_string_to_string(i8* nonnull %4, i8* nonnull %7, i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.65, i32 0, i32 0)) #8
  br label %9

9:                                                ; preds = %.split, %.split2
  %phi.call = phi i8* [ %6, %.split ], [ %8, %.split2 ]
  %10 = phi i8* [ null, %.split ], [ %7, %.split2 ]
  %11 = icmp eq i8* %1, null
  br i1 %11, label %12, label %14

12:                                               ; preds = %9
  %13 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %10, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %16

14:                                               ; preds = %9
  %15 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %10, i8* nonnull %1) #8
  br label %16

16:                                               ; preds = %14, %12
  %17 = phi i8* [ %15, %14 ], [ %13, %12 ]
  %18 = tail call i8* @halide_string_to_string(i8* %17, i8* %10, i8* nonnull getelementptr inbounds ([3 x i8], [3 x i8]* @.str.66, i32 0, i32 0)) #8
  %19 = icmp eq i8* %2, null
  br i1 %19, label %20, label %22

20:                                               ; preds = %16
  %21 = tail call i8* @halide_string_to_string(i8* %18, i8* %10, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %24

22:                                               ; preds = %16
  %23 = tail call i8* @halide_string_to_string(i8* %18, i8* %10, i8* nonnull %2) #8
  br label %24

24:                                               ; preds = %22, %20
  %25 = phi i8* [ %23, %22 ], [ %21, %20 ]
  br i1 %5, label %26, label %27

26:                                               ; preds = %24
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %34

27:                                               ; preds = %24
  %28 = ptrtoint i8* %25 to i32
  %29 = ptrtoint i8* %4 to i32
  %30 = sub i32 1, %29
  %31 = add i32 %30, %28
  %32 = sext i32 %31 to i64
  %33 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %4, i64 %32) #8
  tail call void @halide_error(i8* %0, i8* nonnull %4) #8
  br label %34

34:                                               ; preds = %27, %26
  tail call void @free(i8* %4) #8
  ret i32 -27
}

; Function Attrs: nounwind
define weak i32 @halide_error_specialize_fail(i8* %0, i8* %1) local_unnamed_addr #2 {
  %3 = tail call i8* @malloc(i32 1024) #8
  %4 = icmp eq i8* %3, null
  br i1 %4, label %.split, label %.split2

.split:                                           ; preds = %2
  %5 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.67, i32 0, i32 0)) #8
  br label %8

.split2:                                          ; preds = %2
  %6 = getelementptr inbounds i8, i8* %3, i32 1023
  store i8 0, i8* %6, align 1, !tbaa !17
  %7 = tail call i8* @halide_string_to_string(i8* nonnull %3, i8* nonnull %6, i8* nonnull getelementptr inbounds ([59 x i8], [59 x i8]* @.str.67, i32 0, i32 0)) #8
  br label %8

8:                                                ; preds = %.split, %.split2
  %phi.call = phi i8* [ %5, %.split ], [ %7, %.split2 ]
  %9 = phi i8* [ null, %.split ], [ %6, %.split2 ]
  %10 = icmp eq i8* %1, null
  br i1 %10, label %11, label %13

11:                                               ; preds = %8
  %12 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %9, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %15

13:                                               ; preds = %8
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %9, i8* nonnull %1) #8
  br label %15

15:                                               ; preds = %13, %11
  %16 = phi i8* [ %14, %13 ], [ %12, %11 ]
  br i1 %4, label %17, label %18

17:                                               ; preds = %15
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %25

18:                                               ; preds = %15
  %19 = ptrtoint i8* %16 to i32
  %20 = ptrtoint i8* %3 to i32
  %21 = sub i32 1, %20
  %22 = add i32 %21, %19
  %23 = sext i32 %22 to i64
  %24 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %3, i64 %23) #8
  tail call void @halide_error(i8* %0, i8* nonnull %3) #8
  br label %25

25:                                               ; preds = %18, %17
  tail call void @free(i8* %3) #8
  ret i32 -31
}

; Function Attrs: nounwind
define weak i32 @halide_error_no_device_interface(i8* %0) local_unnamed_addr #2 {
  %2 = tail call i8* @malloc(i32 1024) #8
  %3 = icmp eq i8* %2, null
  br i1 %3, label %4, label %6

4:                                                ; preds = %1
  %5 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.68, i32 0, i32 0)) #8
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %15

6:                                                ; preds = %1
  %7 = getelementptr inbounds i8, i8* %2, i32 1023
  store i8 0, i8* %7, align 1, !tbaa !17
  %8 = tail call i8* @halide_string_to_string(i8* nonnull %2, i8* nonnull %7, i8* nonnull getelementptr inbounds ([55 x i8], [55 x i8]* @.str.68, i32 0, i32 0)) #8
  %9 = ptrtoint i8* %8 to i32
  %10 = ptrtoint i8* %2 to i32
  %11 = sub i32 1, %10
  %12 = add i32 %11, %9
  %13 = sext i32 %12 to i64
  %14 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %2, i64 %13) #8
  tail call void @halide_error(i8* %0, i8* nonnull %2) #8
  br label %15

15:                                               ; preds = %6, %4
  tail call void @free(i8* %2) #8
  ret i32 -19
}

; Function Attrs: nounwind
define weak i32 @halide_error_device_interface_no_device(i8* %0) local_unnamed_addr #2 {
  %2 = tail call i8* @malloc(i32 1024) #8
  %3 = icmp eq i8* %2, null
  br i1 %3, label %4, label %6

4:                                                ; preds = %1
  %5 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([57 x i8], [57 x i8]* @.str.69, i32 0, i32 0)) #8
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %15

6:                                                ; preds = %1
  %7 = getelementptr inbounds i8, i8* %2, i32 1023
  store i8 0, i8* %7, align 1, !tbaa !17
  %8 = tail call i8* @halide_string_to_string(i8* nonnull %2, i8* nonnull %7, i8* nonnull getelementptr inbounds ([57 x i8], [57 x i8]* @.str.69, i32 0, i32 0)) #8
  %9 = ptrtoint i8* %8 to i32
  %10 = ptrtoint i8* %2 to i32
  %11 = sub i32 1, %10
  %12 = add i32 %11, %9
  %13 = sext i32 %12 to i64
  %14 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %2, i64 %13) #8
  tail call void @halide_error(i8* %0, i8* nonnull %2) #8
  br label %15

15:                                               ; preds = %6, %4
  tail call void @free(i8* %2) #8
  ret i32 -36
}

; Function Attrs: nounwind
define weak i32 @halide_error_host_and_device_dirty(i8* %0) local_unnamed_addr #2 {
  %2 = tail call i8* @malloc(i32 1024) #8
  %3 = icmp eq i8* %2, null
  br i1 %3, label %4, label %6

4:                                                ; preds = %1
  %5 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([49 x i8], [49 x i8]* @.str.70, i32 0, i32 0)) #8
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %15

6:                                                ; preds = %1
  %7 = getelementptr inbounds i8, i8* %2, i32 1023
  store i8 0, i8* %7, align 1, !tbaa !17
  %8 = tail call i8* @halide_string_to_string(i8* nonnull %2, i8* nonnull %7, i8* nonnull getelementptr inbounds ([49 x i8], [49 x i8]* @.str.70, i32 0, i32 0)) #8
  %9 = ptrtoint i8* %8 to i32
  %10 = ptrtoint i8* %2 to i32
  %11 = sub i32 1, %10
  %12 = add i32 %11, %9
  %13 = sext i32 %12 to i64
  %14 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %2, i64 %13) #8
  tail call void @halide_error(i8* %0, i8* nonnull %2) #8
  br label %15

15:                                               ; preds = %6, %4
  tail call void @free(i8* %2) #8
  ret i32 -37
}

; Function Attrs: nounwind
define weak i32 @halide_error_buffer_is_null(i8* %0, i8* %1) local_unnamed_addr #2 {
  %3 = tail call i8* @malloc(i32 1024) #8
  %4 = icmp eq i8* %3, null
  br i1 %4, label %.split, label %.split2

.split:                                           ; preds = %2
  %5 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([26 x i8], [26 x i8]* @.str.71, i32 0, i32 0)) #8
  br label %8

.split2:                                          ; preds = %2
  %6 = getelementptr inbounds i8, i8* %3, i32 1023
  store i8 0, i8* %6, align 1, !tbaa !17
  %7 = tail call i8* @halide_string_to_string(i8* nonnull %3, i8* nonnull %6, i8* nonnull getelementptr inbounds ([26 x i8], [26 x i8]* @.str.71, i32 0, i32 0)) #8
  br label %8

8:                                                ; preds = %.split, %.split2
  %phi.call = phi i8* [ %5, %.split ], [ %7, %.split2 ]
  %9 = phi i8* [ null, %.split ], [ %6, %.split2 ]
  %10 = icmp eq i8* %1, null
  br i1 %10, label %11, label %13

11:                                               ; preds = %8
  %12 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %9, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.74, i32 0, i32 0)) #8
  br label %15

13:                                               ; preds = %8
  %14 = tail call i8* @halide_string_to_string(i8* %phi.call, i8* %9, i8* nonnull %1) #8
  br label %15

15:                                               ; preds = %13, %11
  %16 = phi i8* [ %14, %13 ], [ %12, %11 ]
  %17 = tail call i8* @halide_string_to_string(i8* %16, i8* %9, i8* nonnull getelementptr inbounds ([11 x i8], [11 x i8]* @.str.72, i32 0, i32 0)) #8
  br i1 %4, label %18, label %19

18:                                               ; preds = %15
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %26

19:                                               ; preds = %15
  %20 = ptrtoint i8* %17 to i32
  %21 = ptrtoint i8* %3 to i32
  %22 = sub i32 1, %21
  %23 = add i32 %22, %20
  %24 = sext i32 %23 to i64
  %25 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %3, i64 %24) #8
  tail call void @halide_error(i8* %0, i8* nonnull %3) #8
  br label %26

26:                                               ; preds = %19, %18
  tail call void @free(i8* %3) #8
  ret i32 -38
}

; Function Attrs: nounwind
define weak i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* %1, i64 %2) local_unnamed_addr #2 {
  ret i32 0
}

; Function Attrs: nounwind
define weak i32 @halide_msan_check_memory_is_initialized(i8* %0, i8* %1, i64 %2, i8* %3) local_unnamed_addr #2 {
  ret i32 0
}

; Function Attrs: nounwind
define weak i32 @halide_msan_check_buffer_is_initialized(i8* %0, %struct.halide_buffer_t* %1, i8* %2) local_unnamed_addr #2 {
  ret i32 0
}

; Function Attrs: nounwind
define weak i32 @halide_msan_annotate_buffer_is_initialized(i8* %0, %struct.halide_buffer_t* %1) local_unnamed_addr #2 {
  ret i32 0
}

; Function Attrs: nounwind
define weak void @halide_msan_annotate_buffer_is_initialized_as_destructor(i8* %0, i8* %1) local_unnamed_addr #2 {
  ret void
}

; Function Attrs: nounwind
define weak i32 @halide_qurt_hvx_lock(i8* %0, i32 %1) local_unnamed_addr #2 {
  switch i32 %1, label %4 [
    i32 64, label %18
    i32 128, label %3
  ]

3:                                                ; preds = %2
  br label %18

4:                                                ; preds = %2
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %7, label %9

7:                                                ; preds = %4
  %8 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([34 x i8], [34 x i8]* @.str.93, i32 0, i32 0)) #8
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %36

9:                                                ; preds = %4
  %10 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %10, align 1, !tbaa !17
  %11 = tail call i8* @halide_string_to_string(i8* nonnull %5, i8* nonnull %10, i8* nonnull getelementptr inbounds ([34 x i8], [34 x i8]* @.str.93, i32 0, i32 0)) #8
  %12 = ptrtoint i8* %11 to i32
  %13 = ptrtoint i8* %5 to i32
  %14 = sub i32 1, %13
  %15 = add i32 %14, %12
  %16 = sext i32 %15 to i64
  %17 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %16) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %36

18:                                               ; preds = %3, %2
  %19 = phi i32 [ 1, %3 ], [ 0, %2 ]
  %20 = tail call i32 @qurt_hvx_lock(i32 %19) #8
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %38, label %22

22:                                               ; preds = %18
  %23 = tail call i8* @malloc(i32 1024) #8
  %24 = icmp eq i8* %23, null
  br i1 %24, label %25, label %27

25:                                               ; preds = %22
  %26 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5.95, i32 0, i32 0)) #8
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %36

27:                                               ; preds = %22
  %28 = getelementptr inbounds i8, i8* %23, i32 1023
  store i8 0, i8* %28, align 1, !tbaa !17
  %29 = tail call i8* @halide_string_to_string(i8* nonnull %23, i8* nonnull %28, i8* nonnull getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5.95, i32 0, i32 0)) #8
  %30 = ptrtoint i8* %29 to i32
  %31 = ptrtoint i8* %23 to i32
  %32 = sub i32 1, %31
  %33 = add i32 %32, %30
  %34 = sext i32 %33 to i64
  %35 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %23, i64 %34) #8
  tail call void @halide_error(i8* %0, i8* nonnull %23) #8
  br label %36

36:                                               ; preds = %27, %25, %9, %7
  %37 = phi i8* [ %5, %9 ], [ null, %7 ], [ %23, %27 ], [ null, %25 ]
  tail call void @free(i8* %37) #8
  br label %38

38:                                               ; preds = %36, %18
  %39 = phi i32 [ 0, %18 ], [ -1, %36 ]
  ret i32 %39
}

declare i32 @qurt_hvx_lock(i32 %0) local_unnamed_addr #1

; Function Attrs: nounwind
define weak i32 @halide_qurt_hvx_unlock(i8* %0) local_unnamed_addr #2 {
  %2 = tail call i32 @qurt_hvx_unlock() #8
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %19, label %4

4:                                                ; preds = %1
  %5 = tail call i8* @malloc(i32 1024) #8
  %6 = icmp eq i8* %5, null
  br i1 %6, label %7, label %9

7:                                                ; preds = %4
  %8 = tail call i8* @halide_string_to_string(i8* null, i8* null, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.7.96, i32 0, i32 0)) #8
  tail call void @halide_error(i8* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8.94, i32 0, i32 0)) #8
  br label %18

9:                                                ; preds = %4
  %10 = getelementptr inbounds i8, i8* %5, i32 1023
  store i8 0, i8* %10, align 1, !tbaa !17
  %11 = tail call i8* @halide_string_to_string(i8* nonnull %5, i8* nonnull %10, i8* nonnull getelementptr inbounds ([24 x i8], [24 x i8]* @.str.7.96, i32 0, i32 0)) #8
  %12 = ptrtoint i8* %11 to i32
  %13 = ptrtoint i8* %5 to i32
  %14 = sub i32 1, %13
  %15 = add i32 %14, %12
  %16 = sext i32 %15 to i64
  %17 = tail call i32 @halide_msan_annotate_memory_is_initialized(i8* %0, i8* nonnull %5, i64 %16) #8
  tail call void @halide_error(i8* %0, i8* nonnull %5) #8
  br label %18

18:                                               ; preds = %9, %7
  tail call void @free(i8* %5) #8
  br label %19

19:                                               ; preds = %18, %1
  %20 = phi i32 [ -1, %18 ], [ 0, %1 ]
  ret i32 %20
}

declare i32 @qurt_hvx_unlock() local_unnamed_addr #1

; Function Attrs: nounwind
define weak void @halide_qurt_hvx_unlock_as_destructor(i8* %0, i8* %1) local_unnamed_addr #2 {
  %3 = tail call i32 @halide_qurt_hvx_unlock(i8* %0) #9
  ret void
}

; Function Attrs: nounwind
define weak i32 @halide_default_can_use_target_features(i32 %0, i64* %1) #2 {
  %3 = alloca %"struct.Halide::Runtime::Internal::CpuFeatures", align 8
  tail call void @halide_mutex_lock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal36halide_cpu_features_initialized_lockE) #8
  %4 = load i8, i8* @_ZN6Halide7Runtime8Internal31halide_cpu_features_initializedE, align 1, !tbaa !14, !range !16
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %6, label %9

6:                                                ; preds = %2
  %7 = bitcast %"struct.Halide::Runtime::Internal::CpuFeatures"* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %7) #6
  call void @_ZN6Halide7Runtime8Internal23halide_get_cpu_featuresEv(%"struct.Halide::Runtime::Internal::CpuFeatures"* nonnull sret %3) #8
  %8 = call i8* @memcpy(i8* bitcast ([4 x i64]* @_ZN6Halide7Runtime8Internal27halide_cpu_features_storageE to i8*), i8* nonnull %7, i32 32) #8
  store i8 1, i8* @_ZN6Halide7Runtime8Internal31halide_cpu_features_initializedE, align 1, !tbaa !14
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %7) #6
  br label %9

9:                                                ; preds = %6, %2
  call void @halide_mutex_unlock(%struct.halide_mutex* nonnull @_ZN6Halide7Runtime8Internal36halide_cpu_features_initialized_lockE) #8
  %10 = icmp eq i32 %0, 2
  br i1 %10, label %12, label %11

11:                                               ; preds = %9
  call void @halide_error(i8* null, i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.97, i32 0, i32 0)) #8
  br label %12

12:                                               ; preds = %11, %9
  %13 = load i64, i64* %1, align 8, !tbaa !20
  %14 = load i64, i64* getelementptr inbounds ([4 x i64], [4 x i64]* @_ZN6Halide7Runtime8Internal27halide_cpu_features_storageE, i32 0, i32 0), align 8, !tbaa !20
  %15 = and i64 %14, %13
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %21, label %17

17:                                               ; preds = %12
  %18 = load i64, i64* getelementptr inbounds ([4 x i64], [4 x i64]* @_ZN6Halide7Runtime8Internal27halide_cpu_features_storageE, i32 0, i32 2), align 8, !tbaa !20
  %19 = and i64 %18, %15
  %20 = icmp eq i64 %19, %15
  br i1 %20, label %21, label %27

21:                                               ; preds = %17, %12
  %22 = getelementptr inbounds i64, i64* %1, i32 1
  %23 = load i64, i64* %22, align 8, !tbaa !20
  %24 = load i64, i64* getelementptr inbounds ([4 x i64], [4 x i64]* @_ZN6Halide7Runtime8Internal27halide_cpu_features_storageE, i32 0, i32 1), align 8, !tbaa !20
  %25 = and i64 %24, %23
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %33, label %29

27:                                               ; preds = %33, %29, %17
  %28 = phi i32 [ 0, %17 ], [ 0, %29 ], [ 1, %33 ]
  ret i32 %28

29:                                               ; preds = %21
  %30 = load i64, i64* getelementptr inbounds ([4 x i64], [4 x i64]* @_ZN6Halide7Runtime8Internal27halide_cpu_features_storageE, i32 0, i32 3), align 8, !tbaa !20
  %31 = and i64 %30, %25
  %32 = icmp eq i64 %31, %25
  br i1 %32, label %33, label %27

33:                                               ; preds = %29, %21
  br label %27
}

; Function Attrs: nounwind
define weak i32 (i32, i64*)* @halide_set_custom_can_use_target_features(i32 (i32, i64*)* %0) local_unnamed_addr #2 {
  %2 = load i32 (i32, i64*)*, i32 (i32, i64*)** @_ZN6Halide7Runtime8Internal30custom_can_use_target_featuresE, align 4, !tbaa !8
  store i32 (i32, i64*)* %0, i32 (i32, i64*)** @_ZN6Halide7Runtime8Internal30custom_can_use_target_featuresE, align 4, !tbaa !8
  ret i32 (i32, i64*)* %2
}

; Function Attrs: nounwind
define weak i32 @halide_can_use_target_features(i32 %0, i64* %1) local_unnamed_addr #2 {
  %3 = load i32 (i32, i64*)*, i32 (i32, i64*)** @_ZN6Halide7Runtime8Internal30custom_can_use_target_featuresE, align 4, !tbaa !8
  %4 = tail call i32 %3(i32 %0, i64* %1) #10
  ret i32 %4
}

; Function Attrs: nounwind
define linkonce void @_ZN6Halide7Runtime8Internal23halide_get_cpu_featuresEv(%"struct.Halide::Runtime::Internal::CpuFeatures"* noalias sret %0) local_unnamed_addr #2 {
  %2 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CpuFeatures", %"struct.Halide::Runtime::Internal::CpuFeatures"* %0, i32 0, i32 0, i32 0
  store i64 0, i64* %2, align 8, !tbaa !20
  %3 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CpuFeatures", %"struct.Halide::Runtime::Internal::CpuFeatures"* %0, i32 0, i32 1, i32 0
  store i64 0, i64* %3, align 8, !tbaa !20
  %4 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CpuFeatures", %"struct.Halide::Runtime::Internal::CpuFeatures"* %0, i32 0, i32 0, i32 1
  store i64 0, i64* %4, align 8, !tbaa !20
  %5 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CpuFeatures", %"struct.Halide::Runtime::Internal::CpuFeatures"* %0, i32 0, i32 1, i32 1
  store i64 0, i64* %5, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind
define weak void @halide_use_jit_module() local_unnamed_addr #2 {
  ret void
}

; Function Attrs: nounwind
define weak void @halide_release_jit_module() local_unnamed_addr #2 {
  ret void
}

; Function Attrs: nounwind
define i32 @gaussian3x3_hvx128(%struct.halide_buffer_t* noalias %input.buffer, %struct.halide_buffer_t* noalias %output.buffer) local_unnamed_addr #5 {
entry:
  %0 = alloca i32, align 4
  %1 = alloca i32, align 4
  %hvx_lock_result = tail call i32 @halide_qurt_hvx_lock(i8* null, i32 128) #6
  %2 = icmp eq i32 %hvx_lock_result, 0
  br i1 %2, label %"assert succeeded", label %call_destructor.exit, !prof !73

"assert succeeded":                               ; preds = %entry
  %3 = icmp eq %struct.halide_buffer_t* %output.buffer, null
  br i1 %3, label %"assert failed1", label %"assert succeeded2", !prof !74

4:                                                ; preds = %"assert failed1", %"assert failed3", %"assert failed5"
  %.ph = phi i32 [ %59, %"assert failed5" ], [ %8, %"assert failed3" ], [ %6, %"assert failed1" ]
  call void @halide_qurt_hvx_unlock_as_destructor(i8* null, i8* nonnull inttoptr (i32 1 to i8*)) #10
  br label %call_destructor.exit

call_destructor.exit:                             ; preds = %entry, %4
  %5 = phi i32 [ %.ph, %4 ], [ %hvx_lock_result, %entry ]
  ret i32 %5

"assert failed1":                                 ; preds = %"assert succeeded"
  %6 = tail call i32 @halide_error_buffer_argument_is_null(i8* null, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str, i32 0, i32 0)) #6
  br label %4

"assert succeeded2":                              ; preds = %"assert succeeded"
  %7 = icmp eq %struct.halide_buffer_t* %input.buffer, null
  br i1 %7, label %"assert failed3", label %"assert succeeded4", !prof !74

"assert failed3":                                 ; preds = %"assert succeeded2"
  %8 = tail call i32 @halide_error_buffer_argument_is_null(i8* null, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str.101, i32 0, i32 0)) #6
  br label %4

"assert succeeded4":                              ; preds = %"assert succeeded2"
  %9 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %input.buffer, i32 0, i32 2
  %10 = bitcast i32* %1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %10) #6
  %11 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %input.buffer, i32 0, i32 4, i32 0
  %12 = call i8* @memcpy(i8* nonnull %10, i8* nonnull %11, i32 4) #8
  %13 = load i32, i32* %1, align 4, !tbaa !12
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %10) #6
  %14 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %input.buffer, i32 0, i32 5
  %15 = load i32, i32* %14, align 4, !tbaa !34
  %16 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %input.buffer, i32 0, i32 6
  %17 = load %struct.halide_dimension_t*, %struct.halide_dimension_t** %16, align 8, !tbaa !35
  %18 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %17, i32 0, i32 0
  %19 = load i32, i32* %18, align 4, !tbaa !36
  %20 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %17, i32 0, i32 1
  %21 = load i32, i32* %20, align 4, !tbaa !38
  %22 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %17, i32 0, i32 2
  %23 = load i32, i32* %22, align 4, !tbaa !39
  %24 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %17, i32 1, i32 0
  %25 = load i32, i32* %24, align 4, !tbaa !36
  %26 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %17, i32 1, i32 1
  %27 = load i32, i32* %26, align 4, !tbaa !38
  %28 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %17, i32 1, i32 2
  %29 = load i32, i32* %28, align 4, !tbaa !39
  %30 = bitcast i32* %0 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %30) #6
  %31 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %output.buffer, i32 0, i32 4, i32 0
  %32 = call i8* @memcpy(i8* nonnull %30, i8* nonnull %31, i32 4) #8
  %33 = load i32, i32* %0, align 4, !tbaa !12
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %30) #6
  %34 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %output.buffer, i32 0, i32 5
  %35 = load i32, i32* %34, align 4, !tbaa !34
  %36 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %output.buffer, i32 0, i32 6
  %37 = load %struct.halide_dimension_t*, %struct.halide_dimension_t** %36, align 8, !tbaa !35
  %38 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %37, i32 0, i32 0
  %39 = load i32, i32* %38, align 4, !tbaa !36
  %40 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %37, i32 0, i32 1
  %41 = load i32, i32* %40, align 4, !tbaa !38
  %42 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %37, i32 0, i32 2
  %43 = load i32, i32* %42, align 4, !tbaa !39
  %44 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %37, i32 1, i32 0
  %45 = load i32, i32* %44, align 4, !tbaa !36
  %46 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %37, i32 1, i32 1
  %47 = load i32, i32* %46, align 4, !tbaa !38
  %48 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %37, i32 1, i32 2
  %49 = load i32, i32* %48, align 4, !tbaa !39
  %50 = load i8*, i8** %9, align 4, !tbaa !32
  %51 = icmp eq i8* %50, null
  br i1 %51, label %_halide_buffer_is_bounds_query.exit, label %"assert succeeded8"

_halide_buffer_is_bounds_query.exit:              ; preds = %"assert succeeded4"
  %52 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %input.buffer, i32 0, i32 0
  %53 = load i64, i64* %52, align 8, !tbaa !29
  %54 = icmp eq i64 %53, 0
  br i1 %54, label %"assert failed5", label %"assert succeeded8", !prof !74

"assert failed5":                                 ; preds = %_halide_buffer_is_bounds_query.exit
  %55 = add nsw i32 %41, -1
  %56 = and i32 %55, -128
  %57 = add nsw i32 %56, 129
  %58 = add nsw i32 %56, 128
  %59 = call i32 @halide_error_constraints_make_required_region_smaller(i8* null, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str.102, i32 0, i32 0), i32 0, i32 0, i32 %57, i32 -1, i32 %58) #6
  br label %4

"assert succeeded8":                              ; preds = %_halide_buffer_is_bounds_query.exit, %"assert succeeded4"
  %60 = icmp ne i32 %13, 67585
  %61 = zext i1 %60 to i64
  %62 = icmp eq i32 %15, 2
  %63 = select i1 %62, i64 0, i64 2
  %64 = icmp eq i32 %33, 67585
  %65 = select i1 %64, i64 0, i64 4
  %66 = icmp eq i32 %35, 2
  %67 = select i1 %66, i64 0, i64 8
  %68 = add i32 %41, -1
  %69 = and i32 %68, -128
  %70 = add nsw i32 %69, 129
  %71 = add nsw i32 %21, %19
  %72 = icmp sgt i32 %70, %71
  %73 = zext i1 %72 to i64
  %input.min.0.lobit = lshr i32 %19, 31
  %74 = xor i32 %input.min.0.lobit, 1
  %.not = zext i32 %74 to i64
  %75 = or i64 %73, %.not
  %76 = shl nuw nsw i64 %75, 4
  %input.extent.0.lobit = lshr i32 %21, 31
  %77 = shl nuw nsw i32 %input.extent.0.lobit, 5
  %78 = zext i32 %77 to i64
  %79 = add i32 %47, -1
  %80 = and i32 %79, -4
  %81 = add nsw i32 %80, 5
  %82 = add nsw i32 %27, %25
  %83 = icmp sgt i32 %81, %82
  %84 = zext i1 %83 to i64
  %input.min.1.lobit = lshr i32 %25, 31
  %85 = xor i32 %input.min.1.lobit, 1
  %.not36 = zext i32 %85 to i64
  %86 = or i64 %84, %.not36
  %87 = shl nuw nsw i64 %86, 6
  %input.extent.1.lobit = lshr i32 %27, 31
  %88 = shl nuw nsw i32 %input.extent.1.lobit, 7
  %89 = zext i32 %88 to i64
  %90 = icmp sgt i32 %39, 0
  %91 = add nsw i32 %41, 127
  %92 = and i32 %91, 127
  %93 = add nsw i32 %92, %39
  %94 = icmp slt i32 %93, 127
  %95 = or i1 %90, %94
  %96 = select i1 %95, i64 256, i64 0
  %output.extent.0.lobit = lshr i32 %41, 31
  %97 = shl nuw nsw i32 %output.extent.0.lobit, 9
  %98 = zext i32 %97 to i64
  %99 = icmp sgt i32 %45, 0
  %100 = add nsw i32 %47, 3
  %101 = and i32 %100, 3
  %102 = add nsw i32 %101, %45
  %103 = icmp slt i32 %102, 3
  %104 = or i1 %99, %103
  %105 = select i1 %104, i64 1024, i64 0
  %output.extent.1.lobit = lshr i32 %47, 31
  %106 = shl nuw nsw i32 %output.extent.1.lobit, 11
  %107 = zext i32 %106 to i64
  %108 = icmp eq i32 %23, 1
  %109 = select i1 %108, i64 0, i64 4096
  %110 = and i32 %29, 127
  %111 = icmp eq i32 %110, 0
  %112 = select i1 %111, i64 0, i64 16384
  %113 = icmp eq i32 %43, 1
  %114 = select i1 %113, i64 0, i64 65536
  %115 = icmp eq i32 %39, 0
  %116 = select i1 %115, i64 0, i64 131072
  %117 = and i32 %49, 127
  %118 = icmp eq i32 %117, 0
  %119 = select i1 %118, i64 0, i64 262144
  %120 = icmp eq i32 %45, 0
  %121 = select i1 %120, i64 0, i64 524288
  %122 = or i64 %63, %61
  %123 = or i64 %122, %78
  %124 = or i64 %123, %109
  %125 = or i64 %124, %89
  %126 = or i64 %125, %112
  %127 = or i64 %126, %65
  %128 = or i64 %127, %67
  %129 = or i64 %128, %116
  %130 = or i64 %129, %98
  %131 = or i64 %130, %114
  %132 = or i64 %131, %121
  %133 = or i64 %132, %96
  %134 = or i64 %133, %107
  %135 = or i64 %134, %76
  %136 = or i64 %135, %119
  %137 = or i64 %136, %105
  %138 = or i64 %137, %87
  %139 = or i64 %138, -9223372036854734848
  %140 = call i64 @llvm.cttz.i64(i64 %139, i1 true), !range !75
  %141 = trunc i64 %140 to i32
  switch i32 %141, label %no_errors_bb37 [
    i32 0, label %assert_failed
    i32 1, label %assert_failed9
    i32 2, label %assert_failed10
    i32 3, label %assert_failed11
    i32 4, label %assert_failed12
    i32 5, label %assert_failed13
    i32 6, label %assert_failed14
    i32 7, label %assert_failed15
    i32 8, label %assert_failed16
    i32 9, label %assert_failed17
    i32 10, label %assert_failed18
    i32 11, label %assert_failed19
    i32 12, label %assert_failed20
    i32 13, label %assert_failed21
    i32 14, label %assert_failed22
    i32 15, label %assert_failed23
  ], !prof !76

no_errors_bb37:                                   ; preds = %"assert succeeded8"
  unreachable

assert_failed:                                    ; preds = %"assert succeeded8"
  %142 = call i32 @halide_error_bad_type(i8* null, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str.102, i32 0, i32 0), i32 %13, i32 67585) #6
  ret i32 %142

assert_failed9:                                   ; preds = %"assert succeeded8"
  %143 = call i32 @halide_error_bad_dimensions(i8* null, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str.102, i32 0, i32 0), i32 %15, i32 2) #6
  ret i32 %143

assert_failed10:                                  ; preds = %"assert succeeded8"
  %144 = call i32 @halide_error_bad_type(i8* null, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str.103, i32 0, i32 0), i32 %33, i32 67585) #6
  ret i32 %144

assert_failed11:                                  ; preds = %"assert succeeded8"
  %145 = call i32 @halide_error_bad_dimensions(i8* null, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str.103, i32 0, i32 0), i32 %35, i32 2) #6
  ret i32 %145

assert_failed12:                                  ; preds = %"assert succeeded8"
  %146 = add nsw i32 %69, 128
  %147 = add nsw i32 %71, -1
  %148 = call i32 @halide_error_access_out_of_bounds(i8* null, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str.102, i32 0, i32 0), i32 0, i32 -1, i32 %146, i32 %19, i32 %147) #6
  ret i32 %148

assert_failed13:                                  ; preds = %"assert succeeded8"
  %149 = call i32 @halide_error_buffer_extents_negative(i8* null, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str.102, i32 0, i32 0), i32 0, i32 %21) #6
  ret i32 %149

assert_failed14:                                  ; preds = %"assert succeeded8"
  %150 = add nsw i32 %80, 4
  %151 = add nsw i32 %82, -1
  %152 = call i32 @halide_error_access_out_of_bounds(i8* null, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str.102, i32 0, i32 0), i32 1, i32 -1, i32 %150, i32 %25, i32 %151) #6
  ret i32 %152

assert_failed15:                                  ; preds = %"assert succeeded8"
  %153 = call i32 @halide_error_buffer_extents_negative(i8* null, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str.102, i32 0, i32 0), i32 1, i32 %27) #6
  ret i32 %153

assert_failed16:                                  ; preds = %"assert succeeded8"
  %154 = or i32 %68, 127
  %155 = add i32 %68, %39
  %156 = call i32 @halide_error_access_out_of_bounds(i8* null, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str.103, i32 0, i32 0), i32 0, i32 0, i32 %154, i32 %39, i32 %155) #6
  ret i32 %156

assert_failed17:                                  ; preds = %"assert succeeded8"
  %157 = call i32 @halide_error_buffer_extents_negative(i8* null, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str.103, i32 0, i32 0), i32 0, i32 %41) #6
  ret i32 %157

assert_failed18:                                  ; preds = %"assert succeeded8"
  %158 = or i32 %79, 3
  %159 = add i32 %79, %45
  %160 = call i32 @halide_error_access_out_of_bounds(i8* null, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str.103, i32 0, i32 0), i32 1, i32 0, i32 %158, i32 %45, i32 %159) #6
  ret i32 %160

assert_failed19:                                  ; preds = %"assert succeeded8"
  %161 = call i32 @halide_error_buffer_extents_negative(i8* null, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str.103, i32 0, i32 0), i32 1, i32 %47) #6
  ret i32 %161

assert_failed20:                                  ; preds = %"assert succeeded8"
  %162 = call i32 @halide_error_constraint_violated(i8* null, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str.104, i32 0, i32 0), i32 %23, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str.105, i32 0, i32 0), i32 1) #6
  ret i32 %162

assert_failed21:                                  ; preds = %"assert succeeded8"
  %163 = call i32 @halide_error_constraint_violated(i8* null, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str.106, i32 0, i32 0), i32 %19, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str.107, i32 0, i32 0), i32 0) #6
  ret i32 %163

assert_failed22:                                  ; preds = %"assert succeeded8"
  %164 = and i32 %29, -128
  %165 = call i32 @halide_error_constraint_violated(i8* null, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str.108, i32 0, i32 0), i32 %29, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str.109, i32 0, i32 0), i32 %164) #6
  ret i32 %165

assert_failed23:                                  ; preds = %"assert succeeded8"
  %166 = call i32 @halide_error_constraint_violated(i8* null, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str.110, i32 0, i32 0), i32 %25, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str.107, i32 0, i32 0), i32 0) #6
  ret i32 %166
}

; Function Attrs: nounwind readnone speculatable willreturn
declare i64 @llvm.cttz.i64(i64 %0, i1 immarg %1) #4

; Function Attrs: nounwind
define i32 @gaussian3x3_hvx128_argv(i8** nocapture readonly %0) local_unnamed_addr #6 {
entry:
  %1 = bitcast i8** %0 to %struct.halide_buffer_t**
  %2 = load %struct.halide_buffer_t*, %struct.halide_buffer_t** %1, align 4
  %3 = getelementptr i8*, i8** %0, i32 1
  %4 = bitcast i8** %3 to %struct.halide_buffer_t**
  %5 = load %struct.halide_buffer_t*, %struct.halide_buffer_t** %4, align 4
  %6 = tail call i32 @gaussian3x3_hvx128(%struct.halide_buffer_t* %2, %struct.halide_buffer_t* %5) #11
  ret i32 %6
}

; Function Attrs: norecurse nounwind readnone
define nonnull %struct.halide_filter_metadata_t* @gaussian3x3_hvx128_metadata() local_unnamed_addr #7 {
entry:
  ret %struct.halide_filter_metadata_t* @gaussian3x3_hvx128_metadata_storage
}

attributes #0 = { alwaysinline nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-builtins" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "no-builtins" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-builtins" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind willreturn }
attributes #4 = { nounwind readnone speculatable willreturn }
attributes #5 = { nounwind "reciprocal-estimates"="none" }
attributes #6 = { nounwind }
attributes #7 = { norecurse nounwind readnone }
attributes #8 = { nobuiltin nounwind "no-builtins" }
attributes #9 = { nobuiltin "no-builtins" }
attributes #10 = { nobuiltin nounwind }
attributes #11 = { noinline }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5, !6}
!llvm.ident = !{!7, !7, !7, !7, !7, !7, !7, !7, !7, !7, !7, !7, !7, !7, !7, !7, !7, !7, !7, !7}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, !"halide_use_soft_float_abi", i32 0}
!3 = !{i32 2, !"halide_mcpu", !"hexagonv62"}
!4 = !{i32 2, !"halide_mattrs", !"+hvx-length128b,+long-calls"}
!5 = !{i32 2, !"halide_use_pic", i32 1}
!6 = !{i32 2, !"halide_per_instruction_fast_math_flags", i32 0}
!7 = !{!"Ubuntu clang version 10.0.1-++20201013091236+ef32c611aa2-1~exp1~20201013191834.199"}
!8 = !{!9, !9, i64 0}
!9 = !{!"any pointer", !10, i64 0}
!10 = !{!"omnipotent char", !11, i64 0}
!11 = !{!"Simple C++ TBAA"}
!12 = !{!13, !13, i64 0}
!13 = !{!"int", !10, i64 0}
!14 = !{!15, !15, i64 0}
!15 = !{!"bool", !10, i64 0}
!16 = !{i8 0, i8 2}
!17 = !{!10, !10, i64 0}
!18 = !{!19, !19, i64 0}
!19 = !{!"double", !10, i64 0}
!20 = !{!21, !21, i64 0}
!21 = !{!"long long", !10, i64 0}
!22 = distinct !{!22, !23}
!23 = !{!"llvm.loop.unroll.disable"}
!24 = !{!25, !10, i64 0}
!25 = !{!"_ZTS13halide_type_t", !10, i64 0, !10, i64 1, !26, i64 2}
!26 = !{!"short", !10, i64 0}
!27 = !{!25, !10, i64 1}
!28 = !{!25, !26, i64 2}
!29 = !{!30, !21, i64 0}
!30 = !{!"_ZTS15halide_buffer_t", !21, i64 0, !9, i64 8, !9, i64 12, !21, i64 16, !25, i64 24, !13, i64 28, !9, i64 32, !9, i64 36}
!31 = !{!30, !9, i64 8}
!32 = !{!30, !9, i64 12}
!33 = !{!30, !21, i64 16}
!34 = !{!30, !13, i64 28}
!35 = !{!30, !9, i64 32}
!36 = !{!37, !13, i64 0}
!37 = !{!"_ZTS18halide_dimension_t", !13, i64 0, !13, i64 4, !13, i64 8, !13, i64 12}
!38 = !{!37, !13, i64 4}
!39 = !{!37, !13, i64 8}
!40 = !{!41, !9, i64 0}
!41 = !{!"_ZTS29halide_device_allocation_pool", !9, i64 0, !9, i64 4}
!42 = !{!41, !9, i64 4}
!43 = !{!44, !21, i64 0}
!44 = !{!"_ZTSN6Halide7Runtime8Internal11device_copyE", !21, i64 0, !21, i64 8, !21, i64 16, !10, i64 24, !10, i64 152, !10, i64 280, !21, i64 408}
!45 = !{!44, !21, i64 8}
!46 = !{!44, !21, i64 408}
!47 = !{!44, !21, i64 16}
!48 = distinct !{!48, !23}
!49 = distinct !{!49, !23}
!50 = !{i64 0, i64 8, !20, i64 8, i64 8, !20, i64 16, i64 8, !20, i64 24, i64 128, !17, i64 152, i64 128, !17, i64 280, i64 128, !17, i64 408, i64 8, !20}
!51 = !{!52, !9, i64 60}
!52 = !{!"_ZTS25halide_device_interface_t", !9, i64 0, !9, i64 4, !9, i64 8, !9, i64 12, !9, i64 16, !9, i64 20, !9, i64 24, !9, i64 28, !9, i64 32, !9, i64 36, !9, i64 40, !9, i64 44, !9, i64 48, !9, i64 52, !9, i64 56, !9, i64 60}
!53 = !{!54, !9, i64 24}
!54 = !{!"_ZTS30halide_device_interface_impl_t", !9, i64 0, !9, i64 4, !9, i64 8, !9, i64 12, !9, i64 16, !9, i64 20, !9, i64 24, !9, i64 28, !9, i64 32, !9, i64 36, !9, i64 40, !9, i64 44, !9, i64 48, !9, i64 52, !9, i64 56, !9, i64 60}
!55 = !{!54, !9, i64 20}
!56 = !{!54, !9, i64 28}
!57 = !{!54, !9, i64 0}
!58 = !{!54, !9, i64 8}
!59 = !{!54, !9, i64 4}
!60 = !{!54, !9, i64 16}
!61 = !{!54, !9, i64 12}
!62 = !{!54, !9, i64 32}
!63 = !{!54, !9, i64 36}
!64 = distinct !{!64, !23}
!65 = distinct !{!65, !23}
!66 = !{!54, !9, i64 56}
!67 = !{!54, !9, i64 60}
!68 = !{!54, !9, i64 40}
!69 = !{!54, !9, i64 44}
!70 = !{!54, !9, i64 48}
!71 = !{!54, !9, i64 52}
!72 = !{i32 22, i32 33}
!73 = !{!"branch_weights", i32 1073741824, i32 0}
!74 = !{!"branch_weights", i32 0, i32 1073741824}
!75 = !{i64 0, i64 14}
!76 = !{!"branch_weights", i32 1073741824, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0}
Module.compile(): object bin/gaussian3x3_hvx128.o
emit_file.Compiling to native code...
Target triple: hexagon-unknown--elf
Cloning module gaussian3x3_hvx128
free(): invalid pointer
Segmentation fault (core dumped)
Makefile:11: recipe for target 'bin/gaussian3x3.a' failed
make: *** [bin/gaussian3x3.a] Error 139
