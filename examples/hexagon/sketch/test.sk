pragma options "--bnd-cbits 1";
pragma options "--bnd-inbits 2";
pragma options "--bnd-int-range 150";
pragma options "--bnd-arr-size 1024";
pragma options "--bnd-unroll-amnt 10";
pragma options "--bnd-inline-amnt 9";
pragma options "--slv-parallel";
pragma options "--slv-p-cpus 28";
pragma options "--slv-lightverif";

include "types.sk";
include "casting.sk";
include "vector.sk";
include "grammar.sk";

int ARRAY_LEN = 1024;

harness void main (int[ARRAY_LEN] input_data, int t53) {
    Buffer input = new Buffer(data=input_data, elemT=uint8);

    Vector original_expr = vec_add(vec_add(vec_mul(cast_uint8vec_to_int16vec(ramp(input, t53, 1, 128)), broadcast(cast_int32_to_int16(2), 128, int16)), vec_mul(cast_uint8vec_to_int16vec(ramp(input, (t53 + 1), 1, 128)), broadcast(cast_int32_to_int16(3), 128, int16))), cast_uint8vec_to_int16vec(ramp(input, (t53 + 2), 1, 128)));

    Buffer _buf = {| input |};
    int _base = index_gen({ t53, (t53 + 1), (t53 + 2) });
    int _stride = ??(2);
    int _lanes = {| 128 | 64 | 32 | 16 |};
    Vector _v = ramp(_buf, _base, _stride, _lanes);
    Vector synthesized_expr = convolve_x_gen(_v, { cast_int32_to_int16(2), cast_int32_to_int16(3) });

    assert vec_eq(original_expr, synthesized_expr): "Original and synthesized expressions do not match.";
}