pragma options "--bnd-cbits 1";
pragma options "--bnd-inbits 2";
pragma options "--bnd-int-range 150";
pragma options "--bnd-arr-size 1024";
pragma options "--bnd-unroll-amnt 10";
pragma options "--bnd-inline-amnt 9";
//pragma options "--slv-simiters 15";
pragma options "--slv-parallel";
pragma options "--slv-p-cpus 28";
pragma options "--slv-lightverif";

include "casting.sk";
include "vector_adt.sk";

int ARRAY_LEN = 1024;

Vector orig (int[ARRAY_LEN] input, int x, int t51) {
    return vec_add(vec_add(vec_mul(cast_uint8vec_to_int16vec(ramp(input, (((x*128) + t51) + 3), 1, 128)), broadcast(cast_int32_to_int16(3), 128)), vec_add(vec_mul(cast_uint8vec_to_int16vec(ramp(input, (((x*128) + t51) + 2), 1, 128)), broadcast(cast_int32_to_int16(2), 128)), vec_add(vec_mul(vec_add(vec_add(vec_mul(cast_uint8vec_to_int16vec(ramp(input, ((x*128) + t51), 1, 128)), broadcast(cast_int32_to_int16(2), 128)), vec_mul(cast_uint8vec_to_int16vec(ramp(input, (((x*128) + t51) + 1), 1, 128)), broadcast(cast_int32_to_int16(3), 128))), cast_uint8vec_to_int16vec(ramp(input, (((x*128) + t51) + 2), 1, 128))), broadcast(cast_int32_to_int16(4), 128)), vec_mul(vec_add(vec_add(vec_mul(cast_uint8vec_to_int16vec(ramp(input, (((x*128) + t51) + 1), 1, 128)), broadcast(cast_int32_to_int16(2), 128)), vec_mul(cast_uint8vec_to_int16vec(ramp(input, (((x*128) + t51) + 2), 1, 128)), broadcast(cast_int32_to_int16(3), 128))), cast_uint8vec_to_int16vec(ramp(input, (((x*128) + t51) + 3), 1, 128))), broadcast(cast_int32_to_int16(5), 128))))), cast_uint8vec_to_int16vec(ramp(input, (((x*128) + t51) + 4), 1, 128)));
}

generator int index_gen ([int N], int[N] exprs) {
    int i = ??(3);
    int c = ??(2);

    assert i < N;

    int expr = exprs[i];
    return {| expr | expr + c | expr - c |};
}

generator int int_expr_gen ([int N], int[N] terms) {
    assert N <= 32 : "Too many terms given to the generator";

    int[32] exprs = terms;

    int steps = ??(2);

    int idx = N;

    repeat (steps) {
        int idx_e1 = ??(4);
        int idx_e2 = ??(4);

        assert idx_e1 < idx;
        assert idx_e2 < idx;
        assert idx_e1 < idx_e2;

        int e1 = exprs[idx_e1];
        int e2 = exprs[idx_e2];
        int c = ??(3);

        exprs[idx] = {| e1 +- c | e1 + e2 | e1 * e2 |};

        idx++;
    }

    minimize(steps);

    return exprs[idx-1];
}

generator Vector vdmpy_gen (int[ARRAY_LEN] input, int x, int t20) {
    int base = index_gen({((x*128) + t20), ((x*128) + t20) + 1, ((x*128) + t20) + 2});
    int stride = 1;
    int lanes = 128;
    int[2] kernel = {};
    repeat(i : 2) {
        kernel[i] = int_expr_gen({2, 3, 4, 5});
    };
    return vdmpy(input, base, stride, lanes, kernel);
}

generator Vector vtmpy_gen (int[ARRAY_LEN] input, int x, int t20) {
    int base = index_gen({((x*128) + t20), ((x*128) + t20) + 1, ((x*128) + t20) + 2});
    int stride = 1;
    int lanes = 128;
    int[2] kernel = {};
    repeat(i : 2) {
        kernel[i] = int_expr_gen({2, 3, 4, 5});
    };
    return vtmpy(input, base, stride, lanes, kernel);
}

generator Vector vrmpy_gen (int[ARRAY_LEN] input, int x, int t20) {
    int base = index_gen({((x*128) + t20), ((x*128) + t20) + 1, ((x*128) + t20) + 2});
    int stride = 1;
    int lanes = 128;
    int[4] kernel = {};
    repeat(i : 4) {
        kernel[i] = int_expr_gen({2, 3, 4, 5}); // Constants found in input code
    };
    return vrmpy(input, base, stride, lanes, kernel);
}

generator Vector synth (int[ARRAY_LEN] input, int x, int t20) {
    int instr = ??(2);
    //if (instr == 0)
        //return vdmpy_gen(input, x, t20);
    //else if (instr == 1)
      //  return vtmpy_gen(input, x, t20);
    //else
        return vrmpy_gen(input, x, t20);
}

harness void main (int x, int t20, int[ARRAY_LEN] input) {
    Vector original_expr = orig(input, x, t20);
    Vector synthesized_expr = synth(input, x, t20);

    assert vec_eq(original_expr, synthesized_expr): "Original and synthesized expressions do not match.";
}