let scalar_indices = _halide_hexagon_buffer_get_host(scalar_indices.buffer)
assert(((reinterpret(uint64, scalar_indices) % (uint64)128) == (uint64)0), halide_error_unaligned_host_ptr("scalar_indices", 128))
let input = _halide_hexagon_buffer_get_host(input.buffer)
assert(((reinterpret(uint64, input) % (uint64)128) == (uint64)0), halide_error_unaligned_host_ptr("input", 128))
let blur_y = _halide_hexagon_buffer_get_host(blur_y.buffer)
assert(((reinterpret(uint64, blur_y) % (uint64)128) == (uint64)0), halide_error_unaligned_host_ptr("blur_y", 128))
let t98 = scalar_indices[14]
let t96 = scalar_indices[13]
let t94 = scalar_indices[12]
let t93 = scalar_indices[11]
let t91 = scalar_indices[10]
let t89 = scalar_indices[9]
let t87 = scalar_indices[8]
let t86 = scalar_indices[7]
let t84 = scalar_indices[6]
let t82 = scalar_indices[5]
let input.stride.1 = scalar_indices[4]
let blur_y.stride.1 = scalar_indices[3]
let blur_y.min.1 = scalar_indices[2]
let blur_y.extent.1 = scalar_indices[1]
let blur_y.extent.0 = scalar_indices[0]
parallel (blur_y.s0.y.y, 0, t82) {
  if ((let t119.s = min(((blur_y.s0.y.y*128) + 384), blur_y.extent.1) in (((t84 <= (blur_y.min.1 + t119.s)) && t83) && (((blur_y.min.1 + t119.s) + 2) <= t86)))) {
    prefetch(input, ((((min(((blur_y.s0.y.y*128) + 384), blur_y.extent.1) + blur_y.min.1) + -128)*input.stride.1) + t87), t89, 1, 130, input.stride.1)
  }
  let blur_y.s0.y.yi.base.s = min((blur_y.s0.y.y*128), (blur_y.extent.1 + -128))
  allocate blur_x[uint16 * blur_y.extent.0 * 4]
  for (blur_y.s0.y.yi, 0, 128) {
    let blur_x.s0.y.min_2 = (select((0 < blur_y.s0.y.yi), (blur_y.s0.y.yi + 2), blur_y.s0.y.yi) + (blur_y.min.1 + blur_y.s0.y.yi.base.s))
    produce blur_x {
      let t111 = select((0 < blur_y.s0.y.yi), 1, 3)
      for (blur_x.s0.y, blur_x.s0.y.min_2, t111) {
        for (blur_x.s0.x.x, 0, t91) {
          blur_x[ramp(((blur_x.s0.x.x*128) + ((blur_x.s0.y % 4)*blur_y.extent.0)), 1, 128)] = (let t120 = ((blur_x.s0.x.x*128) + ((blur_x.s0.y*input.stride.1) + t87)) in ((input[ramp((t120 + 1), 1, 128)] + (input[ramp((t120 + 2), 1, 128)] + input[ramp(t120, 1, 128)]))/x128((uint16)3)))
        }
        if (t92) {
          blur_x[ramp(((((blur_x.s0.y % 4) + 1)*blur_y.extent.0) + -128), 1, 128)] = ((input[ramp((((blur_x.s0.y*input.stride.1) + t93) + -127), 1, 128)] + (input[ramp((((blur_x.s0.y*input.stride.1) + t93) + -126), 1, 128)] + input[ramp((((blur_x.s0.y*input.stride.1) + t93) + -128), 1, 128)]))/x128((uint16)3))
        }
      }
    }
    consume blur_x {
      for (blur_y.s0.x.x, 0, t94) {
        blur_y[ramp(((blur_y.s0.x.x*256) + ((((blur_y.min.1 + blur_y.s0.y.yi.base.s) + blur_y.s0.y.yi)*blur_y.stride.1) + t96)), 1, 256)] = (let t122 = ((blur_y.s0.x.x*256) + (((((blur_y.min.1 + blur_y.s0.y.yi.base.s) + blur_y.s0.y.yi) + 1) % 4)*blur_y.extent.0)) in (let t123 = ((blur_y.s0.x.x*256) + (((((blur_y.min.1 + blur_y.s0.y.yi.base.s) + blur_y.s0.y.yi) + 2) % 4)*blur_y.extent.0)) in (let t124 = ((blur_y.s0.x.x*256) + ((((blur_y.min.1 + blur_y.s0.y.yi.base.s) + blur_y.s0.y.yi) % 4)*blur_y.extent.0)) in ((blur_x[ramp(t122, 1, 256)] + (blur_x[ramp(t123, 1, 256)] + blur_x[ramp(t124, 1, 256)]))/x256((uint16)3)))))
      }
      if (t97) {
        blur_y[ramp(((((blur_y.min.1 + blur_y.s0.y.yi.base.s) + blur_y.s0.y.yi)*blur_y.stride.1) + t98), 1, 256)] = ((blur_x[ramp((((((((blur_y.min.1 + blur_y.s0.y.yi.base.s) + blur_y.s0.y.yi) + 1) % 4) + 1)*blur_y.extent.0) + -256), 1, 256)] + (blur_x[ramp((((((((blur_y.min.1 + blur_y.s0.y.yi.base.s) + blur_y.s0.y.yi) + 2) % 4) + 1)*blur_y.extent.0) + -256), 1, 256)] + blur_x[ramp(((((((blur_y.min.1 + blur_y.s0.y.yi.base.s) + blur_y.s0.y.yi) % 4) + 1)*blur_y.extent.0) + -256), 1, 256)]))/x256((uint16)3))
      }
    }
  }
  free blur_x
}