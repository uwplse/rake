pragma options "--bnd-cbits 1";
pragma options "--bnd-inbits 2";
pragma options "--bnd-arr-size 1024";
//pragma options "--bnd-inline-amnt 1901";
//pragma options "--fe-fpencoding AS_FIXPOINT";

include "casting.sk";
include "vector.sk";

int ARRAY_LEN = 1024;

vector orig (int[ARRAY_LEN] input, int x, int t20) {
    return vec_add(vec_add(vec_mul(cast_uint8vec_to_int16vec(ramp(input, ((x*128) + t20), 1, 128)), broadcast(cast_int32_to_int16(3), 128)), vec_mul(cast_uint8vec_to_int16vec(ramp(input, (((x*128) + t20) + 1), 1, 128)), broadcast(cast_int32_to_int16(2), 128))), cast_uint8vec_to_int16vec(ramp(input, (((x*128) + t20) + 2), 1, 128)));
}

vector vtmpy (int[ARRAY_LEN] buffer, int base, int stride, int lanes, int[2] kernel) {
    // Force sketch to unroll the loop
    if (lanes == 128) {
        int[128] data;
        for (int i=0; i<128; i++)
            data[i] = buffer[base + (i*stride)]*kernel[0] + buffer[base+ (stride * (i+1))]*kernel[1] + buffer[base + ((i+2)*stride)];//; //buffer[base + (i*stride)]*kernel[0];// + buffer[i+1]*kernel[1] + buffer[i+2];
        return new vector(lanes=128, data=data);
    }
    else {
        assert false : "Unexpected number of lanes";
    }
}

vector synth (int[ARRAY_LEN] input, int x, int t20) {
    int base = (x*128) + t20;
    int stride = 1;
    int lanes = 128;
    int[2] kernel = {3, 2};
    return vtmpy(input, base, stride, lanes, kernel);
}

harness void main (int x, int t20, int[ARRAY_LEN] input) {
    vector original_expr = orig(input, x, t20);
    vector synthesized_expr = synth(input, x, t20);

    assert vec_eq(original_expr, synthesized_expr): "Original and synthesized expressions do not match.";
}